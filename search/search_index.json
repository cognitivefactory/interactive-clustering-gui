{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Interactive Clustering GUI \u00b6 An annotation tool for NLP data based on Interactive Clustering methodology. Quick description \u00b6 Interactive clustering is a method intended to assist in the design of a training data set. This iterative process begins with an unlabeled dataset, and it uses a sequence of two substeps : the user defines constraints on data sampled by the computer ; the computer performs data partitioning using a constrained clustering algorithm. Thus, at each step of the process : the user corrects the clustering of the previous steps using constraints, and the computer offers a corrected and more relevant data partitioning for the next step. This web application implements this annotation methodology with several features: data preprocessing and vectorization in order to reduce noise in data; constrainted clustering in order to automatically partition the data; constraints sampling in order to select the most relevant data to annotate; binary constraints annotation in order to correct clustering relevance; annotation review and conflicts analysis in order to improve constraints consistency. For more details, read the Documentation and the articles in the References section. Documentation \u00b6 Main documentation Requirements \u00b6 Interactive Clustering GUI requires Python 3.7 or above. To install Python 3.7, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.7 pyenv install 3 .7 # make it available globally pyenv global system 3 .7 Installation \u00b6 With pip : # install package python3 -m pip install cognitivefactory-interactive-clustering-gui # install spacy language model dependencies (the one you want, with version \"3.1.x\") python3 -m spacy download fr_core_news_md-3.1.0 --direct With pipx : # install pipx python3 -m pip install --user pipx # install package pipx install --python python3 cognitivefactory-interactive-clustering-gui # install spacy language model dependencies (the one you want, with version \"3.1.x\") python3 -m spacy download fr_core_news_md-3.1.0 --direct Development \u00b6 To work on this project or contribute to it, please read the Copier PDM documentation . Quick setup and help \u00b6 Get the code and prepare the environment: git clone https://github.com/cognitivefactory/interactive-clustering-gui/ cd interactive-clustering-gui make setup Show the help: make help # or just make For more details, read the Contributing documentation. References \u00b6 Interactive Clustering : First presentation: Schild, E., Durantin, G., Lamirel, J.C., & Miconi, F. (2021). Conception it\u00e9rative et semi-supervis\u00e9e d'assistants conversationnels par regroupement interactif des questions. In EGC 2021 - 21\u00e8mes Journ\u00e9es Francophones Extraction et Gestion des Connaissances. Edition RNTI. \u27e8hal-03133007\u27e9. Theoretical study: Schild, E., Durantin, G., Lamirel, J., & Miconi, F. (2022). Iterative and Semi-Supervised Design of Chatbots Using Interactive Clustering. International Journal of Data Warehousing and Mining (IJDWM), 18(2), 1-19. http://doi.org/10.4018/IJDWM.298007. \u27e8hal-03648041\u27e9. Methodological discussion: Schild, E., Durantin, G., & Lamirel, J.C. (2021). Concevoir un assistant conversationnel de mani\u00e8re it\u00e9rative et semi-supervis\u00e9e avec le clustering interactif. In Atelier - Fouille de Textes - Text Mine 2021 - En conjonction avec EGC 2021. \u27e8hal-03133060\u27e9. Implementation: Schild, E. (2021). cognitivefactory/interactive-clustering. Zenodo. https://doi.org/10.5281/zenodo.4775251. Web application : FastAPI : https://fastapi.tiangolo.com/ How to cite \u00b6 Schild, E. (2021). cognitivefactory/interactive-clustering-gui. Zenodo. https://doi.org/10.5281/zenodo.4775270.","title":"Overview"},{"location":"#interactive-clustering-gui","text":"An annotation tool for NLP data based on Interactive Clustering methodology.","title":"Interactive Clustering GUI"},{"location":"#quick-description","text":"Interactive clustering is a method intended to assist in the design of a training data set. This iterative process begins with an unlabeled dataset, and it uses a sequence of two substeps : the user defines constraints on data sampled by the computer ; the computer performs data partitioning using a constrained clustering algorithm. Thus, at each step of the process : the user corrects the clustering of the previous steps using constraints, and the computer offers a corrected and more relevant data partitioning for the next step. This web application implements this annotation methodology with several features: data preprocessing and vectorization in order to reduce noise in data; constrainted clustering in order to automatically partition the data; constraints sampling in order to select the most relevant data to annotate; binary constraints annotation in order to correct clustering relevance; annotation review and conflicts analysis in order to improve constraints consistency. For more details, read the Documentation and the articles in the References section.","title":" Quick description"},{"location":"#documentation","text":"Main documentation","title":" Documentation"},{"location":"#requirements","text":"Interactive Clustering GUI requires Python 3.7 or above. To install Python 3.7, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.7 pyenv install 3 .7 # make it available globally pyenv global system 3 .7","title":" Requirements"},{"location":"#installation","text":"With pip : # install package python3 -m pip install cognitivefactory-interactive-clustering-gui # install spacy language model dependencies (the one you want, with version \"3.1.x\") python3 -m spacy download fr_core_news_md-3.1.0 --direct With pipx : # install pipx python3 -m pip install --user pipx # install package pipx install --python python3 cognitivefactory-interactive-clustering-gui # install spacy language model dependencies (the one you want, with version \"3.1.x\") python3 -m spacy download fr_core_news_md-3.1.0 --direct","title":" Installation"},{"location":"#development","text":"To work on this project or contribute to it, please read the Copier PDM documentation .","title":" Development"},{"location":"#quick-setup-and-help","text":"Get the code and prepare the environment: git clone https://github.com/cognitivefactory/interactive-clustering-gui/ cd interactive-clustering-gui make setup Show the help: make help # or just make For more details, read the Contributing documentation.","title":"Quick setup and help"},{"location":"#references","text":"Interactive Clustering : First presentation: Schild, E., Durantin, G., Lamirel, J.C., & Miconi, F. (2021). Conception it\u00e9rative et semi-supervis\u00e9e d'assistants conversationnels par regroupement interactif des questions. In EGC 2021 - 21\u00e8mes Journ\u00e9es Francophones Extraction et Gestion des Connaissances. Edition RNTI. \u27e8hal-03133007\u27e9. Theoretical study: Schild, E., Durantin, G., Lamirel, J., & Miconi, F. (2022). Iterative and Semi-Supervised Design of Chatbots Using Interactive Clustering. International Journal of Data Warehousing and Mining (IJDWM), 18(2), 1-19. http://doi.org/10.4018/IJDWM.298007. \u27e8hal-03648041\u27e9. Methodological discussion: Schild, E., Durantin, G., & Lamirel, J.C. (2021). Concevoir un assistant conversationnel de mani\u00e8re it\u00e9rative et semi-supervis\u00e9e avec le clustering interactif. In Atelier - Fouille de Textes - Text Mine 2021 - En conjonction avec EGC 2021. \u27e8hal-03133060\u27e9. Implementation: Schild, E. (2021). cognitivefactory/interactive-clustering. Zenodo. https://doi.org/10.5281/zenodo.4775251. Web application : FastAPI : https://fastapi.tiangolo.com/","title":" References"},{"location":"#how-to-cite","text":"Schild, E. (2021). cognitivefactory/interactive-clustering-gui. Zenodo. https://doi.org/10.5281/zenodo.4775270.","title":" How to cite"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.2.1 - 2022-08-25 \u00b6 Compare with 0.2.0 Bug Fixes \u00b6 remove direct dependency to spacy-models/fr-core-news-md ( f02894d by SCHILD Erwan). 0.2.0 - 2022-08-25 \u00b6 Compare with 0.1.3 Bug Fixes \u00b6 handle timezone and pickle5 ( abad506 by SCHILD Erwan). Build \u00b6 add .gitignore ( 14addf6 by SCHILD Erwan). update pyproject.toml with url dependencies ( e2c147a by SCHILD Erwan). update copier-pdm template to 0.9.10 ( fa67838 by SCHILD Erwan). Code Refactoring \u00b6 remove MVP app ( 6173cde by SCHILD Erwan). Features \u00b6 implementation of web application (background tasks, constraints annotation, conflicts resolution) ( c51c2bd by SCHILD Erwan). 0.1.3 - 2021-09-01 \u00b6 Compare with 0.1.2 Build \u00b6 update project from poetry to pdm ( 371cb99 by Erwan Schild) 0.1.2 - 2021-05-19 \u00b6 Compare with 0.1.1 0.1.1 - 2021-05-18 \u00b6 Compare with 0.1.0 0.1.0 - 2021-05-18 \u00b6 Compare with first commit","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#021-2022-08-25","text":"Compare with 0.2.0","title":"0.2.1 - 2022-08-25"},{"location":"changelog/#bug-fixes","text":"remove direct dependency to spacy-models/fr-core-news-md ( f02894d by SCHILD Erwan).","title":"Bug Fixes"},{"location":"changelog/#020-2022-08-25","text":"Compare with 0.1.3","title":"0.2.0 - 2022-08-25"},{"location":"changelog/#bug-fixes_1","text":"handle timezone and pickle5 ( abad506 by SCHILD Erwan).","title":"Bug Fixes"},{"location":"changelog/#build","text":"add .gitignore ( 14addf6 by SCHILD Erwan). update pyproject.toml with url dependencies ( e2c147a by SCHILD Erwan). update copier-pdm template to 0.9.10 ( fa67838 by SCHILD Erwan).","title":"Build"},{"location":"changelog/#code-refactoring","text":"remove MVP app ( 6173cde by SCHILD Erwan).","title":"Code Refactoring"},{"location":"changelog/#features","text":"implementation of web application (background tasks, constraints annotation, conflicts resolution) ( c51c2bd by SCHILD Erwan).","title":"Features"},{"location":"changelog/#013-2021-09-01","text":"Compare with 0.1.2","title":"0.1.3 - 2021-09-01"},{"location":"changelog/#build_1","text":"update project from poetry to pdm ( 371cb99 by Erwan Schild)","title":"Build"},{"location":"changelog/#012-2021-05-19","text":"Compare with 0.1.1","title":"0.1.2 - 2021-05-19"},{"location":"changelog/#011-2021-05-18","text":"Compare with 0.1.0","title":"0.1.1 - 2021-05-18"},{"location":"changelog/#010-2021-05-18","text":"Compare with first commit","title":"0.1.0 - 2021-05-18"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at erwan.schild@e-i.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at erwan.schild@e-i.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00b6 Nothing easier! Fork and clone the repository, then: cd interactive-clustering-gui make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with make run . Run make help to see all the available actions! Tasks \u00b6 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not. Development \u00b6 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00b6 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00b6 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd interactive-clustering-gui make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with make run . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"These projects were used to build cognitivefactory-interactive-clustering-gui . Thank you! python | pdm | copier-pdm Runtime dependencies \u00b6 Project Summary Version (accepted) Version (last resolved) License anyio High level compatibility layer for multiple asynchronous event loop implementations <5,>=3.4.0 3.6.1 MIT blis The Blis BLAS-like linear algebra library, as a self-contained C-extension. <0.8.0,>=0.4.0 0.7.8 BSD catalogue Super lightweight function registries for your library <2.1.0,>=2.0.6 2.0.8 MIT certifi Python package for providing Mozilla's CA Bundle. >=2017.4.17 2022.6.15 MPL-2.0 charset-normalizer The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <3,>=2 2.1.1 MIT click Composable command line interface toolkit <8.1.0 8.0.4 BSD-3-Clause cognitivefactory-interactive-clustering Python package used to apply NLP interactive clustering methods. >=0.5.2 0.5.2 CECILL-C colorama Cross-platform colored terminal text. >=0.3.4; sys_platform == \"win32\" 0.4.5 BSD cymem Manage calls to calloc/free through Cython <2.1.0,>=2.0.2 2.0.6 MIT et-xmlfile An implementation of lxml.xmlfile for the standard library 1.1.0 MIT fastapi FastAPI framework, high performance, easy to learn, fast to code, ready for production >=0.65.2 0.80.0 MIT License filelock A platform independent file lock. >=3.0.12 3.8.0 Unlicense h11 A pure-Python, bring-your-own-I/O implementation of HTTP/1.1 >=0.8 0.12.0 MIT idna Internationalized Domain Names in Applications (IDNA) >=2.8 3.3 BSD-3-Clause importlib-metadata Read metadata from Python packages >=4.8.1 4.12.0 Apache Software License jinja2 A very fast and expressive template engine. >=3.0.1 3.1.2 BSD-3-Clause joblib Lightweight pipelining with Python functions >=0.11 1.1.0 BSD loguru Python logging made (stupidly) simple >=0.5.3 0.6.0 MIT license markupsafe Safely add untrusted strings to HTML/XML markup. >=2.0 2.1.1 BSD-3-Clause murmurhash Cython bindings for MurmurHash <1.1.0,>=0.28.0 1.0.8 MIT networkx Python package for creating and manipulating graphs and networks >=2.5 2.6.3 BSD License numpy NumPy is the fundamental package for array computing with Python. >=1.19.5 1.21.1 BSD openpyxl A Python library to read/write Excel 2010 xlsx/xlsm files >=3.0.7 3.0.10 MIT packaging Core utilities for Python packages >=20.0 21.3 BSD-2-Clause or Apache-2.0 pandas Powerful data structures for data analysis, time series, and statistics >=1.1.4 1.1.5 BSD pathy pathlib.Path subclasses for local and cloud bucket storage >=0.3.5 0.6.2 Apache 2.0 pickle5 Backport of the pickle 5 protocol (PEP 574) and other pickle changes >=0.0.12; python_version < '3.8' 0.0.12 ? preshed Cython hash table that trusts the keys are pre-hashed <3.1.0,>=3.0.2 3.0.7 MIT prometheus-client Python client for the Prometheus monitoring system. <1.0.0,>=0.8.0 0.14.1 Apache Software License 2.0 prometheus-fastapi-instrumentator Instrument your FastAPI with Prometheus metrics >=5.5.1 5.9.1 ISC pydantic Data validation and settings management using python 3.6 type hinting !=1.7,!=1.7.1,!=1.7.2,!=1.7.3,!=1.8,!=1.8.1,<2.0.0,>=1.6.2 1.8.2 MIT pyparsing pyparsing module - Classes and methods to define and execute parsing grammars !=3.0.5,>=2.0.2 3.0.9 MIT License python-dateutil Extensions to the standard Python datetime module >=2.7.3 2.8.2 Dual License python-multipart A streaming multipart parser for Python >=0.0.5 0.0.5 Apache pytz World timezone definitions, modern and historical >=2017.2 2022.2.1 MIT requests Python HTTP for Humans. <3.0.0,>=2.13.0 2.28.1 Apache 2.0 scikit-learn A set of python modules for machine learning and data mining >=0.24.1 1.0.2 new BSD scipy SciPy: Scientific Library for Python >=1.5.3 1.6.1 BSD setuptools Easily download, build, install, upgrade, and uninstall Python packages 65.2.0 MIT License six Python 2 and 3 compatibility utilities >=1.5 1.16.0 MIT smart-open Utils for streaming large files (S3, HDFS, GCS, Azure Blob Storage, gzip, bz2...) <6.0.0,>=5.2.1 5.2.1 MIT sniffio Sniff out which async library your code is running under >=1.1 1.2.0 MIT -or- Apache License 2.0 spacy Industrial-strength Natural Language Processing (NLP) in Python <3.2,>=3.1 3.1.6 MIT spacy-legacy Legacy registered functions for spaCy backwards compatibility <3.1.0,>=3.0.8 3.0.10 MIT srsly Modern high-performance serialization utilities for Python <3.0.0,>=2.4.1 2.4.4 MIT starlette The little ASGI library that shines. ==0.19.1 0.19.1 BSD thinc A refreshing functional take on deep learning, compatible with your favorite libraries <8.1.0,>=8.0.12 8.0.17 MIT threadpoolctl threadpoolctl >=2.0.0 3.1.0 BSD-3-Clause tqdm Fast, Extensible Progress Meter <5.0.0,>=4.38.0 4.64.0 MPLv2.0, MIT Licences typer Typer, build great CLIs. Easy to code. Based on Python type hints. <0.5.0,>=0.3.0 0.4.2 MIT License typing-extensions Backported and Experimental Type Hints for Python 3.5+ >=3.6.4; python_version < \"3.8\" 3.10.0.2 PSF urllib3 HTTP library with thread-safe connection pooling, file post, and more. <1.27,>=1.21.1 1.26.12 MIT uvicorn The lightning-fast ASGI server. >=0.12.2 0.18.3 BSD License wasabi A lightweight console printing and formatting toolkit <1.1.0,>=0.8.1 0.10.1 MIT win32-setctime A small Python utility to set file creation time on Windows >=1.0.0; sys_platform == \"win32\" 1.1.0 MIT license zipp Backport of pathlib-compatible object wrapper for zip files >=3.5.0 3.8.1 MIT License Development dependencies \u00b6 Project Summary Version (accepted) Version (last resolved) License ansimarkup Produce colored terminal text with an xml-like markup ~=1.4 1.5.0 Revised BSD License anyio High level compatibility layer for multiple asynchronous event loop implementations ==3.* 3.6.1 MIT astor Read/rewrite/write Python ASTs >=0.8 0.8.1 BSD-3-Clause atomicwrites Atomic file writes. >=1.0; sys_platform == \"win32\" 1.4.1 MIT attrs Classes Without Boilerplate >=19.2.0 22.1.0 MIT autoflake Removes unused imports and unused variables >=1.4 1.4 Expat License bandit Security oriented static analyser for python code. >=1.7.3 1.7.4 Apache-2.0 license black The uncompromising code formatter. >=21.10b0 22.6.0 MIT blis The Blis BLAS-like linear algebra library, as a self-contained C-extension. <0.8.0,>=0.4.0 0.7.8 BSD brotli Python bindings for the Brotli compression library 1.0.9 MIT cached-property A decorator for caching properties in classes. ~=1.5; python_version < \"3.8\" 1.5.2 ? catalogue Super lightweight function registries for your library <2.1.0,>=2.0.6 2.0.8 MIT certifi Python package for providing Mozilla's CA Bundle. 2022.6.15 MPL-2.0 cffi Foreign Function Interface for Python calling C code. ; implementation_name == \"pypy\" 1.15.1 MIT charset-normalizer The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <3,>=2 2.1.1 MIT click Composable command line interface toolkit >=8.0.0 8.0.4 BSD-3-Clause colorama Cross-platform colored terminal text. ; platform_system == \"Windows\" 0.4.5 BSD configargparse A drop-in replacement for argparse that allows options to also be set via config files and/or environment variables. >=1.0 1.5.3 MIT coverage Code coverage measurement for Python [toml]>=5.2.1 6.4.4 Apache 2.0 cymem Manage calls to calloc/free through Cython <2.1.0,>=2.0.2 2.0.6 MIT darglint A utility for ensuring Google-style docstrings stay up to date with the source code. >=1.8 1.8.1 MIT dparse A parser for Python dependency files >=0.5.1 0.5.2 MIT license duty A simple task runner. >=0.7 0.7.0 Other/Proprietary License exceptiongroup Backport of PEP 654 (exception groups) >=1.0.0rc8; python_version < \"3.11\" 1.0.0rc8 MIT License execnet execnet: rapid multi-Python deployment >=1.1 1.9.0 MIT failprint Run a command, print its output only if it fails. ~=0.8 0.8.0 Other/Proprietary License flake8 the modular source code checker: pep8 pyflakes and co 3.9.2 MIT flake8-bandit Automated security testing with bandit and flake8. >=2.1 3.0.0 MIT flake8-black flake8 plugin to call black as a code style validator >=0.2 0.3.3 MIT flake8-bugbear A plugin for flake8 finding likely bugs and design problems in your program. Contains warnings that don't belong in pyflakes and pycodestyle. >=21.9 22.8.23 MIT flake8-builtins Check for python builtins being used as variables or parameters. >=1.5 1.5.3 GPL version 2 flake8-comprehensions A flake8 plugin to help you write better list/set/dict comprehensions. >=3.7 3.10.0 MIT flake8-docstrings Extension for flake8 which uses pydocstyle to check docstrings >=1.6 1.6.0 MIT License flake8-plugin-utils The package provides base classes and utils for flake8 plugin writing <2.0.0,>=1.3.2 1.3.2 MIT flake8-polyfill Polyfill package for Flake8 plugins 1.0.2 MIT flake8-pytest-style A flake8 plugin checking common style issues or inconsistencies with pytest-based tests. >=1.5 1.6.0 MIT flake8-string-format string format checker, plugin for flake8 >=0.3 0.3.0 MIT License flake8-tidy-imports A flake8 plugin that helps you write tidier imports. >=4.5 4.8.0 MIT flake8-variables-names A flake8 extension that helps to make more readable variables names >=0.0 0.0.5 MIT flask A simple framework for building complex web applications. >=2.0.0 2.2.2 BSD-3-Clause flask-basicauth HTTP basic access authentication for Flask. >=0.2.0 0.2.0 BSD flask-cors A Flask extension adding a decorator for CORS support >=3.0.10 3.0.10 MIT fr-core-news-md French pipeline optimized for CPU. Components: tok2vec, morphologizer, parser, senter, ner, attribute_ruler, lemmatizer. @ https://github.com/explosion/spacy-models/releases/download/fr_core_news_md-3.1.0/fr_core_news_md-3.1.0.tar.gz 3.1.0 LGPL-LR gevent Coroutine-based network library >=20.12.1 21.12.0 MIT geventhttpclient http client library for gevent >=1.5.1 2.0 MIT ghp-import Copy your docs directly to the gh-pages branch. >=1.0 2.1.0 Apache Software License git-changelog Automatic Changelog generator using Jinja2 templates. >=0.4 0.5.0 Other/Proprietary License gitdb Git Object Database <5,>=4.0.1 4.0.9 BSD License gitpython GitPython is a python library used to interact with Git repositories >=1.0.1 3.1.27 BSD greenlet Lightweight in-process concurrent programming <2.0,>=1.1.0; platform_python_implementation == \"CPython\" 1.1.2 MIT License griffe Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. >=0.11.1 0.22.0 ISC h11 A pure-Python, bring-your-own-I/O implementation of HTTP/1.1 <0.13,>=0.11 0.12.0 MIT httpcore A minimal low-level HTTP client. <0.16.0,>=0.15.0 0.15.0 BSD httpx The next generation HTTP client. >=0.16 0.23.0 BSD hypothesis A library for property-based testing >=6.8 6.54.4 MPL-2.0 idna Internationalized Domain Names in Applications (IDNA) <4,>=2.5 3.3 BSD-3-Clause importlib-metadata Read metadata from Python packages ; python_version < \"3.8\" 4.12.0 Apache Software License iniconfig iniconfig: brain-dead simple config-ini parsing 1.1.1 MIT License isort A Python utility / library to sort Python imports. >=5.10 5.10.1 MIT itsdangerous Safely pass data to untrusted environments and back. >=2.0 2.1.2 BSD-3-Clause jinja2 A very fast and expressive template engine. <4,>=2.11 3.1.2 BSD-3-Clause locust Developer friendly load testing framework >=1.1 2.11.0 MIT markdown Python implementation of Markdown. <4.0,>=3.3 3.3.7 BSD License markdown-callouts Markdown extension: a classier syntax for admonitions >=0.2 0.2.0 MIT markdown-exec Utilities to execute code blocks in Markdown files. >=0.5 0.7.0 ISC markupsafe Safely add untrusted strings to HTML/XML markup. >=2.0 2.1.1 BSD-3-Clause mccabe McCabe checker, plugin for flake8 <0.7.0,>=0.6.0 0.6.1 Expat license mergedeep A deep merge function for \ud83d\udc0d. >=1.3.4 1.3.4 MIT License mkdocs Project documentation with Markdown. >=1.3 1.3.1 BSD mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site. >=0.2 0.2.5 ISC License (ISCL) mkdocs-gen-files MkDocs plugin to programmatically generate documentation pages during the build >=0.3 0.4.0 MIT mkdocs-literate-nav MkDocs plugin to specify the navigation in Markdown instead of YAML >=0.4 0.4.1 MIT mkdocs-material Documentation that simply works >=7.3 8.4.1 MIT mkdocs-material-extensions Extension pack for Python Markdown. >=1.0.3 1.0.3 MIT License mkdocs-section-index MkDocs plugin to allow clickable sections that lead to an index page >=0.3 0.3.4 MIT mkdocstrings Automatic documentation from sources, for MkDocs. [python]>=0.19 0.19.0 ISC License (ISCL) mkdocstrings-python A Python handler for mkdocstrings. >=0.5.2 0.7.1 ISC msgpack MessagePack serializer >=0.6.2 1.0.4 Apache 2.0 murmurhash Cython bindings for MurmurHash <1.1.0,>=0.28.0 1.0.8 MIT mypy Optional static typing for Python >=0.910 0.971 MIT License mypy-extensions Experimental type system extensions for programs checked with the mypy typechecker. >=0.4.3 0.4.3 MIT License numpy NumPy is the fundamental package for array computing with Python. >=1.15.0 1.21.1 BSD packaging Core utilities for Python packages >=20.5 21.3 BSD-2-Clause or Apache-2.0 pathspec Utility library for gitignore style pattern matching of file paths. >=0.9.0 0.9.0 MPL 2.0 pathy pathlib.Path subclasses for local and cloud bucket storage >=0.3.5 0.6.2 Apache 2.0 pbr Python Build Reasonableness !=2.1.0,>=2.0.0 5.10.0 Apache Software License pep8-naming Check PEP-8 naming conventions, plugin for flake8 >=0.12 0.13.2 Expat license platformdirs A small Python module for determining appropriate platform-specific dirs, e.g. a \"user data dir\". >=2 2.5.2 MIT License pluggy plugin and hook calling mechanisms for python <2.0,>=0.12 1.0.0 MIT preshed Cython hash table that trusts the keys are pre-hashed <3.1.0,>=3.0.2 3.0.7 MIT psutil Cross-platform lib for process and system monitoring in Python. >=5.6.7 5.9.1 BSD ptyprocess Run a subprocess in a pseudo terminal ~=0.6; sys_platform != \"win32\" 0.7.0 ? py library with cross-python path, ini-parsing, io, code, log facilities >=1.8.2 1.11.0 MIT license pycodestyle Python style guide checker 2.7.0 Expat license pycparser C parser in Python 2.21 BSD pydantic Data validation and settings management using python 3.6 type hinting !=1.8,!=1.8.1,<1.9.0,>=1.7.4 1.8.2 MIT pydocstyle Python docstring style checker >=2.1 6.1.1 MIT pyflakes passive checker of Python programs >=1.1.0 2.3.1 MIT pygments Pygments is a syntax highlighting package written in Python. >=2.12 2.13.0 BSD License pymdown-extensions Extension pack for Python Markdown. >=9 9.5 MIT License pyparsing pyparsing module - Classes and methods to define and execute parsing grammars !=3.0.5,>=2.0.2 3.0.9 MIT License pytest pytest: simple powerful testing with Python >=6.2 7.1.2 MIT pytest-asyncio Pytest support for asyncio >=0.14 0.19.0 Apache 2.0 pytest-cov Pytest plugin for measuring coverage. >=3.0 3.0.0 MIT pytest-forked run tests in isolated forked subprocesses 1.4.0 MIT pytest-mock Thin-wrapper around the mock package for easier use with pytest >=3.4 3.8.2 MIT pytest-randomly Pytest plugin to randomly order tests and control random.seed. >=3.10 3.12.0 MIT pytest-sugar pytest-sugar is a plugin for pytest that changes the default look and feel of pytest (e.g. progressbar, show tests that fail instantly). >=0.9 0.9.5 BSD pytest-xdist pytest xdist plugin for distributed testing and loop-on-failing modes >=2.4 2.5.0 MIT python-dateutil Extensions to the standard Python datetime module >=2.8.1 2.8.2 Dual License pywin32 Python for Window Extensions ; platform_system == \"Windows\" 304 PSF pyyaml YAML parser and emitter for Python >=3.10 6.0 MIT pyyaml-env-tag A custom YAML tag for referencing environment variables in YAML files. >=0.1 0.1 MIT License pyzmq Python bindings for 0MQ <23.0.0,>=22.2.1 22.3.0 LGPL+BSD requests Python HTTP for Humans. >=2.23.0 2.28.1 Apache 2.0 rfc3986 Validating URI References per RFC 3986 [idna2008]<2,>=1.3 1.5.0 Apache 2.0 roundrobin Collection of roundrobin utilities >=0.0.2 0.0.4 MIT safety Checks installed dependencies for known vulnerabilities. >=1.10,<2 1.10.3 MIT license semver Python helper for Semantic Versioning (http://semver.org/) ~=2.13 2.13.0 BSD setuptools Easily download, build, install, upgrade, and uninstall Python packages 65.2.0 MIT License six Python 2 and 3 compatibility utilities 1.16.0 MIT smart-open Utils for streaming large files (S3, HDFS, GCS, Azure Blob Storage, gzip, bz2...) <6.0.0,>=5.2.1 5.2.1 MIT smmap A pure Python implementation of a sliding window memory map manager <6,>=3.0.1 5.0.0 BSD sniffio Sniff out which async library your code is running under 1.2.0 MIT -or- Apache License 2.0 snowballstemmer This package provides 29 stemmers for 28 languages generated from Snowball algorithms. 2.2.0 BSD-3-Clause sortedcontainers Sorted Containers -- Sorted List, Sorted Dict, Sorted Set <3.0.0,>=2.1.0 2.4.0 Apache 2.0 spacy Industrial-strength Natural Language Processing (NLP) in Python <3.2.0,>=3.1.0 3.1.6 MIT spacy-legacy Legacy registered functions for spaCy backwards compatibility <3.1.0,>=3.0.8 3.0.10 MIT srsly Modern high-performance serialization utilities for Python <3.0.0,>=2.4.1 2.4.4 MIT stevedore Manage dynamic plugins for Python applications >=1.20.0 3.5.0 Apache Software License termcolor ANSII Color formatting for output in terminal. >=1.1.0 1.1.0 MIT thinc A refreshing functional take on deep learning, compatible with your favorite libraries <8.1.0,>=8.0.12 8.0.17 MIT toml Python Library for Tom's Obvious, Minimal Language >=0.10 0.10.2 MIT tomli A lil' TOML parser >=1.1.0; python_full_version < \"3.11.0a7\" 2.0.1 MIT License tqdm Fast, Extensible Progress Meter <5.0.0,>=4.38.0 4.64.0 MPLv2.0, MIT Licences typed-ast a fork of Python 2 and 3 ast modules with type comment support >=1.4.2; python_version < \"3.8\" and implementation_name == \"cpython\" 1.5.4 ? typer Typer, build great CLIs. Easy to code. Based on Python type hints. <0.5.0,>=0.3.0 0.4.2 MIT License types-filelock Typing stubs for filelock 3.2.7 Apache-2.0 license types-markdown Typing stubs for Markdown >=3.3 3.4.1 Apache-2.0 license types-python-dateutil Typing stubs for python-dateutil 2.8.19 Apache-2.0 license types-toml Typing stubs for toml >=0.10 0.10.8 Apache-2.0 license typing-extensions Backported and Experimental Type Hints for Python 3.5+ >=3.10.0.0; python_version < \"3.10\" 3.10.0.2 PSF urllib3 HTTP library with thread-safe connection pooling, file post, and more. <1.27,>=1.21.1 1.26.12 MIT wasabi A lightweight console printing and formatting toolkit <1.1.0,>=0.8.1 0.10.1 MIT watchdog Filesystem events monitoring >=2.0 2.1.9 Apache License 2.0 werkzeug The comprehensive WSGI web application library. >=2.0.0 2.2.2 BSD-3-Clause wps-light The strictest and most opinionated python linter ever (lighter fork). >=0.15 0.16.1 MIT zipp Backport of pathlib-compatible object wrapper for zip files >=0.5 3.8.1 MIT License zope.event Very basic event publishing system 4.5.0 ZPL 2.1 zope.interface Interfaces for Python 5.4.0 ZPL 2.1","title":"Credits"},{"location":"license/","text":"CeCILL-C FREE SOFTWARE LICENSE AGREEMENT \u00b6 Notice \u00b6 This Agreement is a Free Software license agreement that is the result of discussions between its authors in order to ensure compliance with the two main principles guiding its drafting: firstly, compliance with the principles governing the distribution of Free Software: access to source code, broad rights granted to users, secondly, the election of a governing law, French law, with which it is conformant, both as regards the law of torts and intellectual property law, and the protection that it offers to both authors and holders of the economic rights over software. The authors of the CeCILL-C license are: Commissariat \u00e0 l'Energie Atomique - CEA, a public scientific, technical and industrial research establishment, having its principal place of business at 25 rue Leblanc, immeuble Le Ponant D, 75015 Paris, France. Centre National de la Recherche Scientifique - CNRS, a public scientific and technological establishment, having its principal place of business at 3 rue Michel-Ange, 75794 Paris cedex 16, France. Institut National de Recherche en Informatique et en Automatique - INRIA, a public scientific and technological establishment, having its principal place of business at Domaine de Voluceau, Rocquencourt, BP 105, 78153 Le Chesnay cedex, France. CeCILL stands for Ce(a) C(nrs) I(nria) L(ogiciel) L(ibre) Preamble \u00b6 The purpose of this Free Software license agreement is to grant users the right to modify and re-use the software governed by this license. The exercising of this right is conditional upon the obligation to make available to the community the modifications made to the source code of the software so as to contribute to its evolution. In consideration of access to the source code and the rights to copy, modify and redistribute granted by the license, users are provided only with a limited warranty and the software's author, the holder of the economic rights, and the successive licensors only have limited liability. In this respect, the risks associated with loading, using, modifying and/or developing or reproducing the software by the user are brought to the user's attention, given its Free Software status, which may make it complicated to use, with the result that its use is reserved for developers and experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the suitability of the software as regards their requirements in conditions enabling the security of their systems and/or data to be ensured and, more generally, to use and operate it in the same conditions of security. This Agreement may be freely reproduced and published, provided it is not altered, and that no provisions are either added or removed herefrom. This Agreement may apply to any or all software for which the holder of the economic rights decides to submit the use thereof to its provisions. Article 1 - DEFINITIONS \u00b6 For the purpose of this Agreement, when the following expressions commence with a capital letter, they shall have the following meaning: Agreement: means this license agreement, and its possible subsequent versions and annexes. Software: means the software in its Object Code and/or Source Code form and, where applicable, its documentation, \"as is\" when the Licensee accepts the Agreement. Initial Software: means the Software in its Source Code and possibly its Object Code form and, where applicable, its documentation, \"as is\" when it is first distributed under the terms and conditions of the Agreement. Modified Software: means the Software modified by at least one Integrated Contribution. Source Code: means all the Software's instructions and program lines to which access is required so as to modify the Software. Object Code: means the binary files originating from the compilation of the Source Code. Holder: means the holder(s) of the economic rights over the Initial Software. Licensee: means the Software user(s) having accepted the Agreement. Contributor: means a Licensee having made at least one Integrated Contribution. Licensor: means the Holder, or any other individual or legal entity, who distributes the Software under the Agreement. Integrated Contribution: means any or all modifications, corrections, translations, adaptations and/or new functions integrated into the Source Code by any or all Contributors. Related Module: means a set of sources files including their documentation that, without modification to the Source Code, enables supplementary functions or services in addition to those offered by the Software. Derivative Software: means any combination of the Software, modified or not, and of a Related Module. Parties: mean both the Licensee and the Licensor. These expressions may be used both in singular and plural form. Article 2 - PURPOSE \u00b6 The purpose of the Agreement is the grant by the Licensor to the Licensee of a non-exclusive, transferable and worldwide license for the Software as set forth in Article 5 hereinafter for the whole term of the protection granted by the rights over said Software. Article 3 - ACCEPTANCE \u00b6 3.1 The Licensee shall be deemed as having accepted the terms and conditions of this Agreement upon the occurrence of the first of the following events: (i) loading the Software by any or all means, notably, by downloading from a remote server, or by loading from a physical medium; (ii) the first time the Licensee exercises any of the rights granted hereunder. 3.2 One copy of the Agreement, containing a notice relating to the characteristics of the Software, to the limited warranty, and to the fact that its use is restricted to experienced users has been provided to the Licensee prior to its acceptance as set forth in Article 3.1 hereinabove, and the Licensee hereby acknowledges that it has read and understood it. Article 4 - EFFECTIVE DATE AND TERM \u00b6 4.1 EFFECTIVE DATE \u00b6 The Agreement shall become effective on the date when it is accepted by the Licensee as set forth in Article 3.1 . 4.2 TERM \u00b6 The Agreement shall remain in force for the entire legal term of protection of the economic rights over the Software. Article 5 - SCOPE OF RIGHTS GRANTED \u00b6 The Licensor hereby grants to the Licensee, who accepts, the following rights over the Software for any or all use, and for the term of the Agreement, on the basis of the terms and conditions set forth hereinafter. Besides, if the Licensor owns or comes to own one or more patents protecting all or part of the functions of the Software or of its components, the Licensor undertakes not to enforce the rights granted by these patents against successive Licensees using, exploiting or modifying the Software. If these patents are transferred, the Licensor undertakes to have the transferees subscribe to the obligations set forth in this paragraph. 5.1 RIGHT OF USE \u00b6 The Licensee is authorized to use the Software, without any limitation as to its fields of application, with it being hereinafter specified that this comprises: permanent or temporary reproduction of all or part of the Software by any or all means and in any or all form. loading, displaying, running, or storing the Software on any or all medium. entitlement to observe, study or test its operation so as to determine the ideas and principles behind any or all constituent elements of said Software. This shall apply when the Licensee carries out any or all loading, displaying, running, transmission or storage operation as regards the Software, that it is entitled to carry out hereunder. 5.2 RIGHT OF MODIFICATION \u00b6 The right of modification includes the right to translate, adapt, arrange, or make any or all modifications to the Software, and the right to reproduce the resulting software. It includes, in particular, the right to create a Derivative Software. The Licensee is authorized to make any or all modification to the Software provided that it includes an explicit notice that it is the author of said modification and indicates the date of the creation thereof. 5.3 RIGHT OF DISTRIBUTION \u00b6 In particular, the right of distribution includes the right to publish, transmit and communicate the Software to the general public on any or all medium, and by any or all means, and the right to market, either in consideration of a fee, or free of charge, one or more copies of the Software by any means. The Licensee is further authorized to distribute copies of the modified or unmodified Software to third parties according to the terms and conditions set forth hereinafter. 5.3.1 DISTRIBUTION OF SOFTWARE WITHOUT MODIFICATION \u00b6 The Licensee is authorized to distribute true copies of the Software in Source Code or Object Code form, provided that said distribution complies with all the provisions of the Agreement and is accompanied by: a copy of the Agreement, a notice relating to the limitation of both the Licensor's warranty and liability as set forth in Article 8 and Article 9 , and that, in the event that only the Object Code of the Software is redistributed, the Licensee allows effective access to the full Source Code of the Software at a minimum during the entire period of its distribution of the Software, it being understood that the additional cost of acquiring the Source Code shall not exceed the cost of transferring the data. 5.3.2 DISTRIBUTION OF MODIFIED SOFTWARE \u00b6 When the Licensee makes an Integrated Contribution to the Software, the terms and conditions for the distribution of the resulting Modified Software become subject to all the provisions of this Agreement. The Licensee is authorized to distribute the Modified Software, in source code or object code form, provided that said distribution complies with all the provisions of the Agreement and is accompanied by: a copy of the Agreement, a notice relating to the limitation of both the Licensor's warranty and liability as set forth in Article 8 and Article 9 , and that, in the event that only the object code of the Modified Software is redistributed, the Licensee allows effective access to the full source code of the Modified Software at a minimum during the entire period of its distribution of the Modified Software, it being understood that the additional cost of acquiring the source code shall not exceed the cost of transferring the data. 5.3.3 DISTRIBUTION OF DERIVATIVE SOFTWARE \u00b6 When the Licensee creates Derivative Software, this Derivative Software may be distributed under a license agreement other than this Agreement, subject to compliance with the requirement to include a notice concerning the rights over the Software as defined in Article 6.4 . In the event the creation of the Derivative Software required modification of the Source Code, the Licensee undertakes that: the resulting Modified Software will be governed by this Agreement, the Integrated Contributions in the resulting Modified Software will be clearly identified and documented, the Licensee will allow effective access to the source code of the Modified Software, at a minimum during the entire period of distribution of the Derivative Software, such that such modifications may be carried over in a subsequent version of the Software; it being understood that the additional cost of purchasing the source code of the Modified Software shall not exceed the cost of transferring the data. 5.3.4 COMPATIBILITY WITH THE CeCILL LICENSE \u00b6 When a Modified Software contains an Integrated Contribution subject to the CeCILL license agreement, or when a Derivative Software contains a Related Module subject to the CeCILL license agreement, the provisions set forth in the third item of Article 6.4 are optional. Article 6 - INTELLECTUAL PROPERTY \u00b6 6.1 OVER THE INITIAL SOFTWARE \u00b6 The Holder owns the economic rights over the Initial Software. Any or all use of the Initial Software is subject to compliance with the terms and conditions under which the Holder has elected to distribute its work and no one shall be entitled to modify the terms and conditions for the distribution of said Initial Software. The Holder undertakes that the Initial Software will remain ruled at least by this Agreement, for the duration set forth in Article 4.2 . 6.2 OVER THE INTEGRATED CONTRIBUTIONS \u00b6 The Licensee who develops an Integrated Contribution is the owner of the intellectual property rights over this Contribution as defined by applicable law. 6.3 OVER THE RELATED MODULES \u00b6 The Licensee who develops a Related Module is the owner of the intellectual property rights over this Related Module as defined by applicable law and is free to choose the type of agreement that shall govern its distribution under the conditions defined in Article 5.3.3 . 6.4 NOTICE OF RIGHTS \u00b6 The Licensee expressly undertakes: not to remove, or modify, in any manner, the intellectual property notices attached to the Software; to reproduce said notices, in an identical manner, in the copies of the Software modified or not; to ensure that use of the Software, its intellectual property notices and the fact that it is governed by the Agreement is indicated in a text that is easily accessible, specifically from the interface of any Derivative Software. The Licensee undertakes not to directly or indirectly infringe the intellectual property rights of the Holder and/or Contributors on the Software and to take, where applicable, vis-\u00e0-vis its staff, any and all measures required to ensure respect of said intellectual property rights of the Holder and/or Contributors. Article 7 - RELATED SERVICES \u00b6 7.1 Under no circumstances shall the Agreement oblige the Licensor to provide technical assistance or maintenance services for the Software. However, the Licensor is entitled to offer this type of services. The terms and conditions of such technical assistance, and/or such maintenance, shall be set forth in a separate instrument. Only the Licensor offering said maintenance and/or technical assistance services shall incur liability therefor. 7.2 Similarly, any Licensor is entitled to offer to its licensees, under its sole responsibility, a warranty, that shall only be binding upon itself, for the redistribution of the Software and/or the Modified Software, under terms and conditions that it is free to decide. Said warranty, and the financial terms and conditions of its application, shall be subject of a separate instrument executed between the Licensor and the Licensee. Article 8 - LIABILITY \u00b6 8.1 Subject to the provisions of Article 8.2, the Licensee shall be entitled to claim compensation for any direct loss it may have suffered from the Software as a result of a fault on the part of the relevant Licensor, subject to providing evidence thereof. 8.2 The Licensor's liability is limited to the commitments made under this Agreement and shall not be incurred as a result of in particular: (i) loss due the Licensee's total or partial failure to fulfill its obligations, (ii) direct or consequential loss that is suffered by the Licensee due to the use or performance of the Software, and (iii) more generally, any consequential loss. In particular the Parties expressly agree that any or all pecuniary or business loss (i.e. loss of data, loss of profits, operating loss, loss of customers or orders, opportunity cost, any disturbance to business activities) or any or all legal proceedings instituted against the Licensee by a third party, shall constitute consequential loss and shall not provide entitlement to any or all compensation from the Licensor. Article 9 - WARRANTY \u00b6 9.1 The Licensee acknowledges that the scientific and technical state-of-the-art when the Software was distributed did not enable all possible uses to be tested and verified, nor for the presence of possible defects to be detected. In this respect, the Licensee's attention has been drawn to the risks associated with loading, using, modifying and/or developing and reproducing the Software which are reserved for experienced users. The Licensee shall be responsible for verifying, by any or all means, the suitability of the product for its requirements, its good working order, and for ensuring that it shall not cause damage to either persons or properties. 9.2 The Licensor hereby represents, in good faith, that it is entitled to grant all the rights over the Software (including in particular the rights set forth in Article 5 ). 9.3 The Licensee acknowledges that the Software is supplied \"as is\" by the Licensor without any other express or tacit warranty, other than that provided for in Article 9.2 and, in particular, without any warranty as to its commercial value, its secured, safe, innovative or relevant nature. Specifically, the Licensor does not warrant that the Software is free from any error, that it will operate without interruption, that it will be compatible with the Licensee's own equipment and software configuration, nor that it will meet the Licensee's requirements. 9.4 The Licensor does not either expressly or tacitly warrant that the Software does not infringe any third party intellectual property right relating to a patent, software or any other property right. Therefore, the Licensor disclaims any and all liability towards the Licensee arising out of any or all proceedings for infringement that may be instituted in respect of the use, modification and redistribution of the Software. Nevertheless, should such proceedings be instituted against the Licensee, the Licensor shall provide it with technical and legal assistance for its defense. Such technical and legal assistance shall be decided on a case-by-case basis between the relevant Licensor and the Licensee pursuant to a memorandum of understanding. The Licensor disclaims any and all liability as regards the Licensee's use of the name of the Software. No warranty is given as regards the existence of prior rights over the name of the Software or as regards the existence of a trademark. Article 10 - TERMINATION \u00b6 10.1 In the event of a breach by the Licensee of its obligations hereunder, the Licensor may automatically terminate this Agreement thirty (30) days after notice has been sent to the Licensee and has remained ineffective. 10.2 A Licensee whose Agreement is terminated shall no longer be authorized to use, modify or distribute the Software. However, any licenses that it may have granted prior to termination of the Agreement shall remain valid subject to their having been granted in compliance with the terms and conditions hereof. Article 11 - MISCELLANEOUS \u00b6 11.1 EXCUSABLE EVENTS Neither Party shall be liable for any or all delay, or failure to perform the Agreement, that may be attributable to an event of force majeure, an act of God or an outside cause, such as defective functioning or interruptions of the electricity or telecommunications networks, network paralysis following a virus attack, intervention by government authorities, natural disasters, water damage, earthquakes, fire, explosions, strikes and labor unrest, war, etc. 11.2 Any failure by either Party, on one or more occasions, to invoke one or more of the provisions hereof, shall under no circumstances be interpreted as being a waiver by the interested Party of its right to invoke said provision(s) subsequently. 11.3 The Agreement cancels and replaces any or all previous agreements, whether written or oral, between the Parties and having the same purpose, and constitutes the entirety of the agreement between said Parties concerning said purpose. No supplement or modification to the terms and conditions hereof shall be effective as between the Parties unless it is made in writing and signed by their duly authorized representatives. 11.4 In the event that one or more of the provisions hereof were to conflict with a current or future applicable act or legislative text, said act or legislative text shall prevail, and the Parties shall make the necessary amendments so as to comply with said act or legislative text. All other provisions shall remain effective. Similarly, invalidity of a provision of the Agreement, for any reason whatsoever, shall not cause the Agreement as a whole to be invalid. 11.5 LANGUAGE The Agreement is drafted in both French and English and both versions are deemed authentic. Article 12 - NEW VERSIONS OF THE AGREEMENT \u00b6 12.1 Any person is authorized to duplicate and distribute copies of this Agreement. 12.2 So as to ensure coherence, the wording of this Agreement is protected and may only be modified by the authors of the License, who reserve the right to periodically publish updates or new versions of the Agreement, each with a separate number. These subsequent versions may address new issues encountered by Free Software. 12.3 Any Software distributed under a given version of the Agreement may only be subsequently distributed under the same version of the Agreement or a subsequent version. Article 13 - GOVERNING LAW AND JURISDICTION \u00b6 13.1 The Agreement is governed by French law. The Parties agree to endeavor to seek an amicable solution to any disagreements or disputes that may arise during the performance of the Agreement. 13.2 Failing an amicable solution within two (2) months as from their occurrence, and unless emergency proceedings are necessary, the disagreements or disputes shall be referred to the Paris Courts having jurisdiction, by the more diligent Party. Version 1.0 dated 2006-09-05.","title":"License"},{"location":"license/#cecill-c-free-software-license-agreement","text":"","title":"CeCILL-C FREE SOFTWARE LICENSE AGREEMENT"},{"location":"license/#notice","text":"This Agreement is a Free Software license agreement that is the result of discussions between its authors in order to ensure compliance with the two main principles guiding its drafting: firstly, compliance with the principles governing the distribution of Free Software: access to source code, broad rights granted to users, secondly, the election of a governing law, French law, with which it is conformant, both as regards the law of torts and intellectual property law, and the protection that it offers to both authors and holders of the economic rights over software. The authors of the CeCILL-C license are: Commissariat \u00e0 l'Energie Atomique - CEA, a public scientific, technical and industrial research establishment, having its principal place of business at 25 rue Leblanc, immeuble Le Ponant D, 75015 Paris, France. Centre National de la Recherche Scientifique - CNRS, a public scientific and technological establishment, having its principal place of business at 3 rue Michel-Ange, 75794 Paris cedex 16, France. Institut National de Recherche en Informatique et en Automatique - INRIA, a public scientific and technological establishment, having its principal place of business at Domaine de Voluceau, Rocquencourt, BP 105, 78153 Le Chesnay cedex, France. CeCILL stands for Ce(a) C(nrs) I(nria) L(ogiciel) L(ibre)","title":"Notice"},{"location":"license/#preamble","text":"The purpose of this Free Software license agreement is to grant users the right to modify and re-use the software governed by this license. The exercising of this right is conditional upon the obligation to make available to the community the modifications made to the source code of the software so as to contribute to its evolution. In consideration of access to the source code and the rights to copy, modify and redistribute granted by the license, users are provided only with a limited warranty and the software's author, the holder of the economic rights, and the successive licensors only have limited liability. In this respect, the risks associated with loading, using, modifying and/or developing or reproducing the software by the user are brought to the user's attention, given its Free Software status, which may make it complicated to use, with the result that its use is reserved for developers and experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the suitability of the software as regards their requirements in conditions enabling the security of their systems and/or data to be ensured and, more generally, to use and operate it in the same conditions of security. This Agreement may be freely reproduced and published, provided it is not altered, and that no provisions are either added or removed herefrom. This Agreement may apply to any or all software for which the holder of the economic rights decides to submit the use thereof to its provisions.","title":"Preamble"},{"location":"license/#article-1-definitions","text":"For the purpose of this Agreement, when the following expressions commence with a capital letter, they shall have the following meaning: Agreement: means this license agreement, and its possible subsequent versions and annexes. Software: means the software in its Object Code and/or Source Code form and, where applicable, its documentation, \"as is\" when the Licensee accepts the Agreement. Initial Software: means the Software in its Source Code and possibly its Object Code form and, where applicable, its documentation, \"as is\" when it is first distributed under the terms and conditions of the Agreement. Modified Software: means the Software modified by at least one Integrated Contribution. Source Code: means all the Software's instructions and program lines to which access is required so as to modify the Software. Object Code: means the binary files originating from the compilation of the Source Code. Holder: means the holder(s) of the economic rights over the Initial Software. Licensee: means the Software user(s) having accepted the Agreement. Contributor: means a Licensee having made at least one Integrated Contribution. Licensor: means the Holder, or any other individual or legal entity, who distributes the Software under the Agreement. Integrated Contribution: means any or all modifications, corrections, translations, adaptations and/or new functions integrated into the Source Code by any or all Contributors. Related Module: means a set of sources files including their documentation that, without modification to the Source Code, enables supplementary functions or services in addition to those offered by the Software. Derivative Software: means any combination of the Software, modified or not, and of a Related Module. Parties: mean both the Licensee and the Licensor. These expressions may be used both in singular and plural form.","title":"Article 1 - DEFINITIONS"},{"location":"license/#article-2-purpose","text":"The purpose of the Agreement is the grant by the Licensor to the Licensee of a non-exclusive, transferable and worldwide license for the Software as set forth in Article 5 hereinafter for the whole term of the protection granted by the rights over said Software.","title":"Article 2 - PURPOSE"},{"location":"license/#article-3-acceptance","text":"3.1 The Licensee shall be deemed as having accepted the terms and conditions of this Agreement upon the occurrence of the first of the following events: (i) loading the Software by any or all means, notably, by downloading from a remote server, or by loading from a physical medium; (ii) the first time the Licensee exercises any of the rights granted hereunder. 3.2 One copy of the Agreement, containing a notice relating to the characteristics of the Software, to the limited warranty, and to the fact that its use is restricted to experienced users has been provided to the Licensee prior to its acceptance as set forth in Article 3.1 hereinabove, and the Licensee hereby acknowledges that it has read and understood it.","title":" Article 3 - ACCEPTANCE"},{"location":"license/#article-4-effective-date-and-term","text":"","title":" Article 4 - EFFECTIVE DATE AND TERM"},{"location":"license/#41-effective-date","text":"The Agreement shall become effective on the date when it is accepted by the Licensee as set forth in Article 3.1 .","title":" 4.1 EFFECTIVE DATE"},{"location":"license/#42-term","text":"The Agreement shall remain in force for the entire legal term of protection of the economic rights over the Software.","title":" 4.2 TERM"},{"location":"license/#article-5-scope-of-rights-granted","text":"The Licensor hereby grants to the Licensee, who accepts, the following rights over the Software for any or all use, and for the term of the Agreement, on the basis of the terms and conditions set forth hereinafter. Besides, if the Licensor owns or comes to own one or more patents protecting all or part of the functions of the Software or of its components, the Licensor undertakes not to enforce the rights granted by these patents against successive Licensees using, exploiting or modifying the Software. If these patents are transferred, the Licensor undertakes to have the transferees subscribe to the obligations set forth in this paragraph.","title":" Article 5 - SCOPE OF RIGHTS GRANTED"},{"location":"license/#51-right-of-use","text":"The Licensee is authorized to use the Software, without any limitation as to its fields of application, with it being hereinafter specified that this comprises: permanent or temporary reproduction of all or part of the Software by any or all means and in any or all form. loading, displaying, running, or storing the Software on any or all medium. entitlement to observe, study or test its operation so as to determine the ideas and principles behind any or all constituent elements of said Software. This shall apply when the Licensee carries out any or all loading, displaying, running, transmission or storage operation as regards the Software, that it is entitled to carry out hereunder.","title":" 5.1 RIGHT OF USE"},{"location":"license/#52-right-of-modification","text":"The right of modification includes the right to translate, adapt, arrange, or make any or all modifications to the Software, and the right to reproduce the resulting software. It includes, in particular, the right to create a Derivative Software. The Licensee is authorized to make any or all modification to the Software provided that it includes an explicit notice that it is the author of said modification and indicates the date of the creation thereof.","title":" 5.2 RIGHT OF MODIFICATION"},{"location":"license/#53-right-of-distribution","text":"In particular, the right of distribution includes the right to publish, transmit and communicate the Software to the general public on any or all medium, and by any or all means, and the right to market, either in consideration of a fee, or free of charge, one or more copies of the Software by any means. The Licensee is further authorized to distribute copies of the modified or unmodified Software to third parties according to the terms and conditions set forth hereinafter.","title":" 5.3 RIGHT OF DISTRIBUTION"},{"location":"license/#531-distribution-of-software-without-modification","text":"The Licensee is authorized to distribute true copies of the Software in Source Code or Object Code form, provided that said distribution complies with all the provisions of the Agreement and is accompanied by: a copy of the Agreement, a notice relating to the limitation of both the Licensor's warranty and liability as set forth in Article 8 and Article 9 , and that, in the event that only the Object Code of the Software is redistributed, the Licensee allows effective access to the full Source Code of the Software at a minimum during the entire period of its distribution of the Software, it being understood that the additional cost of acquiring the Source Code shall not exceed the cost of transferring the data.","title":" 5.3.1 DISTRIBUTION OF SOFTWARE WITHOUT MODIFICATION"},{"location":"license/#532-distribution-of-modified-software","text":"When the Licensee makes an Integrated Contribution to the Software, the terms and conditions for the distribution of the resulting Modified Software become subject to all the provisions of this Agreement. The Licensee is authorized to distribute the Modified Software, in source code or object code form, provided that said distribution complies with all the provisions of the Agreement and is accompanied by: a copy of the Agreement, a notice relating to the limitation of both the Licensor's warranty and liability as set forth in Article 8 and Article 9 , and that, in the event that only the object code of the Modified Software is redistributed, the Licensee allows effective access to the full source code of the Modified Software at a minimum during the entire period of its distribution of the Modified Software, it being understood that the additional cost of acquiring the source code shall not exceed the cost of transferring the data.","title":" 5.3.2 DISTRIBUTION OF MODIFIED SOFTWARE"},{"location":"license/#533-distribution-of-derivative-software","text":"When the Licensee creates Derivative Software, this Derivative Software may be distributed under a license agreement other than this Agreement, subject to compliance with the requirement to include a notice concerning the rights over the Software as defined in Article 6.4 . In the event the creation of the Derivative Software required modification of the Source Code, the Licensee undertakes that: the resulting Modified Software will be governed by this Agreement, the Integrated Contributions in the resulting Modified Software will be clearly identified and documented, the Licensee will allow effective access to the source code of the Modified Software, at a minimum during the entire period of distribution of the Derivative Software, such that such modifications may be carried over in a subsequent version of the Software; it being understood that the additional cost of purchasing the source code of the Modified Software shall not exceed the cost of transferring the data.","title":" 5.3.3 DISTRIBUTION OF DERIVATIVE SOFTWARE"},{"location":"license/#534-compatibility-with-the-cecill-license","text":"When a Modified Software contains an Integrated Contribution subject to the CeCILL license agreement, or when a Derivative Software contains a Related Module subject to the CeCILL license agreement, the provisions set forth in the third item of Article 6.4 are optional.","title":" 5.3.4 COMPATIBILITY WITH THE CeCILL LICENSE"},{"location":"license/#article-6-intellectual-property","text":"","title":" Article 6 - INTELLECTUAL PROPERTY"},{"location":"license/#61-over-the-initial-software","text":"The Holder owns the economic rights over the Initial Software. Any or all use of the Initial Software is subject to compliance with the terms and conditions under which the Holder has elected to distribute its work and no one shall be entitled to modify the terms and conditions for the distribution of said Initial Software. The Holder undertakes that the Initial Software will remain ruled at least by this Agreement, for the duration set forth in Article 4.2 .","title":" 6.1 OVER THE INITIAL SOFTWARE"},{"location":"license/#62-over-the-integrated-contributions","text":"The Licensee who develops an Integrated Contribution is the owner of the intellectual property rights over this Contribution as defined by applicable law.","title":" 6.2 OVER THE INTEGRATED CONTRIBUTIONS"},{"location":"license/#63-over-the-related-modules","text":"The Licensee who develops a Related Module is the owner of the intellectual property rights over this Related Module as defined by applicable law and is free to choose the type of agreement that shall govern its distribution under the conditions defined in Article 5.3.3 .","title":" 6.3 OVER THE RELATED MODULES"},{"location":"license/#64-notice-of-rights","text":"The Licensee expressly undertakes: not to remove, or modify, in any manner, the intellectual property notices attached to the Software; to reproduce said notices, in an identical manner, in the copies of the Software modified or not; to ensure that use of the Software, its intellectual property notices and the fact that it is governed by the Agreement is indicated in a text that is easily accessible, specifically from the interface of any Derivative Software. The Licensee undertakes not to directly or indirectly infringe the intellectual property rights of the Holder and/or Contributors on the Software and to take, where applicable, vis-\u00e0-vis its staff, any and all measures required to ensure respect of said intellectual property rights of the Holder and/or Contributors.","title":" 6.4 NOTICE OF RIGHTS"},{"location":"license/#article-7-related-services","text":"7.1 Under no circumstances shall the Agreement oblige the Licensor to provide technical assistance or maintenance services for the Software. However, the Licensor is entitled to offer this type of services. The terms and conditions of such technical assistance, and/or such maintenance, shall be set forth in a separate instrument. Only the Licensor offering said maintenance and/or technical assistance services shall incur liability therefor. 7.2 Similarly, any Licensor is entitled to offer to its licensees, under its sole responsibility, a warranty, that shall only be binding upon itself, for the redistribution of the Software and/or the Modified Software, under terms and conditions that it is free to decide. Said warranty, and the financial terms and conditions of its application, shall be subject of a separate instrument executed between the Licensor and the Licensee.","title":" Article 7 - RELATED SERVICES"},{"location":"license/#article-8-liability","text":"8.1 Subject to the provisions of Article 8.2, the Licensee shall be entitled to claim compensation for any direct loss it may have suffered from the Software as a result of a fault on the part of the relevant Licensor, subject to providing evidence thereof. 8.2 The Licensor's liability is limited to the commitments made under this Agreement and shall not be incurred as a result of in particular: (i) loss due the Licensee's total or partial failure to fulfill its obligations, (ii) direct or consequential loss that is suffered by the Licensee due to the use or performance of the Software, and (iii) more generally, any consequential loss. In particular the Parties expressly agree that any or all pecuniary or business loss (i.e. loss of data, loss of profits, operating loss, loss of customers or orders, opportunity cost, any disturbance to business activities) or any or all legal proceedings instituted against the Licensee by a third party, shall constitute consequential loss and shall not provide entitlement to any or all compensation from the Licensor.","title":" Article 8 - LIABILITY"},{"location":"license/#article-9-warranty","text":"9.1 The Licensee acknowledges that the scientific and technical state-of-the-art when the Software was distributed did not enable all possible uses to be tested and verified, nor for the presence of possible defects to be detected. In this respect, the Licensee's attention has been drawn to the risks associated with loading, using, modifying and/or developing and reproducing the Software which are reserved for experienced users. The Licensee shall be responsible for verifying, by any or all means, the suitability of the product for its requirements, its good working order, and for ensuring that it shall not cause damage to either persons or properties. 9.2 The Licensor hereby represents, in good faith, that it is entitled to grant all the rights over the Software (including in particular the rights set forth in Article 5 ). 9.3 The Licensee acknowledges that the Software is supplied \"as is\" by the Licensor without any other express or tacit warranty, other than that provided for in Article 9.2 and, in particular, without any warranty as to its commercial value, its secured, safe, innovative or relevant nature. Specifically, the Licensor does not warrant that the Software is free from any error, that it will operate without interruption, that it will be compatible with the Licensee's own equipment and software configuration, nor that it will meet the Licensee's requirements. 9.4 The Licensor does not either expressly or tacitly warrant that the Software does not infringe any third party intellectual property right relating to a patent, software or any other property right. Therefore, the Licensor disclaims any and all liability towards the Licensee arising out of any or all proceedings for infringement that may be instituted in respect of the use, modification and redistribution of the Software. Nevertheless, should such proceedings be instituted against the Licensee, the Licensor shall provide it with technical and legal assistance for its defense. Such technical and legal assistance shall be decided on a case-by-case basis between the relevant Licensor and the Licensee pursuant to a memorandum of understanding. The Licensor disclaims any and all liability as regards the Licensee's use of the name of the Software. No warranty is given as regards the existence of prior rights over the name of the Software or as regards the existence of a trademark.","title":" Article 9 - WARRANTY"},{"location":"license/#article-10-termination","text":"10.1 In the event of a breach by the Licensee of its obligations hereunder, the Licensor may automatically terminate this Agreement thirty (30) days after notice has been sent to the Licensee and has remained ineffective. 10.2 A Licensee whose Agreement is terminated shall no longer be authorized to use, modify or distribute the Software. However, any licenses that it may have granted prior to termination of the Agreement shall remain valid subject to their having been granted in compliance with the terms and conditions hereof.","title":" Article 10 - TERMINATION"},{"location":"license/#article-11-miscellaneous","text":"11.1 EXCUSABLE EVENTS Neither Party shall be liable for any or all delay, or failure to perform the Agreement, that may be attributable to an event of force majeure, an act of God or an outside cause, such as defective functioning or interruptions of the electricity or telecommunications networks, network paralysis following a virus attack, intervention by government authorities, natural disasters, water damage, earthquakes, fire, explosions, strikes and labor unrest, war, etc. 11.2 Any failure by either Party, on one or more occasions, to invoke one or more of the provisions hereof, shall under no circumstances be interpreted as being a waiver by the interested Party of its right to invoke said provision(s) subsequently. 11.3 The Agreement cancels and replaces any or all previous agreements, whether written or oral, between the Parties and having the same purpose, and constitutes the entirety of the agreement between said Parties concerning said purpose. No supplement or modification to the terms and conditions hereof shall be effective as between the Parties unless it is made in writing and signed by their duly authorized representatives. 11.4 In the event that one or more of the provisions hereof were to conflict with a current or future applicable act or legislative text, said act or legislative text shall prevail, and the Parties shall make the necessary amendments so as to comply with said act or legislative text. All other provisions shall remain effective. Similarly, invalidity of a provision of the Agreement, for any reason whatsoever, shall not cause the Agreement as a whole to be invalid. 11.5 LANGUAGE The Agreement is drafted in both French and English and both versions are deemed authentic.","title":" Article 11 - MISCELLANEOUS"},{"location":"license/#article-12-new-versions-of-the-agreement","text":"12.1 Any person is authorized to duplicate and distribute copies of this Agreement. 12.2 So as to ensure coherence, the wording of this Agreement is protected and may only be modified by the authors of the License, who reserve the right to periodically publish updates or new versions of the Agreement, each with a separate number. These subsequent versions may address new issues encountered by Free Software. 12.3 Any Software distributed under a given version of the Agreement may only be subsequently distributed under the same version of the Agreement or a subsequent version.","title":" Article 12 - NEW VERSIONS OF THE AGREEMENT"},{"location":"license/#article-13-governing-law-and-jurisdiction","text":"13.1 The Agreement is governed by French law. The Parties agree to endeavor to seek an amicable solution to any disagreements or disputes that may arise during the performance of the Agreement. 13.2 Failing an amicable solution within two (2) months as from their occurrence, and unless emergency proceedings are necessary, the disagreements or disputes shall be referred to the Paris Courts having jurisdiction, by the more diligent Party. Version 1.0 dated 2006-09-05.","title":" Article 13 - GOVERNING LAW AND JURISDICTION"},{"location":"reference/SUMMARY/","text":"cognitivefactory interactive_clustering_gui app backgroundtasks models queries settings states","title":"SUMMARY"},{"location":"reference/cognitivefactory/interactive_clustering_gui/","text":"Interactive Clustering GUI package. Web application for Interactive Clustering methodology","title":"interactive_clustering_gui"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/","text":"Name: cognitivefactory.interactive_clustering_gui.app Description: Definition of FastAPI application and routes for interactive clustering graphical user interface. Author: Erwan Schild Created: 22/10/2021 Licence: CeCILL-C License v1.0 ( https://cecill.info/licences.fr.html ) alive () async \u00b6 Tell if the API is alive/healthy. Returns: Name Type Description Response Response An HTTP response with either 200 or 503 codes. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 @app . get ( \"/alive\" , tags = [ \"app state\" ], status_code = status . HTTP_200_OK , ) async def alive () -> Response : # pragma: no cover \"\"\" Tell if the API is alive/healthy. Returns: Response: An HTTP response with either 200 or 503 codes. \"\"\" try : # Assert the volume can be reached. pathlib . Path ( DATA_DIRECTORY / \".available\" ) . touch () # Or anything else asserting the API is healthy. except OSError : return Response ( status_code = status . HTTP_503_SERVICE_UNAVAILABLE ) return Response ( status_code = status . HTTP_200_OK ) annotate_constraint ( project_id = Path ( Ellipsis , description = 'The ID of the project.' ), constraint_id = Path ( Ellipsis , description = 'The ID of the constraint.' ), constraint_type = Query ( None , description = 'The type of constraint to annotate. Defaults to `None`.' )) async \u00b6 Annotate a constraint. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') constraint_id str The ID of the constraint. Path(Ellipsis, description='The ID of the constraint.') constraint_type Optional [ ConstraintsValues ] The type of constraint to annotate. Defaults to None . Query(None, description='The type of constraint to annotate. Defaults to `None`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the constraint with id constraint_id to annotate doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow modification. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of annotated constraint. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 @app . put ( \"/api/projects/ {project_id} /constraints/ {constraint_id} /annotate\" , tags = [ \"Constraints\" ], status_code = status . HTTP_202_ACCEPTED , ) async def annotate_constraint ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), constraint_id : str = Path ( ... , description = \"The ID of the constraint.\" , ), constraint_type : Optional [ ConstraintsValues ] = Query ( None , description = \"The type of constraint to annotate. Defaults to `None`.\" , ), ) -> Dict [ str , Any ]: \"\"\" Annotate a constraint. Args: project_id (str): The ID of the project. constraint_id (str): The ID of the constraint. constraint_type (Optional[ConstraintsValues]): The type of constraint to annotate. Defaults to `None`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the constraint with id `constraint_id` to annotate doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow modification. Returns: Dict[str, Any]: A dictionary that contains the ID of annotated constraint. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Load constraints file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Any ] = json . load ( constraints_fileobject_r ) ### ### Check parameters. ### # Check constraint id. if constraint_id not in constraints . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"In project with id ' {project_id_str} ', the constraint with id ' {constraint_id_str} ' to annotate doesn't exist.\" . format ( project_id_str = str ( project_id ), constraint_id_str = str ( constraint_id ), ), ) # Check status. if ( project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow modification during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"outdated\" status. if project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS # Update constraints by updating the constraint history. constraints [ constraint_id ][ \"constraint_type_previous\" ] . append ( constraints [ constraint_id ][ \"constraint_type\" ]) # Update constraints by annotating the constraint. constraints [ constraint_id ][ \"constraint_type\" ] = constraint_type constraints [ constraint_id ][ \"date_of_update\" ] = datetime . now () . timestamp () # Force annotation status. constraints [ constraint_id ][ \"to_annotate\" ] = False ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Store updated constraints in file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"constraint_id\" : constraint_id , \"detail\" : \"In project with id ' {project_id_str} ', the constraint with id ' {constraint_id_str} ' has been annotated at ` {constraint_type_str} `.\" . format ( project_id_str = str ( project_id ), constraint_id_str = str ( constraint_id ), constraint_type_str = \"None\" if ( constraint_type is None ) else str ( constraint_type . value ), ), } approve_all_constraints ( project_id = Path ( Ellipsis , description = 'The ID of the project.' )) async \u00b6 Approve all constraints. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow constraints approbation. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the confirmation of constraints approbation. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 @app . post ( \"/api/projects/ {project_id} /constraints/approve\" , tags = [ \"Constraints\" ], status_code = status . HTTP_201_CREATED , ) async def approve_all_constraints ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Approve all constraints. Args: project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow constraints approbation. Returns: Dict[str, Any]: A dictionary that contains the confirmation of constraints approbation. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Check status. if project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow constraints approbation during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status to clustering step. project_status [ \"state\" ] = ICGUIStates . CLUSTERING_TODO ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"detail\" : \"In project with id ' {project_id_str} ', the constraints have been approved.\" . format ( project_id_str = str ( project_id ), ), } comment_constraint ( project_id = Path ( Ellipsis , description = 'The ID of the project.' ), constraint_id = Path ( Ellipsis , description = 'The ID of the constraint.' ), constraint_comment = Query ( Ellipsis , description = 'The comment of constraint.' , max_length = 256 )) async \u00b6 Comment a constraint. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') constraint_id str The ID of the constraint. Path(Ellipsis, description='The ID of the constraint.') constraint_comment str The comment of constraint. Query(Ellipsis, description='The comment of constraint.', max_length=256) Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the constraint with id constraint_id to annotate doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of commented constraint. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 @app . put ( \"/api/projects/ {project_id} /constraints/ {constraint_id} /comment\" , tags = [ \"Constraints\" ], status_code = status . HTTP_202_ACCEPTED , ) async def comment_constraint ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), constraint_id : str = Path ( ... , description = \"The ID of the constraint.\" , ), constraint_comment : str = Query ( ... , description = \"The comment of constraint.\" , # min_length=0, max_length = 256 , ), ) -> Dict [ str , Any ]: \"\"\" Comment a constraint. Args: project_id (str): The ID of the project. constraint_id (str): The ID of the constraint. constraint_comment (str): The comment of constraint. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the constraint with id `constraint_id` to annotate doesn't exist. Returns: Dict[str, Any]: A dictionary that contains the ID of commented constraint. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load constraints file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Any ] = json . load ( constraints_fileobject_r ) ### ### Check parameters. ### # Check constraint id. if constraint_id not in constraints . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"In project with id ' {project_id_str} ', the constraint with id ' {constraint_id_str} ' to annotate doesn't exist.\" . format ( project_id_str = str ( project_id ), constraint_id_str = str ( constraint_id ), ), ) ### ### Update data. ### # Update constraints by commenting the constraint. constraints [ constraint_id ][ \"comment\" ] = constraint_comment ### ### Store updated data. ### # Store updated constraints in file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"constraint_id\" : constraint_id , \"constraint_comment\" : constraint_comment , \"detail\" : \"In project with id ' {project_id_str} ', the constraint with id ' {constraint_id_str} ' has been commented.\" . format ( project_id_str = str ( project_id ), constraint_id_str = str ( constraint_id ), ), } create_project ( project_name = Query ( Ellipsis , description = 'The name of the project. Should not be an empty string.' , min_length = 3 , max_length = 64 ), dataset_file = File ( Ellipsis , description = \"The dataset file to load. Use a `.csv` (`;` separator) or `.xlsx` file. Please use a list of texts in the first column, without header, with encoding 'utf-8'.\" )) async \u00b6 Create a project. Parameters: Name Type Description Default project_name str The name of the project. Should not be an empty string. Query(Ellipsis, description='The name of the project. Should not be an empty string.', min_length=3, max_length=64) dataset_file UploadFile The dataset file to load. Use a .csv ( ; separator) or .xlsx file. Please use a list of texts in the first column, without header, with encoding 'utf-8'. File(Ellipsis, description=\"The dataset file to load. Use a `.csv` (`;` separator) or `.xlsx` file. Please use a list of texts in the first column, without header, with encoding 'utf-8'.\") Raises: Type Description HTTPException Raises HTTP_400_BAD_REQUEST if parameters project_name or dataset_file are invalid. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of the created project. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 @app . post ( \"/api/projects\" , tags = [ \"Projects\" ], status_code = status . HTTP_201_CREATED , ) async def create_project ( project_name : str = Query ( ... , description = \"The name of the project. Should not be an empty string.\" , min_length = 3 , max_length = 64 , ), dataset_file : UploadFile = File ( ... , description = \"The dataset file to load. Use a `.csv` (`;` separator) or `.xlsx` file. Please use a list of texts in the first column, without header, with encoding 'utf-8'.\" , # TODO: max_size=\"8MB\", ), ) -> Dict [ str , Any ]: \"\"\" Create a project. Args: project_name (str): The name of the project. Should not be an empty string. dataset_file (UploadFile): The dataset file to load. Use a `.csv` (`;` separator) or `.xlsx` file. Please use a list of texts in the first column, without header, with encoding 'utf-8'. Raises: HTTPException: Raises `HTTP_400_BAD_REQUEST` if parameters `project_name` or `dataset_file` are invalid. Returns: Dict[str, Any]: A dictionary that contains the ID of the created project. \"\"\" # Define the new project ID. current_timestamp : float = datetime . now () . timestamp () current_project_id : str = str ( int ( current_timestamp * 10 ** 6 )) # Check project name. if project_name . strip () == \"\" : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = \"The project name ' {project_name_str} ' is invalid.\" . format ( project_name_str = str ( project_name ), ), ) # Initialize variable to store loaded dataset. list_of_texts : List [ str ] = [] # Load dataset: Case of `.csv` with `;` separator. if dataset_file . content_type in { \"text/csv\" , \"application/vnd.ms-excel\" }: # \"text/csv\" == \".csv\" # \"application/vnd.ms-excel\" == \".xls\" try : # noqa: WPS229 # Found too long `try` body length dataset_csv : pd . Dataframe = pd . read_csv ( filepath_or_buffer = dataset_file . file , sep = \";\" , header = None , # No header expected in the csv file. ) list_of_texts = dataset_csv [ dataset_csv . columns [ 0 ]] . tolist () except Exception : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = \"The dataset file is invalid. `.csv` file, with `;` separator, must contain a list of texts in the first column, with no header.\" , ) # Load dataset: Case of `.xlsx`. elif dataset_file . content_type == \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" : # \"application/vnd.ms-excel\" == \".xlsx\" try : # noqa: WPS229 # Found too long `try` body length dataset_xlsx : pd . Dataframe = pd . read_excel ( io = dataset_file . file . read (), engine = \"openpyxl\" , header = None , # No header expected in the xlsx file. ) list_of_texts = dataset_xlsx [ dataset_xlsx . columns [ 0 ]] . tolist () except Exception : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = \"The dataset file is invalid. `.xlsx` file must contain a list of texts in the first column, with no header.\" , ) # Load dataset: case of not supported type. else : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = \"The file type ' {dataset_file_type} ' is not supported. Please use '.csv' (`;` separator) or '.xlsx' file.\" . format ( dataset_file_type = str ( dataset_file . content_type ), ), ) # Create the directory and subdirectories of the new project. os . mkdir ( DATA_DIRECTORY / current_project_id ) # Initialize storage of metadata. with open ( DATA_DIRECTORY / current_project_id / \"metadata.json\" , \"w\" ) as metadata_fileobject : json . dump ( { \"project_id\" : current_project_id , \"project_name\" : str ( project_name . strip ()), \"creation_timestamp\" : current_timestamp , }, metadata_fileobject , indent = 4 , ) # Initialize storage of status. with open ( DATA_DIRECTORY / current_project_id / \"status.json\" , \"w\" ) as status_fileobject : json . dump ( { \"iteration_id\" : 0 , # Use string format for JSON serialization in dictionaries. \"state\" : ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION , \"task\" : None , # \"progression\", \"detail\". }, status_fileobject , indent = 4 , ) # Initialize storage of texts. with open ( DATA_DIRECTORY / current_project_id / \"texts.json\" , \"w\" ) as texts_fileobject : json . dump ( { str ( i ): { \"text_original\" : str ( text ), # Will never be changed. \"text\" : str ( text ), # Can be change by renaming. \"text_preprocessed\" : str ( text ), # Will be preprocessed during `Modelizationpdate` task. \"is_deleted\" : False , } for i , text in enumerate ( list_of_texts ) }, texts_fileobject , indent = 4 , ) # Initialize storage of constraints. with open ( DATA_DIRECTORY / current_project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject : json . dump ( {}, # Dict[str, Any] constraints_fileobject , indent = 4 , ) # Initialize storage of modelization inference assignations. with open ( DATA_DIRECTORY / current_project_id / \"modelization.json\" , \"w\" ) as modelization_fileobject : json . dump ( { str ( i ): { \"MUST_LINK\" : [ str ( i )], \"CANNOT_LINK\" : [], \"COMPONENT\" : i } for i in range ( len ( list_of_texts ))}, modelization_fileobject , indent = 4 , ) # Initialize settings storage. with open ( DATA_DIRECTORY / current_project_id / \"settings.json\" , \"w\" ) as settings_fileobject : json . dump ( { \"0\" : { \"preprocessing\" : default_PreprocessingSettingsModel () . to_dict (), \"vectorization\" : default_VectorizationSettingsModel () . to_dict (), \"clustering\" : default_ClusteringSettingsModel () . to_dict (), }, }, settings_fileobject , indent = 4 , ) # Initialize storage of sampling results. with open ( DATA_DIRECTORY / current_project_id / \"sampling.json\" , \"w\" ) as sampling_fileobject : json . dump ({}, sampling_fileobject , indent = 4 ) # Dict[str, List[str]] # Initialize storage of clustering results. with open ( DATA_DIRECTORY / current_project_id / \"clustering.json\" , \"w\" ) as clustering_fileobject : json . dump ({}, clustering_fileobject , indent = 4 ) # Dict[str, Dict[str, str]] # Return the ID of the created project. return { \"project_id\" : current_project_id , \"detail\" : \"The project with name ' {project_name_str} ' has been created. It has the id ' {project_id_str} '.\" . format ( project_name_str = str ( project_name ), project_id_str = str ( current_project_id ), ), } delete_project ( project_id = Path ( Ellipsis , description = 'The ID of the project to delete.' )) async \u00b6 Delete a project. Parameters: Name Type Description Default project_id str The ID of the project to delete. Path(Ellipsis, description='The ID of the project to delete.') Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of the deleted project. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 @app . delete ( \"/api/projects/ {project_id} \" , tags = [ \"Projects\" ], status_code = status . HTTP_202_ACCEPTED , ) async def delete_project ( project_id : str = Path ( ... , description = \"The ID of the project to delete.\" , ), ) -> Dict [ str , Any ]: \"\"\" Delete a project. Args: project_id (str): The ID of the project to delete. Returns: Dict[str, Any]: A dictionary that contains the ID of the deleted project. \"\"\" # Delete the project. if os . path . isdir ( DATA_DIRECTORY / project_id ): shutil . rmtree ( DATA_DIRECTORY / project_id , ignore_errors = True ) # Return the deleted project id. return { \"project_id\" : project_id , \"detail\" : \"The deletion of project with id ' {project_id_str} ' is accepted.\" . format ( project_id_str = str ( project_id ), ), } delete_text ( project_id = Path ( Ellipsis , description = 'The ID of the project.' ), text_id = Path ( Ellipsis , description = 'The ID of the text.' )) async \u00b6 Delete a text. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') text_id str The ID of the text. Path(Ellipsis, description='The ID of the text.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the text with id text_id to delete doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow modification. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of deleted text. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 @app . put ( \"/api/projects/ {project_id} /texts/ {text_id} /delete\" , tags = [ \"Texts\" ], status_code = status . HTTP_202_ACCEPTED , ) async def delete_text ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), text_id : str = Path ( ... , description = \"The ID of the text.\" , ), ) -> Dict [ str , Any ]: \"\"\" Delete a text. Args: project_id (str): The ID of the project. text_id (str): The ID of the text. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the text with id `text_id` to delete doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow modification. Returns: Dict[str, Any]: A dictionary that contains the ID of deleted text. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Load texts file. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"r\" ) as texts_fileobject_r : texts : Dict [ str , Any ] = json . load ( texts_fileobject_r ) # Load constraints file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Any ] = json . load ( constraints_fileobject_r ) ### ### Check parameters. ### # Check text id. if text_id not in texts . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"In project with id ' {project_id_str} ', the text with id ' {text_id_str} ' to delete doesn't exist.\" . format ( project_id_str = str ( project_id ), text_id_str = str ( text_id ), ), ) # Check status. if ( project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow modification during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"outdated\" status. if project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS # Update texts by deleting the text. texts [ text_id ][ \"is_deleted\" ] = True # Update constraints by hidding those associated with the deleted text. for constraint_id , constraint_value in constraints . items (): data_id1 : str = constraint_value [ \"data\" ][ \"id_1\" ] data_id2 : str = constraint_value [ \"data\" ][ \"id_2\" ] if text_id in { data_id1 , data_id2 , }: constraints [ constraint_id ][ \"is_hidden\" ] = True ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Store updated texts in file. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"w\" ) as texts_fileobject_w : json . dump ( texts , texts_fileobject_w , indent = 4 ) # Store updated constraints in file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"text_id\" : text_id , \"detail\" : \"In project with id ' {project_id_str} ', the text with id ' {text_id_str} ' has been deleted. Several constraints have been hidden.\" . format ( project_id_str = str ( project_id ), text_id_str = str ( text_id ), ), } download_project ( background_tasks , project_id = Path ( Ellipsis , description = 'The ID of the project to download.' )) async \u00b6 Download a project in a zip archive. Parameters: Name Type Description Default background_tasks BackgroundTasks A background task to run after the return statement. required project_id str The ID of the project to download. Path(Ellipsis, description='The ID of the project to download.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. Returns: Name Type Description FileResponse FileResponse A zip archive of the project. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 @app . get ( \"/api/projects/ {project_id} /download\" , tags = [ \"Projects\" ], response_class = FileResponse , status_code = status . HTTP_200_OK , ) async def download_project ( background_tasks : BackgroundTasks , project_id : str = Path ( ... , description = \"The ID of the project to download.\" , ), ) -> FileResponse : \"\"\" Download a project in a zip archive. Args: background_tasks (BackgroundTasks): A background task to run after the return statement. project_id (str): The ID of the project to download. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. Returns: FileResponse: A zip archive of the project. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Define archive name. archive_name : str = \"archive- {project_id_str} .zip\" . format ( project_id_str = str ( project_id )) archive_path : pathlib . Path = DATA_DIRECTORY / project_id / archive_name # Zip the project in an archive. with zipfile . ZipFile ( archive_path , \"w\" , zipfile . ZIP_DEFLATED ) as archive_filewriter : archive_filewriter . write ( DATA_DIRECTORY / project_id / \"metadata.json\" , arcname = \"metadata.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"status.json\" , arcname = \"status.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"texts.json\" , arcname = \"texts.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"constraints.json\" , arcname = \"constraints.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"settings.json\" , arcname = \"settings.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"sampling.json\" , arcname = \"sampling.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"clustering.json\" , arcname = \"clustering.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"modelization.json\" , arcname = \"modelization.json\" ) if \"vectors_2D.json\" in os . listdir ( DATA_DIRECTORY / project_id ): archive_filewriter . write ( DATA_DIRECTORY / project_id / \"vectors_2D.json\" , arcname = \"vectors_2D.json\" ) if \"vectors_3D.json\" in os . listdir ( DATA_DIRECTORY / project_id ): archive_filewriter . write ( DATA_DIRECTORY / project_id / \"vectors_3D.json\" , arcname = \"vectors_3D.json\" ) # Define a backgroundtask to clear archive after downloading. def clear_after_download_project (): # noqa: WPS430 (nested function) \"\"\" Delete the archive file. \"\"\" # Delete archive file. if os . path . exists ( archive_path ): # pragma: no cover os . remove ( archive_path ) # Add the background task. background_tasks . add_task ( func = clear_after_download_project , ) # Return the zip archive of the project. return FileResponse ( archive_path , media_type = \"application/x-zip-compressed\" , filename = archive_name , ) get_constrained_clustering_results ( project_id = Path ( Ellipsis , description = 'The ID of the project.' ), iteration_id = Query ( None , description = 'The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.' )) async \u00b6 Get constrained clustering results. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') iteration_id Optional [ int ] The ID of project iteration. If None , get the current iteration. Defaults to None . Query(None, description='The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the iteration with id iteration_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the status of the project hasn't completed its clustering step. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains clustering result. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3523 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 3574 3575 3576 3577 3578 3579 3580 3581 3582 3583 3584 3585 3586 3587 3588 3589 3590 3591 3592 3593 3594 3595 3596 3597 3598 3599 3600 3601 3602 3603 3604 3605 3606 3607 3608 3609 3610 3611 3612 3613 3614 3615 3616 3617 @app . get ( \"/api/projects/ {project_id} /clustering\" , tags = [ \"Constrained clustering\" ], status_code = status . HTTP_200_OK , ) async def get_constrained_clustering_results ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), iteration_id : Optional [ int ] = Query ( None , description = \"The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get constrained clustering results. Args: project_id (str, optional): The ID of the project. iteration_id (Optional[int], optional): The ID of project iteration. If `None`, get the current iteration. Defaults to `None`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the iteration with id `iteration_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the status of the project hasn't completed its clustering step. Returns: Dict[str, Any]: A dictionary that contains clustering result. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Load clustering. with open ( DATA_DIRECTORY / project_id / \"clustering.json\" , \"r\" ) as clustering_fileobject : project_clustering : Dict [ str , Dict [ str , Any ]] = json . load ( clustering_fileobject ) # Set iteration id if needed. if iteration_id is None : if ( project_status [ \"iteration_id\" ] == 0 or project_status [ \"state\" ] == ICGUIStates . ITERATION_END or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_ERRORS ): iteration_id = project_status [ \"iteration_id\" ] else : iteration_id = project_status [ \"iteration_id\" ] - 1 # Check project status. if ( iteration_id == project_status [ \"iteration_id\" ] and project_status [ \"state\" ] != ICGUIStates . ITERATION_END and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_ITERATION_END_WITH_ERRORS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' hasn't completed its clustering step on iteration ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( iteration_id ), ), ) # Otherwise check that requested iteration id exist. if str ( iteration_id ) not in project_clustering . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' has no iteration with id ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( iteration_id ), ), ) # Return the project clustering. return { \"project_id\" : project_id , \"iteration_id\" : iteration_id , \"clustering\" : project_clustering [ str ( iteration_id )], } get_constraints ( project_id = Path ( Ellipsis , description = 'The ID of the project.' ), without_hidden_constraints = Query ( True , description = 'The option to not return hidden constraints. Defaults to `True`.' ), sorted_by = Query ( ConstraintsSortOptions . ID , description = 'The option to sort constraints. Defaults to `ID`.' ), sorted_reverse = Query ( False , description = 'The option to reverse constraints order. Defaults to `False`.' )) async \u00b6 Get constraints. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') without_hidden_constraints bool The option to not return hidden constraints. Defaults to True . Query(True, description='The option to not return hidden constraints. Defaults to `True`.') sorted_by ConstraintsSortOptions The option to sort constraints. Defaults to ID . Query(ConstraintsSortOptions.ID, description='The option to sort constraints. Defaults to `ID`.') sorted_reverse bool The option to reverse constraints order. Defaults to False . Query(False, description='The option to reverse constraints order. Defaults to `False`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains constraints. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 @app . get ( \"/api/projects/ {project_id} /constraints\" , tags = [ \"Constraints\" ], status_code = status . HTTP_200_OK , ) async def get_constraints ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), without_hidden_constraints : bool = Query ( True , description = \"The option to not return hidden constraints. Defaults to `True`.\" , ), sorted_by : ConstraintsSortOptions = Query ( ConstraintsSortOptions . ID , description = \"The option to sort constraints. Defaults to `ID`.\" , ), sorted_reverse : bool = Query ( False , description = \"The option to reverse constraints order. Defaults to `False`.\" , ), # TODO: filter_text # TODO: limit_size + offset ) -> Dict [ str , Any ]: \"\"\" Get constraints. Args: project_id (str): The ID of the project. without_hidden_constraints (bool, optional): The option to not return hidden constraints. Defaults to `True`. sorted_by (ConstraintsSortOptions, optional): The option to sort constraints. Defaults to `ID`. sorted_reverse (bool, optional): The option to reverse constraints order. Defaults to `False`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. Returns: Dict[str, Any]: A dictionary that contains constraints. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) ### ### Load needed data. ### # Load constraints. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject : constraints : Dict [ str , Any ] = { constraint_id : constraint_value for constraint_id , constraint_value in json . load ( constraints_fileobject ) . items () if ( without_hidden_constraints is False or constraint_value [ \"is_hidden\" ] is False ) } # Load texts. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"r\" ) as texts_fileobject : texts : Dict [ str , Any ] = json . load ( texts_fileobject ) ### ### Sort constraints. ### # Define the values selection method. def get_value_for_constraints_sorting ( # noqa: WPS430 (nested function) constraint_to_sort : Tuple [ str , Dict [ str , Any ]] ) -> Any : \"\"\"Return the values expected for constraints sorting. Args: constraint_to_sort (Tuple[Dict[str, Any]]): A constraint (from `.items()`). Returns: Any: The expected values of the constraint need for the sort. \"\"\" # By constraint id. if sorted_by == ConstraintsSortOptions . ID : return constraint_to_sort [ 0 ] # By texts. if sorted_by == ConstraintsSortOptions . TEXT : return ( texts [ constraint_to_sort [ 1 ][ \"data\" ][ \"id_1\" ]][ \"text\" ], texts [ constraint_to_sort [ 1 ][ \"data\" ][ \"id_2\" ]][ \"text\" ], ) # By constraint type. if sorted_by == ConstraintsSortOptions . CONSTRAINT_TYPE : return ( constraint_to_sort [ 1 ][ \"constraint_type\" ] is None , constraint_to_sort [ 1 ][ \"constraint_type\" ] == \"CANNOT_LINK\" , constraint_to_sort [ 1 ][ \"constraint_type\" ] == \"MUST_LINK\" , ) # By date of update. if sorted_by == ConstraintsSortOptions . DATE_OF_UPDATE : return constraint_to_sort [ 1 ][ \"date_of_update\" ] # By iteration of sampling. if sorted_by == ConstraintsSortOptions . ITERATION_OF_SAMPLING : return constraint_to_sort [ 1 ][ \"iteration_of_sampling\" ] # To annotation. if sorted_by == ConstraintsSortOptions . TO_ANNOTATE : return constraint_to_sort [ 1 ][ \"to_annotate\" ] is False # To review. if sorted_by == ConstraintsSortOptions . TO_REVIEW : return constraint_to_sort [ 1 ][ \"to_review\" ] is False # To fix conflict. #### if sorted_by == ConstraintsSortOptions.TO_FIX_CONFLICT: return constraint_to_sort [ 1 ][ \"to_fix_conflict\" ] is False # Sorted the constraints to return. sorted_constraints : Dict [ str , Any ] = { sorted_constraint_id : sorted_constraint for sorted_constraint_id , sorted_constraint in sorted ( constraints . items (), key = get_value_for_constraints_sorting , reverse = sorted_reverse , ) } # Return the requested constraints. return { \"project_id\" : project_id , \"constraints\" : sorted_constraints , # Get the request parameters. \"parameters\" : { \"without_hidden_constraints\" : without_hidden_constraints , \"sorted_by\" : sorted_by . value , \"sorted_reverse\" : sorted_reverse , }, } get_constraints_sampling_results ( project_id = Path ( Ellipsis , description = 'The ID of the project.' ), iteration_id = Query ( None , description = 'The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.' )) async \u00b6 Get constraints sampling results. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') iteration_id Optional [ int ] The ID of project iteration. If None , get the current iteration. Defaults to None . Query(None, description='The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the iteration with id iteration_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the status of the project hasn't completed its sampling step. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains sampling result. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 @app . get ( \"/api/projects/ {project_id} /sampling\" , tags = [ \"Constraints sampling\" ], status_code = status . HTTP_200_OK , ) async def get_constraints_sampling_results ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), iteration_id : Optional [ int ] = Query ( None , description = \"The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get constraints sampling results. Args: project_id (str, optional): The ID of the project. iteration_id (Optional[int], optional): The ID of project iteration. If `None`, get the current iteration. Defaults to `None`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the iteration with id `iteration_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the status of the project hasn't completed its sampling step. Returns: Dict[str, Any]: A dictionary that contains sampling result. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load settings. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject : project_settings : Dict [ str , Dict [ str , Any ]] = json . load ( settings_fileobject ) # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Get current iteration id if needed. if iteration_id is None : if project_status [ \"iteration_id\" ] == 0 : iteration_id = 0 elif ( project_status [ \"state\" ] == ICGUIStates . SAMPLING_TODO # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . SAMPLING_PENDING or project_status [ \"state\" ] == ICGUIStates . SAMPLING_WORKING or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_ERRORS ): iteration_id = project_status [ \"iteration_id\" ] - 1 else : iteration_id = project_status [ \"iteration_id\" ] # Case of iteration `0`. if iteration_id == 0 : raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The iteration `0` has no sampling step.\" , ) # Check project status. if iteration_id == project_status [ \"iteration_id\" ] and ( project_status [ \"state\" ] == ICGUIStates . SAMPLING_TODO # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . SAMPLING_PENDING or project_status [ \"state\" ] == ICGUIStates . SAMPLING_WORKING or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_ERRORS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' hasn't completed its sampling step on iteration ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( iteration_id ), ), ) # Otherwise check that requested iteration id exist. if str ( iteration_id ) not in project_settings . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' has no iteration with id ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( iteration_id ), ), ) # Load the sampling results. with open ( DATA_DIRECTORY / project_id / \"sampling.json\" , \"r\" ) as sampling_fileobject : # Return the project sampling. return { \"project_id\" : project_id , \"iteration_id\" : iteration_id , \"sampling\" : json . load ( sampling_fileobject )[ str ( iteration_id )], } get_html_constraint_annotation_page ( request , project_id = Path ( Ellipsis , description = 'The ID of the project.' ), constraint_id = Path ( Ellipsis , description = 'The ID of the constraint.' )) async \u00b6 Get HTML constraint annotation page. Parameters: Name Type Description Default request Request The request context. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') constraint_id str The ID of the constraint. Path(Ellipsis, description='The ID of the constraint.') Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 @app . get ( \"/gui/projects/ {project_id} /constraints/ {constraint_id} \" , tags = [ \"Constraints\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_constraint_annotation_page ( request : Request , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), constraint_id : str = Path ( ... , description = \"The ID of the constraint.\" , ), ) -> Response : \"\"\" Get HTML constraint annotation page. Args: request (Request): The request context. project_id (str): The ID of the project. constraint_id (str): The ID of the constraint. Returns: Response: The requested page. \"\"\" # Return HTML constraints page. try : return templates . TemplateResponse ( name = \"constraint_annotation.html\" , context = { \"request\" : request , # Get the project ID. \"project_id\" : project_id , # Get the constraints ID. \"constraint_id\" : constraint_id , # Get the project metadata (ID, name, creation date). \"metadata\" : ( await get_metadata ( project_id = project_id ))[ \"metadata\" ], # Get the project status (iteration, step name and status, modelization state and conflict). \"status\" : ( await get_status ( project_id = project_id ))[ \"status\" ], # Get the project texts. \"texts\" : ( await get_texts ( project_id = project_id , without_deleted_texts = False , sorted_by = TextsSortOptions . ID , sorted_reverse = False , ) )[ \"texts\" ], # Get the project constraints. \"constraints\" : ( await get_constraints ( project_id = project_id , without_hidden_constraints = False , sorted_by = ConstraintsSortOptions . ITERATION_OF_SAMPLING , sorted_reverse = False , ) )[ \"constraints\" ], # Get the project clustering result. \"clusters\" : ( await get_constrained_clustering_results ( project_id = project_id , iteration_id = None ))[ \"clustering\" ], # Get the project modelization inference result. \"modelization\" : ( await get_modelization ( project_id = project_id ))[ \"modelization\" ], }, status_code = status . HTTP_200_OK , ) # Case of error: Return HTML error page. except HTTPException as error : # Return HTML error page. return templates . TemplateResponse ( name = \"error.html\" , context = { \"request\" : request , \"status_code\" : error . status_code , \"detail\" : error . detail , }, status_code = error . status_code , ) get_html_constraints_page ( request , project_id = Path ( Ellipsis , description = 'The ID of the project.' ), sorted_by = Query ( ConstraintsSortOptions . ITERATION_OF_SAMPLING , description = 'The option to sort constraints. Defaults to `ITERATION_OF_SAMPLING`.' ), sorted_reverse = Query ( False , description = 'The option to reverse constraints order. Defaults to `False`.' )) async \u00b6 Get HTML constraints page. Parameters: Name Type Description Default request Request The request context. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') sorted_by ConstraintsSortOptions The option to sort constraints. Defaults to ITERATION_OF_SAMPLING . Query(ConstraintsSortOptions.ITERATION_OF_SAMPLING, description='The option to sort constraints. Defaults to `ITERATION_OF_SAMPLING`.') sorted_reverse bool The option to reverse constraints order. Defaults to False . Query(False, description='The option to reverse constraints order. Defaults to `False`.') Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 @app . get ( \"/gui/projects/ {project_id} /constraints\" , tags = [ \"Constraints\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_constraints_page ( request : Request , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), sorted_by : ConstraintsSortOptions = Query ( ConstraintsSortOptions . ITERATION_OF_SAMPLING , description = \"The option to sort constraints. Defaults to `ITERATION_OF_SAMPLING`.\" , ), sorted_reverse : bool = Query ( False , description = \"The option to reverse constraints order. Defaults to `False`.\" , ), # TODO: filter_text # TODO: limit_size + offset ) -> Response : \"\"\" Get HTML constraints page. Args: request (Request): The request context. project_id (str): The ID of the project. sorted_by (ConstraintsSortOptions, optional): The option to sort constraints. Defaults to `ITERATION_OF_SAMPLING`. sorted_reverse (bool, optional): The option to reverse constraints order. Defaults to `False`. Returns: Response: The requested page. \"\"\" # Return HTML constraints page. try : return templates . TemplateResponse ( name = \"constraints.html\" , context = { \"request\" : request , # Get the project ID. \"project_id\" : project_id , # Get the request parameters. \"parameters\" : { \"without_hidden_constraints\" : True , \"sorted_by\" : sorted_by . value , \"sorted_reverse\" : sorted_reverse , }, # Get the project metadata (ID, name, creation date). \"metadata\" : ( await get_metadata ( project_id = project_id ))[ \"metadata\" ], # Get the project status (iteration, step name and status, modelization state and conflict). \"status\" : ( await get_status ( project_id = project_id ))[ \"status\" ], # Get the project texts. \"texts\" : ( await get_texts ( project_id = project_id , without_deleted_texts = False , sorted_by = TextsSortOptions . ID , sorted_reverse = False , ) )[ \"texts\" ], # Get the project constraints. \"constraints\" : ( await get_constraints ( project_id = project_id , without_hidden_constraints = True , sorted_by = sorted_by , sorted_reverse = sorted_reverse , ) )[ \"constraints\" ], }, status_code = status . HTTP_200_OK , ) # Case of error: Return HTML error page. except HTTPException as error : # Return HTML error page. return templates . TemplateResponse ( name = \"error.html\" , context = { \"request\" : request , \"status_code\" : error . status_code , \"detail\" : error . detail , }, status_code = error . status_code , ) get_html_help_page ( request ) async \u00b6 Get HTML help page. Parameters: Name Type Description Default request Request The request context. required Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 @app . get ( \"/gui/help\" , tags = [ \"Home and Documentation\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_help_page ( request : Request , ) -> Response : \"\"\" Get HTML help page. Args: request (Request): The request context. Returns: Response: The requested page. \"\"\" # Return HTML help page. return templates . TemplateResponse ( name = \"help.html\" , context = { \"request\" : request , }, status_code = status . HTTP_200_OK , ) get_html_project_home_page ( request , project_id = Path ( Ellipsis , description = 'The ID of the project.' )) async \u00b6 Get HTML project home page. Parameters: Name Type Description Default request Request The request context. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 @app . get ( \"/gui/projects/ {project_id} \" , tags = [ \"Projects\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_project_home_page ( request : Request , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Response : \"\"\" Get HTML project home page. Args: request (Request): The request context. project_id (str): The ID of the project. Returns: Response: The requested page. \"\"\" # Return HTML project home page. try : return templates . TemplateResponse ( name = \"project_home.html\" , context = { \"request\" : request , # Get the project ID. \"project_id\" : project_id , # Get the project metadata (ID, name, creation date). \"metadata\" : ( await get_metadata ( project_id = project_id ))[ \"metadata\" ], # Get the project status (iteration, step name and status, modelization state and conflict). \"status\" : ( await get_status ( project_id = project_id ))[ \"status\" ], }, status_code = status . HTTP_200_OK , ) # Case of error: Return HTML error page. except HTTPException as error : # Return HTML error page. return templates . TemplateResponse ( name = \"error.html\" , context = { \"request\" : request , \"status_code\" : error . status_code , \"detail\" : error . detail , }, status_code = error . status_code , ) get_html_projects_listing_or_creation_page ( request ) async \u00b6 Get HTML projects listing or creation page. Parameters: Name Type Description Default request Request The request context. required Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 @app . get ( \"/gui/projects\" , tags = [ \"Projects\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_projects_listing_or_creation_page ( request : Request , ) -> Response : \"\"\" Get HTML projects listing or creation page. Args: request (Request): The request context. Returns: Response: The requested page. \"\"\" # Return HTML projects listing and creation page. return templates . TemplateResponse ( name = \"projects_listing.html\" , context = { \"request\" : request , # Get projects and their description. \"projects\" : { project_id : { \"metadata\" : ( await get_metadata ( project_id = project_id ))[ \"metadata\" ], \"status\" : ( await get_status ( project_id = project_id ))[ \"status\" ], } for project_id in ( await get_projects ()) }, }, status_code = status . HTTP_200_OK , ) get_html_settings_page ( request , project_id = Path ( Ellipsis , description = 'The ID of the project.' ), iteration_id = Query ( None , description = 'The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.' ), settings_names = Query ([ ICGUISettings . PREPROCESSING , ICGUISettings . VECTORIZATION , ICGUISettings . SAMPLING , ICGUISettings . CLUSTERING ], description = 'The list of names of requested settings to return. To select multiple settings kinds, use `CTRL + clic`.' )) async \u00b6 Get HTML settings page. Parameters: Name Type Description Default request Request The request context. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') iteration_id Optional [ int ] The ID of project iteration. If None , get the current iteration. Defaults to None . Query(None, description='The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.') settings_names List [ ICGUISettings ] The list of names of requested settings to return. Defaults to [ICGUISettings.PREPROCESSING, ICGUISettings.VECTORIZATION, ICGUISettings.SAMPLING, ICGUISettings.CLUSTERING,] . Query([ICGUISettings.PREPROCESSING, ICGUISettings.VECTORIZATION, ICGUISettings.SAMPLING, ICGUISettings.CLUSTERING], description='The list of names of requested settings to return. To select multiple settings kinds, use `CTRL + clic`.') Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 @app . get ( \"/gui/projects/ {project_id} /settings\" , tags = [ \"Settings\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_settings_page ( request : Request , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), iteration_id : Optional [ int ] = Query ( None , description = \"The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.\" , ), settings_names : List [ ICGUISettings ] = Query ( [ ICGUISettings . PREPROCESSING , ICGUISettings . VECTORIZATION , ICGUISettings . SAMPLING , ICGUISettings . CLUSTERING , ], description = \"The list of names of requested settings to return. To select multiple settings kinds, use `CTRL + clic`.\" , ), ) -> Response : \"\"\" Get HTML settings page. Args: request (Request): The request context. project_id (str): The ID of the project. iteration_id (Optional[int], optional): The ID of project iteration. If `None`, get the current iteration. Defaults to `None`. settings_names (List[ICGUISettings], optional): The list of names of requested settings to return. Defaults to `[ICGUISettings.PREPROCESSING, ICGUISettings.VECTORIZATION, ICGUISettings.SAMPLING, ICGUISettings.CLUSTERING,]`. Returns: Response: The requested page. \"\"\" # Return HTML project home page. try : # noqa: WPS229 (too long try body) project_status : Dict [ str , Any ] = ( await get_status ( project_id = project_id ))[ \"status\" ] if iteration_id is None : iteration_id = project_status [ \"iteration_id\" ] return templates . TemplateResponse ( name = \"settings.html\" , context = { \"request\" : request , # Get the project ID. \"project_id\" : project_id , # Get the iteration ID. \"iteration_id\" : iteration_id , # Get the request parameters. \"parameters\" : { \"settings_names\" : [ settings_name . value for settings_name in settings_names ], }, # Get the project metadata (ID, name, creation date). \"metadata\" : ( await get_metadata ( project_id = project_id ))[ \"metadata\" ], # Get the project status (iteration, step name and status, modelization state and conflict). \"status\" : project_status , # Get the project settings (preprocessing, vectorization, sampling, clustering). \"settings\" : ( await get_settings ( project_id = project_id , iteration_id = iteration_id , settings_names = settings_names ) )[ \"settings\" ], # Get navigation information. \"navigation\" : { \"previous\" : ( None if ( iteration_id == 0 ) else iteration_id - 1 ), \"next\" : ( None if ( iteration_id == project_status [ \"iteration_id\" ]) else ( iteration_id + 1 )), }, }, status_code = status . HTTP_200_OK , ) # Case of error: Return HTML error page. except HTTPException as error : # Return HTML error page. return templates . TemplateResponse ( name = \"error.html\" , context = { \"request\" : request , \"status_code\" : error . status_code , \"detail\" : error . detail , }, status_code = error . status_code , ) get_html_texts_page ( request , project_id = Path ( Ellipsis , description = 'The ID of the project.' ), sorted_by = Query ( TextsSortOptions . ALPHABETICAL , description = 'The option to sort texts. Defaults to `ALPHABETICAL`.' ), sorted_reverse = Query ( False , description = 'The option to reverse texts order. Defaults to `False`.' )) async \u00b6 Get HTML texts page. Parameters: Name Type Description Default request Request The request context. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') sorted_by TextsSortOptions The option to sort texts. Defaults to ALPHABETICAL . Query(TextsSortOptions.ALPHABETICAL, description='The option to sort texts. Defaults to `ALPHABETICAL`.') sorted_reverse bool The option to reverse texts order. Defaults to False . Query(False, description='The option to reverse texts order. Defaults to `False`.') Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 @app . get ( \"/gui/projects/ {project_id} /texts\" , tags = [ \"Texts\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_texts_page ( request : Request , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), sorted_by : TextsSortOptions = Query ( TextsSortOptions . ALPHABETICAL , description = \"The option to sort texts. Defaults to `ALPHABETICAL`.\" , ), sorted_reverse : bool = Query ( False , description = \"The option to reverse texts order. Defaults to `False`.\" , ), # TODO: filter_text # TODO: limit_size + offset ) -> Response : \"\"\" Get HTML texts page. Args: request (Request): The request context. project_id (str): The ID of the project. sorted_by (TextsSortOptions, optional): The option to sort texts. Defaults to `ALPHABETICAL`. sorted_reverse (bool, optional): The option to reverse texts order. Defaults to `False`. Returns: Response: The requested page. \"\"\" # Return HTML constraints page. try : return templates . TemplateResponse ( name = \"texts.html\" , context = { \"request\" : request , # Get the project ID. \"project_id\" : project_id , # Get the request parameters. \"parameters\" : { \"without_deleted_texts\" : True , \"sorted_by\" : sorted_by . value , \"sorted_reverse\" : sorted_reverse , }, # Get the project metadata (ID, name, creation date). \"metadata\" : ( await get_metadata ( project_id = project_id ))[ \"metadata\" ], # Get the project status (iteration, step name and status, modelization state and conflict). \"status\" : ( await get_status ( project_id = project_id ))[ \"status\" ], # Get the project texts. \"texts\" : ( await get_texts ( project_id = project_id , without_deleted_texts = False , sorted_by = sorted_by , sorted_reverse = sorted_reverse , ) )[ \"texts\" ], # Get the project constraints. \"constraints\" : ( await get_constraints ( project_id = project_id , without_hidden_constraints = True , sorted_by = ConstraintsSortOptions . ID , sorted_reverse = False , ) )[ \"constraints\" ], }, status_code = status . HTTP_200_OK , ) # Case of error: Return HTML error page. except HTTPException as error : # Return HTML error page. return templates . TemplateResponse ( name = \"error.html\" , context = { \"request\" : request , \"status_code\" : error . status_code , \"detail\" : error . detail , }, status_code = error . status_code , ) get_html_welcome_page ( request ) async \u00b6 Define HTML welcome page. Parameters: Name Type Description Default request Request The request context. required Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 @app . get ( \"/welcome\" , # TODO: Use \"/\". tags = [ \"Home and Documentation\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_welcome_page ( request : Request , ) -> Response : \"\"\" Define HTML welcome page. Args: request (Request): The request context. Returns: Response: The requested page. \"\"\" # Return HTML welcome page. return templates . TemplateResponse ( name = \"welcome.html\" , context = { \"request\" : request , }, status_code = status . HTTP_200_OK , ) get_metadata ( project_id = Path ( Ellipsis , description = 'The ID of the project.' )) async \u00b6 Get metadata. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains metadata. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 @app . get ( \"/api/projects/ {project_id} /metadata\" , tags = [ \"Projects\" ], status_code = status . HTTP_200_OK , ) async def get_metadata ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get metadata. Args: project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. Returns: Dict[str, Any]: A dictionary that contains metadata. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load the project metadata. with open ( DATA_DIRECTORY / project_id / \"metadata.json\" , \"r\" ) as metadata_fileobject : # Return the project metadata. return { \"project_id\" : project_id , \"metadata\" : json . load ( metadata_fileobject ), } get_modelization ( project_id = Path ( Ellipsis , description = 'The ID of the project.' )) async \u00b6 Get modelization inference. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains modelization inference result. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 @app . get ( \"/api/projects/ {project_id} /modelization\" , tags = [ \"Data modelization\" ], status_code = status . HTTP_200_OK , ) async def get_modelization ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get modelization inference. Args: project_id (str, optional): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. Returns: Dict[str, Any]: A dictionary that contains modelization inference result. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load the modelization inference results. with open ( DATA_DIRECTORY / project_id / \"modelization.json\" , \"r\" ) as modelization_fileobject : # Return the project modelization inference. return { \"project_id\" : project_id , \"modelization\" : json . load ( modelization_fileobject ), } get_next_key ( key , dictionary ) \u00b6 Get next key in a dictionary. Parameters: Name Type Description Default key str The current key. required dictionary Dict [ str , Any ] The dictionary. required Returns: Type Description Optional [ str ] Optional[str]: The next key. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def get_next_key ( key : str , dictionary : Dict [ str , Any ]) -> Optional [ str ]: \"\"\" Get next key in a dictionary. Args: key (str): The current key. dictionary (Dict[str, Any]): The dictionary. Returns: Optional[str]: The next key. \"\"\" list_of_keys : List [ str ] = list ( dictionary . keys ()) if key in list_of_keys : next_key_index : int = list_of_keys . index ( key ) + 1 return list_of_keys [ next_key_index ] if next_key_index < len ( list_of_keys ) else None return None get_previous_key ( key , dictionary ) \u00b6 Get previous key in a dictionary. Parameters: Name Type Description Default key str The current key. required dictionary Dict [ str , Any ] The dictionary. required Returns: Type Description Optional [ str ] Optional[str]: The previous key. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def get_previous_key ( key : str , dictionary : Dict [ str , Any ]) -> Optional [ str ]: \"\"\" Get previous key in a dictionary. Args: key (str): The current key. dictionary (Dict[str, Any]): The dictionary. Returns: Optional[str]: The previous key. \"\"\" list_of_keys : List [ str ] = list ( dictionary . keys ()) if key in list_of_keys : previous_key_index : int = list_of_keys . index ( key ) - 1 return list_of_keys [ previous_key_index ] if 0 <= previous_key_index else None return None get_projects () async \u00b6 Get the list of existing project IDs. (A project is represented by a subfolder in .data folder.) Returns: Type Description List [ str ] List[str]: The list of existing project IDs. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 @app . get ( \"/api/projects\" , tags = [ \"Projects\" ], status_code = status . HTTP_200_OK , ) async def get_projects () -> List [ str ]: \"\"\" Get the list of existing project IDs. (A project is represented by a subfolder in `.data` folder.) Returns: List[str]: The list of existing project IDs. \"\"\" # Return the list of project IDs. return [ project_id for project_id in os . listdir ( DATA_DIRECTORY ) if os . path . isdir ( DATA_DIRECTORY / project_id )] get_settings ( project_id = Path ( Ellipsis , description = 'The ID of the project.' ), iteration_id = Query ( None , description = 'The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.' ), settings_names = Query ([ ICGUISettings . PREPROCESSING , ICGUISettings . VECTORIZATION , ICGUISettings . SAMPLING , ICGUISettings . CLUSTERING ], description = 'The list of names of requested settings to return. To select multiple settings kinds, use `CTRL + clic`.' )) async \u00b6 Get settings. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') iteration_id Optional [ int ] The ID of project iteration. If None , get the current iteration. Defaults to None . Query(None, description='The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.') settings_names List [ ICGUISettings ] The list of names of requested settings to return. Defaults to [ICGUISettings.PREPROCESSING, ICGUISettings.VECTORIZATION, ICGUISettings.SAMPLING, ICGUISettings.CLUSTERING,] . Query([ICGUISettings.PREPROCESSING, ICGUISettings.VECTORIZATION, ICGUISettings.SAMPLING, ICGUISettings.CLUSTERING], description='The list of names of requested settings to return. To select multiple settings kinds, use `CTRL + clic`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the iteration with id iteration_id doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains settings. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 @app . get ( \"/api/projects/ {project_id} /settings\" , tags = [ \"Settings\" ], status_code = status . HTTP_200_OK , ) async def get_settings ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), iteration_id : Optional [ int ] = Query ( None , description = \"The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.\" , ), settings_names : List [ ICGUISettings ] = Query ( [ ICGUISettings . PREPROCESSING , ICGUISettings . VECTORIZATION , ICGUISettings . SAMPLING , ICGUISettings . CLUSTERING , ], description = \"The list of names of requested settings to return. To select multiple settings kinds, use `CTRL + clic`.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get settings. Args: project_id (str): The ID of the project. iteration_id (Optional[int], optional): The ID of project iteration. If `None`, get the current iteration. Defaults to `None`. settings_names (List[ICGUISettings], optional): The list of names of requested settings to return. Defaults to `[ICGUISettings.PREPROCESSING, ICGUISettings.VECTORIZATION, ICGUISettings.SAMPLING, ICGUISettings.CLUSTERING,]`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the iteration with id `iteration_id` doesn't exist. Returns: Dict[str, Any]: A dictionary that contains settings. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load settings. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject : project_settings : Dict [ str , Dict [ str , Any ]] = json . load ( settings_fileobject ) # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Get current iteration id if needed. if iteration_id is None : iteration_id = project_status [ \"iteration_id\" ] # Otherwise check that requested iteration id exist. if str ( iteration_id ) not in project_settings . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' has no iteration with id ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( iteration_id ), ), ) # Return the requested settings. return { # Get the project ID. \"project_id\" : project_id , # Get the iteration ID. \"iteration_id\" : iteration_id , # Get the request parameters. \"parameters\" : { \"settings_names\" : [ settings_name . value for settings_name in settings_names ], }, # Get the settings. \"settings\" : { setting_name : settings_value for setting_name , settings_value in project_settings [ str ( iteration_id )] . items () if setting_name in settings_names }, } get_status ( project_id = Path ( Ellipsis , description = 'The ID of the project.' )) async \u00b6 Get status. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains status. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 @app . get ( \"/api/projects/ {project_id} /status\" , tags = [ \"Status\" ], status_code = status . HTTP_200_OK , ) async def get_status ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get status. Args: project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. Returns: Dict[str, Any]: A dictionary that contains status. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) project_status [ \"state_details\" ] = get_ICGUIStates_details ( state = project_status [ \"state\" ]) # Return the requested status. return { \"project_id\" : project_id , \"status\" : project_status } get_texts ( project_id = Path ( Ellipsis , description = 'The ID of the project.' ), without_deleted_texts = Query ( True , description = 'The option to not return deleted texts. Defaults to `True`.' ), sorted_by = Query ( TextsSortOptions . ALPHABETICAL , description = 'The option to sort texts. Defaults to `ALPHABETICAL`.' ), sorted_reverse = Query ( False , description = 'The option to reverse texts order. Defaults to `False`.' )) async \u00b6 Get texts. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') without_deleted_texts bool The option to not return deleted texts. Defaults to True . Query(True, description='The option to not return deleted texts. Defaults to `True`.') sorted_by TextsSortOptions The option to sort texts. Defaults to ALPHABETICAL . Query(TextsSortOptions.ALPHABETICAL, description='The option to sort texts. Defaults to `ALPHABETICAL`.') sorted_reverse bool The option to reverse texts order. Defaults to False . Query(False, description='The option to reverse texts order. Defaults to `False`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains texts. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 @app . get ( \"/api/projects/ {project_id} /texts\" , tags = [ \"Texts\" ], status_code = status . HTTP_200_OK , ) async def get_texts ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), without_deleted_texts : bool = Query ( True , description = \"The option to not return deleted texts. Defaults to `True`.\" , ), sorted_by : TextsSortOptions = Query ( TextsSortOptions . ALPHABETICAL , description = \"The option to sort texts. Defaults to `ALPHABETICAL`.\" , ), sorted_reverse : bool = Query ( False , description = \"The option to reverse texts order. Defaults to `False`.\" , ), # TODO: filter_text # TODO: limit_size + offset ) -> Dict [ str , Any ]: \"\"\" Get texts. Args: project_id (str): The ID of the project. without_deleted_texts (bool): The option to not return deleted texts. Defaults to `True`. sorted_by (TextsSortOptions, optional): The option to sort texts. Defaults to `ALPHABETICAL`. sorted_reverse (bool, optional): The option to reverse texts order. Defaults to `False`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. Returns: Dict[str, Any]: A dictionary that contains texts. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) ### ### Load needed data. ### # Load texts. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"r\" ) as texts_fileobject : texts : Dict [ str , Any ] = { text_id : text_value for text_id , text_value in json . load ( texts_fileobject ) . items () if ( without_deleted_texts is False or text_value [ \"is_deleted\" ] is False ) } ### ### Sort texts. ### # Define the values selection method. def get_value_for_texts_sorting ( text_to_sort : Tuple [ str , Dict [ str , Any ]]) -> Any : # noqa: WPS430 (nested function) \"\"\"Return the values expected for texts sorting. Args: text_to_sort (Tuple[Dict[str, Any]]): A text (from `.items()`). Returns: Any: The expected values of the text need for the sort. \"\"\" # By text id. if sorted_by == TextsSortOptions . ID : return text_to_sort [ 0 ] # By text value. if sorted_by == TextsSortOptions . ALPHABETICAL : return text_to_sort [ 1 ][ \"text_preprocessed\" ] # By deletion status. #### if sorted_by == TextsSortOptions.IS_DELETED: return text_to_sort [ 1 ][ \"is_deleted\" ] # Sorted the texts to return. sorted_texts : Dict [ str , Any ] = { sorted_text_id : sorted_text for sorted_text_id , sorted_text in sorted ( texts . items (), key = get_value_for_texts_sorting , reverse = sorted_reverse , ) } # Return the requested texts. return { \"project_id\" : project_id , \"texts\" : sorted_texts , # Get the request parameters. \"parameters\" : { \"without_deleted_texts\" : without_deleted_texts , \"sorted_by\" : sorted_by . value , \"sorted_reverse\" : sorted_reverse , }, } get_vectors ( project_id = Path ( Ellipsis , description = 'The ID of the project.' )) async \u00b6 Get 2D and 3D vectors. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the iteration with id iteration_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the status of the project hasn't completed its clustering step. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains clustering result. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 @app . get ( \"/api/projects/ {project_id} /vectors\" , tags = [ \"Data modelization\" ], status_code = status . HTTP_200_OK , ) async def get_vectors ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get 2D and 3D vectors. Args: project_id (str, optional): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the iteration with id `iteration_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the status of the project hasn't completed its clustering step. Returns: Dict[str, Any]: A dictionary that contains clustering result. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Check project status. if ( project_status [ \"state\" ] != ICGUIStates . SAMPLING_TODO # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . SAMPLING_PENDING and project_status [ \"state\" ] != ICGUIStates . SAMPLING_WORKING and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . CLUSTERING_TODO and project_status [ \"state\" ] != ICGUIStates . CLUSTERING_PENDING and project_status [ \"state\" ] != ICGUIStates . CLUSTERING_WORKING and project_status [ \"state\" ] != ICGUIStates . ITERATION_END ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' hasn't completed its modelization update step.\" . format ( project_id_str = str ( project_id ), ), ) # Load the 2D vectors. with open ( DATA_DIRECTORY / project_id / \"vectors_2D.json\" , \"r\" ) as vectors_2D_fileobject : vectors_2D : Dict [ str , Dict [ str , float ]] = json . load ( vectors_2D_fileobject ) # noqa: S301 # Usage of Pickle # Load the 3D vectors. with open ( DATA_DIRECTORY / project_id / \"vectors_3D.json\" , \"r\" ) as vectors_3D_fileobject : vectors_3D : Dict [ str , Dict [ str , float ]] = json . load ( vectors_3D_fileobject ) # noqa: S301 # Usage of Pickle # Return the project vectors. return { \"project_id\" : project_id , \"vectors_2d\" : vectors_2D , \"vectors_3d\" : vectors_3D , } import_project ( background_tasks , project_archive = File ( Ellipsis , description = 'A zip archive representing a project. Use format from `download` route.' )) async \u00b6 Import a project from a zip archive file. Parameters: Name Type Description Default background_tasks BackgroundTasks A background task to run after the return statement. required project_archive UploadFile A zip archive representing a project. Use format from download route. File(Ellipsis, description='A zip archive representing a project. Use format from `download` route.') Raises: Type Description HTTPException Raises HTTP_400_NOT_FOUND if archive is invalid. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of the imported project. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 @app . put ( \"/api/projects\" , tags = [ \"Projects\" ], status_code = status . HTTP_201_CREATED , ) async def import_project ( background_tasks : BackgroundTasks , project_archive : UploadFile = File ( ... , description = \"A zip archive representing a project. Use format from `download` route.\" , # TODO: max_size=\"8MB\", ), ) -> Dict [ str , Any ]: \"\"\" Import a project from a zip archive file. Args: background_tasks (BackgroundTasks): A background task to run after the return statement. project_archive (UploadFile, optional): A zip archive representing a project. Use format from `download` route. Raises: HTTPException: Raises `HTTP_400_NOT_FOUND` if archive is invalid. Returns: Dict[str, Any]: A dictionary that contains the ID of the imported project. \"\"\" # Check archive type. if project_archive . content_type != \"application/x-zip-compressed\" : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = \"The file type ' {project_archive_type} ' is not supported. Please use '.zip' file.\" . format ( project_archive_type = str ( project_archive . content_type ), ), ) # Temporarly store zip archive. current_timestamp : float = datetime . now () . timestamp () new_current_project_id : str = str ( int ( current_timestamp * 10 ** 6 )) import_archive_name : str = \"import- {new_current_project_id_str} .zip\" . format ( new_current_project_id_str = str ( new_current_project_id ) ) import_archive_path : pathlib . Path = DATA_DIRECTORY / import_archive_name with open ( import_archive_path , \"wb\" ) as import_archive_fileobject_w : shutil . copyfileobj ( project_archive . file , import_archive_fileobject_w ) # Define a backgroundtask to clear archive after importation. def clear_after_import_project (): # noqa: WPS430 (nested function) \"\"\" Delete the archive file. \"\"\" # Delete archive file. if os . path . exists ( import_archive_path ): # pragma: no cover os . remove ( import_archive_path ) # Add the background task. background_tasks . add_task ( func = clear_after_import_project , ) # Try to open archive file. try : with zipfile . ZipFile ( import_archive_path , \"r\" ) as import_archive_file : ### ### Check archive content. ### missing_files : List [ str ] = [ needed_file for needed_file in ( \"metadata.json\" , \"status.json\" , \"texts.json\" , \"constraints.json\" , \"settings.json\" , \"sampling.json\" , \"clustering.json\" , \"modelization.json\" , # Will be recomputed during modelization step. # \"vectors_2D.json\", # Will be recomputed during modelization step. # \"vectors_3D.json\", # Will be recomputed during modelization step. ) if needed_file not in import_archive_file . namelist () ] if len ( missing_files ) != 0 : # noqa: WPS507 raise ValueError ( \"The project archive file doesn't contains the following files: {missing_files_str} .\" . format ( missing_files_str = str ( missing_files ), ) ) ### ### Check `metadata.json`. ### with import_archive_file . open ( \"metadata.json\" ) as metadata_fileobject_r : metadata : Dict [ str , Any ] = json . load ( metadata_fileobject_r ) metadata [ \"project_id\" ] = new_current_project_id if ( \"project_name\" not in metadata . keys () or not isinstance ( metadata [ \"project_name\" ], str ) or \"creation_timestamp\" not in metadata . keys () or not isinstance ( metadata [ \"creation_timestamp\" ], float ) ): raise ValueError ( \"The project archive file has an invalid `metadata.json` file.\" ) ### ### Check `status.json`. ### with import_archive_file . open ( \"status.json\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) # Check `status.state`. if \"state\" not in project_status . keys (): raise ValueError ( \"The project archive file has an invalid `status.json` file (see key `state`).\" ) # Force `status.state` - Case of initialization. if ( project_status [ \"state\" ] == ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . INITIALIZATION_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . INITIALIZATION_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . INITIALIZATION_WITH_ERRORS ): project_status [ \"state\" ] = ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION # Force `status.state` - Case of sampling. elif ( project_status [ \"state\" ] == ICGUIStates . SAMPLING_TODO # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . SAMPLING_PENDING or project_status [ \"state\" ] == ICGUIStates . SAMPLING_WORKING or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_ERRORS ): project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION # Force `status.state` - Case of annotation. elif ( project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS or project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS or project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS or project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS or project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS or project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_WORKING_MODELIZATION ): project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION # Force `status.state` - Case of clustering. elif ( project_status [ \"state\" ] == ICGUIStates . CLUSTERING_TODO # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . CLUSTERING_PENDING or project_status [ \"state\" ] == ICGUIStates . CLUSTERING_WORKING or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_ERRORS ): project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION # Force `status.state` - Case of iteration end. elif ( project_status [ \"state\" ] == ICGUIStates . ITERATION_END # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_ERRORS ): project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION # Force `state` - Case of unknown state. else : raise ValueError ( \"The project archive file has an invalid `status.json` file (see key `state`).\" ) # Force `status.task`. project_status [ \"task\" ] = None # TODO: Check `texts.json`. with import_archive_file . open ( \"texts.json\" ) as texts_fileobject_r : texts : Dict [ str , Dict [ str , Any ]] = json . load ( texts_fileobject_r ) # TODO: Check `constraints.json`. with import_archive_file . open ( \"constraints.json\" ) as constraints_fileobject_r : constraints : Dict [ str , Dict [ str , Any ]] = json . load ( constraints_fileobject_r ) # TODO: Check `settings.json`. with import_archive_file . open ( \"settings.json\" ) as settings_fileobject_r : settings : Dict [ str , Dict [ str , Any ]] = json . load ( settings_fileobject_r ) # TODO: Check `sampling.json`. with import_archive_file . open ( \"sampling.json\" ) as sampling_fileobject_r : sampling : Dict [ str , List [ str ]] = json . load ( sampling_fileobject_r ) # TODO: Check `clustering.json`. with import_archive_file . open ( \"clustering.json\" ) as clustering_fileobject_r : clustering : Dict [ str , Dict [ str , str ]] = json . load ( clustering_fileobject_r ) # TODO: Check `modelization.json`. with import_archive_file . open ( \"modelization.json\" ) as modelization_fileobject_r : modelization : Dict [ str , Dict [ str , Any ]] = json . load ( modelization_fileobject_r ) # Error: case of custom raised errors. except ValueError as value_error : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = str ( value_error ), ) # Error: other raised errors. except Exception : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = \"An error occurs in project import. Project archive is probably invalid.\" , ) # Create the directory and subdirectories of the new project. os . mkdir ( DATA_DIRECTORY / metadata [ \"project_id\" ]) # Store `metadata.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"metadata.json\" , \"w\" ) as metadata_fileobject_w : json . dump ( metadata , metadata_fileobject_w , indent = 4 ) # Store `status.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Store `texts.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"texts.json\" , \"w\" ) as texts_fileobject_w : json . dump ( texts , texts_fileobject_w , indent = 4 ) # Store `constraints.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) # Store `settings.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"settings.json\" , \"w\" ) as settings_fileobject_w : json . dump ( settings , settings_fileobject_w , indent = 4 ) # Store `sampling.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"sampling.json\" , \"w\" ) as sampling_fileobject_w : json . dump ( sampling , sampling_fileobject_w , indent = 4 ) # Store `clustering.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"clustering.json\" , \"w\" ) as clustering_fileobject_w : json . dump ( clustering , clustering_fileobject_w , indent = 4 ) # Store `modelization.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"modelization.json\" , \"w\" ) as modelization_fileobject_w : json . dump ( modelization , modelization_fileobject_w , indent = 4 ) # Return the new ID of the imported project. return { \"project_id\" : metadata [ \"project_id\" ], \"detail\" : \"The project with name ' {project_name_str} ' has been imported. It has the id ' {project_id_str} '.\" . format ( project_name_str = str ( metadata [ \"project_name\" ]), project_id_str = str ( metadata [ \"project_id\" ]), ), } move_to_next_iteration ( project_id = Path ( Ellipsis , description = 'The ID of the project.' )) async \u00b6 Move to next iteration after clustering step. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the project didn't complete its clustering step. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of the new iteration. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 @app . post ( \"/api/projects/ {project_id} /iterations\" , tags = [ \"Status\" ], status_code = status . HTTP_201_CREATED , ) async def move_to_next_iteration ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Move to next iteration after clustering step. Args: project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the project didn't complete its clustering step. Returns: Dict[str, Any]: A dictionary that contains the ID of the new iteration. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) # Load settings file. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject_r : project_settings : Dict [ str , Any ] = json . load ( settings_fileobject_r ) # Get current iteration id. current_iteration_id : int = project_status [ \"iteration_id\" ] ### ### Check parameters. ### # Check project status. if project_status [ \"state\" ] != ICGUIStates . ITERATION_END : raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' hasn't completed its clustering step on iteration ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( current_iteration_id ), ), ) ### ### Update data. ### # Define new iteration id. new_iteration_id : int = current_iteration_id + 1 # Initialize status for the new iteration. project_status [ \"iteration_id\" ] = new_iteration_id project_status [ \"state\" ] = ICGUIStates . SAMPLING_TODO # Initialize settings for the new iteration. project_settings [ str ( new_iteration_id )] = { \"sampling\" : ( default_SamplingSettingsModel () . to_dict () if ( current_iteration_id == 0 ) else project_settings [ str ( current_iteration_id )][ \"sampling\" ] ), \"preprocessing\" : project_settings [ str ( current_iteration_id )][ \"preprocessing\" ], \"vectorization\" : project_settings [ str ( current_iteration_id )][ \"vectorization\" ], \"clustering\" : project_settings [ str ( current_iteration_id )][ \"clustering\" ], } ### ### Store updated data. ### # Store project settings. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"w\" ) as settings_fileobject_w : json . dump ( project_settings , settings_fileobject_w , indent = 4 ) # Store project status. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Return the new iteration id. return { \"project_id\" : project_id , \"iteration_id\" : new_iteration_id , \"detail\" : \"The project with id ' {project_id_str} ' is now on iteration with id ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( new_iteration_id ), ), } prepare_constrained_clustering_task ( background_tasks , project_id = Path ( Ellipsis , description = 'The ID of the project.' )) async \u00b6 Prepare constrained clustering task. Parameters: Name Type Description Default background_tasks BackgroundTasks A background task to run after the return statement. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow the preparation of constrained clustering task. HTTPException Raises HTTP_504_GATEWAY_TIMEOUT if the task can't be prepared. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the confirmation of the preparation of constrained clustering task. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3623 3624 3625 3626 3627 3628 3629 3630 3631 3632 3633 3634 3635 3636 3637 3638 3639 3640 3641 3642 3643 3644 3645 3646 3647 3648 3649 3650 3651 3652 3653 3654 3655 3656 3657 3658 3659 3660 3661 3662 3663 3664 3665 3666 3667 3668 3669 3670 3671 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 3683 3684 3685 3686 3687 3688 3689 3690 3691 3692 3693 3694 3695 3696 3697 3698 3699 3700 3701 3702 3703 3704 3705 3706 3707 3708 3709 3710 3711 3712 3713 3714 3715 3716 3717 3718 3719 3720 3721 3722 @app . post ( \"/api/projects/ {project_id} /clustering\" , tags = [ \"Constrained clustering\" ], status_code = status . HTTP_202_ACCEPTED , ) async def prepare_constrained_clustering_task ( background_tasks : BackgroundTasks , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Prepare constrained clustering task. Args: background_tasks (BackgroundTasks): A background task to run after the return statement. project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow the preparation of constrained clustering task. HTTPException: Raises `HTTP_504_GATEWAY_TIMEOUT` if the task can't be prepared. Returns: Dict[str, Any]: A dictionary that contains the confirmation of the preparation of constrained clustering task. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) ### ### Check parameters. ### # Check status. if project_status [ \"state\" ] != ICGUIStates . CLUSTERING_TODO : raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow the preparation of constrained clustering task during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"pending\" status. project_status [ \"state\" ] = ICGUIStates . CLUSTERING_PENDING # Prepare status by initializing \"task\" status. project_status [ \"task\" ] = { \"progression\" : 1 , \"detail\" : \"Waiting for background task allocation...\" , } ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) ### ### Launch backgroundtask. ### # Add the background task. background_tasks . add_task ( func = backgroundtasks . run_constrained_clustering_task , project_id = project_id , ) # Return statement. return { # pragma: no cover (need radis and worder) \"project_id\" : project_id , \"detail\" : \"In project with id ' {project_id_str} ', the constrained clustering task has been requested and is waiting for a background task.\" . format ( project_id_str = str ( project_id ), ), } prepare_constraints_sampling_task ( background_tasks , project_id = Path ( Ellipsis , description = 'The ID of the project.' )) async \u00b6 Prepare constraints sampling task. Parameters: Name Type Description Default background_tasks BackgroundTasks A background task to run after the return statement. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow the preparation of constraints sampling task. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the confirmation of the preparation of constraints sampling task. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 @app . post ( \"/api/projects/ {project_id} /sampling\" , tags = [ \"Constraints sampling\" ], status_code = status . HTTP_202_ACCEPTED , ) async def prepare_constraints_sampling_task ( background_tasks : BackgroundTasks , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Prepare constraints sampling task. Args: background_tasks (BackgroundTasks): A background task to run after the return statement. project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow the preparation of constraints sampling task. Returns: Dict[str, Any]: A dictionary that contains the confirmation of the preparation of constraints sampling task. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Check status. if project_status [ \"state\" ] != ICGUIStates . SAMPLING_TODO : raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow the preparation of constraints sampling task during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"pending\" status. project_status [ \"state\" ] = ICGUIStates . SAMPLING_PENDING # Prepare status by initializing \"task\" status. project_status [ \"task\" ] = { \"progression\" : 1 , \"detail\" : \"Waiting for background task allocation...\" , } ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) ### ### Launch backgroundtask. ### # Add the background task. background_tasks . add_task ( func = backgroundtasks . run_constraints_sampling_task , project_id = project_id , ) # Return statement. return { # pragma: no cover (need radis and worder) \"project_id\" : project_id , \"detail\" : \"In project with id ' {project_id_str} ', the constraints sampling task has been requested and is waiting for a background task.\" . format ( project_id_str = str ( project_id ), ), } prepare_modelization_update_task ( background_tasks , project_id = Path ( Ellipsis , description = 'The ID of the project.' )) async \u00b6 Prepare modelization update task. Parameters: Name Type Description Default background_tasks BackgroundTasks A background task to run after the return statement. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow the preparation of modelization update task. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the confirmation of the preparation of modelization update task. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 @app . post ( \"/api/projects/ {project_id} /modelization\" , tags = [ \"Data modelization\" ], status_code = status . HTTP_202_ACCEPTED , ) async def prepare_modelization_update_task ( background_tasks : BackgroundTasks , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Prepare modelization update task. Args: background_tasks (BackgroundTasks): A background task to run after the return statement. project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow the preparation of modelization update task. Returns: Dict[str, Any]: A dictionary that contains the confirmation of the preparation of modelization update task. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) ### ### Check parameters. ### # Check status. if ( project_status [ \"state\" ] != ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow the preparation of modelization update task during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"pending\" status. if project_status [ \"state\" ] == ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . INITIALIZATION_WITH_PENDING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_PENDING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_PENDING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: else : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS # Prepare status by initializing \"task\" status. project_status [ \"task\" ] = { \"progression\" : 1 , \"detail\" : \"Waiting for background task allocation...\" , } ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) ### ### Launch backgroundtask. ### # Add the background task. background_tasks . add_task ( func = backgroundtasks . run_modelization_update_task , project_id = project_id , ) # Return statement. return { # pragma: no cover (need radis and worder) \"project_id\" : project_id , \"detail\" : \"In project with id ' {project_id_str} ', the modelization update task has been requested and is waiting for a background task.\" . format ( project_id_str = str ( project_id ), ), } prometheus_disk_usage () \u00b6 Define a metric of disk usage. Returns: Type Description Callable [[ metrics . Info ], None] Callable[[metrics.Info], None]: instrumentation. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def prometheus_disk_usage () -> Callable [[ metrics . Info ], None ]: \"\"\" Define a metric of disk usage. Returns: Callable[[metrics.Info], None]: instrumentation. \"\"\" gaugemetric = Gauge ( \"disk_usage\" , \"The disk usage in %\" , ) def instrumentation ( info : metrics . Info ) -> None : # noqa: WPS430 (nested function) total , used , _ = shutil . disk_usage ( DATA_DIRECTORY ) gaugemetric . set ( used * 100 / total ) return instrumentation ready () async \u00b6 Tell if the API is ready. Returns: Type Description Response An HTTP response with either 200 or 503 codes. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 @app . get ( \"/ready\" , tags = [ \"app state\" ], status_code = status . HTTP_200_OK , ) async def ready () -> Response : # pragma: no cover \"\"\" Tell if the API is ready. Returns: An HTTP response with either 200 or 503 codes. \"\"\" # Return 200_OK if ready. if app . state . ready : return Response ( status_code = status . HTTP_200_OK ) # Return 503_SERVICE_UNAVAILABLE otherwise. return Response ( status_code = status . HTTP_503_SERVICE_UNAVAILABLE ) rename_text ( project_id = Path ( Ellipsis , description = 'The ID of the project.' ), text_id = Path ( Ellipsis , description = 'The ID of the text.' ), text_value = Query ( Ellipsis , description = 'The new value of the text.' , min_length = 3 , max_length = 256 )) async \u00b6 Rename a text. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') text_id str The ID of the text. Path(Ellipsis, description='The ID of the text.') text_value str The new value of the text. Query(Ellipsis, description='The new value of the text.', min_length=3, max_length=256) Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the text with id text_id to rename doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow modification. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of renamed text. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 @app . put ( \"/api/projects/ {project_id} /texts/ {text_id} /rename\" , tags = [ \"Texts\" ], status_code = status . HTTP_202_ACCEPTED , ) async def rename_text ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), text_id : str = Path ( ... , description = \"The ID of the text.\" , ), text_value : str = Query ( ... , description = \"The new value of the text.\" , min_length = 3 , max_length = 256 , ), ) -> Dict [ str , Any ]: \"\"\" Rename a text. Args: project_id (str): The ID of the project. text_id (str): The ID of the text. text_value (str): The new value of the text. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the text with id `text_id` to rename doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow modification. Returns: Dict[str, Any]: A dictionary that contains the ID of renamed text. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Load texts file. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"r\" ) as texts_fileobject_r : texts : Dict [ str , Any ] = json . load ( texts_fileobject_r ) ### ### Check parameters. ### # Check text id. if text_id not in texts . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"In project with id ' {project_id_str} ', the text with id ' {text_id_str} ' to rename doesn't exist.\" . format ( project_id_str = str ( project_id ), text_id_str = str ( text_id ), ), ) # Check status. if ( project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow modification during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"outdated\" status. if project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS # Update texts by renaming the new text. texts [ text_id ][ \"text\" ] = text_value ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Store updated texts in file. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"w\" ) as texts_fileobject_w : json . dump ( texts , texts_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"text_id\" : text_id , \"text_value\" : text_value , \"detail\" : \"In project with id ' {project_id_str} ', the text with id ' {text_id_str} ' has been renamed.\" . format ( project_id_str = str ( project_id ), text_id_str = str ( text_id ), ), } review_constraint ( project_id = Path ( Ellipsis , description = 'The ID of the project.' ), constraint_id = Path ( Ellipsis , description = 'The ID of the constraint.' ), to_review = Query ( True , description = 'The choice to review or not the constraint. Defaults to `True`.' )) async \u00b6 Review a constraint. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') constraint_id str The ID of the constraint. Path(Ellipsis, description='The ID of the constraint.') to_review str The choice to review or not the constraint. Defaults to True . Query(True, description='The choice to review or not the constraint. Defaults to `True`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the constraint with id constraint_id to annotate doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of reviewed constraint. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 @app . put ( \"/api/projects/ {project_id} /constraints/ {constraint_id} /review\" , tags = [ \"Constraints\" ], status_code = status . HTTP_202_ACCEPTED , ) async def review_constraint ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), constraint_id : str = Path ( ... , description = \"The ID of the constraint.\" , ), to_review : bool = Query ( True , description = \"The choice to review or not the constraint. Defaults to `True`.\" , ), ) -> Dict [ str , Any ]: \"\"\" Review a constraint. Args: project_id (str): The ID of the project. constraint_id (str): The ID of the constraint. to_review (str): The choice to review or not the constraint. Defaults to `True`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the constraint with id `constraint_id` to annotate doesn't exist. Returns: Dict[str, Any]: A dictionary that contains the ID of reviewed constraint. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load constraints file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Any ] = json . load ( constraints_fileobject_r ) ### ### Check parameters. ### # Check constraint id. if constraint_id not in constraints . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"In project with id ' {project_id_str} ', the constraint with id ' {constraint_id_str} ' to annotate doesn't exist.\" . format ( project_id_str = str ( project_id ), constraint_id_str = str ( constraint_id ), ), ) ### ### Update data. ### # Update constraints by reviewing the constraint. constraints [ constraint_id ][ \"to_review\" ] = to_review ### ### Store updated data. ### # Store updated constraints in file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"constraint_id\" : constraint_id , \"detail\" : \"In project with id ' {project_id_str} ', the constraint with id ' {constraint_id_str} ' {review_conclusion} .\" . format ( project_id_str = str ( project_id ), constraint_id_str = str ( constraint_id ), review_conclusion = \"need a review\" if ( to_review ) else \"has been reviewed\" , ), } startup () async \u00b6 Startup event. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 227 228 229 230 231 232 233 234 235 236 237 @app . on_event ( \"startup\" ) async def startup () -> None : # pragma: no cover \"\"\"Startup event.\"\"\" # Initialize ready state. app . state . ready = False # Apply database connection, long loading, etc. # Update ready state when done. app . state . ready = True timestamp_to_date ( timestamp , timezone_str = 'Europe/Paris' ) \u00b6 From timestamp to date. Parameters: Name Type Description Default timestamp float The timstamp to convert. required timezone_str str The time zone. Defaults to \"Europe/Paris\" . 'Europe/Paris' Returns: Name Type Description str str The requested date. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 106 107 108 109 110 111 112 113 114 115 116 117 118 def timestamp_to_date ( timestamp : float , timezone_str : str = \"Europe/Paris\" ) -> str : \"\"\" From timestamp to date. Args: timestamp (float): The timstamp to convert. timezone_str (str, optional): The time zone. Defaults to `\"Europe/Paris\"`. Returns: str: The requested date. \"\"\" timezone = tz . gettz ( timezone_str ) return datetime . fromtimestamp ( timestamp , timezone ) . strftime ( \" %d /%m/%Y\" ) timestamp_to_hour ( timestamp , timezone_str = 'Europe/Paris' ) \u00b6 From timestamp to hours. Parameters: Name Type Description Default timestamp float The timstamp to convert. required timezone_str str The time zone. Defaults to \"Europe/Paris\" . 'Europe/Paris' Returns: Name Type Description str str The requested hour. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 125 126 127 128 129 130 131 132 133 134 135 136 137 def timestamp_to_hour ( timestamp : float , timezone_str : str = \"Europe/Paris\" ) -> str : \"\"\" From timestamp to hours. Args: timestamp (float): The timstamp to convert. timezone_str (str, optional): The time zone. Defaults to `\"Europe/Paris\"`. Returns: str: The requested hour. \"\"\" timezone = tz . gettz ( timezone_str ) return datetime . fromtimestamp ( timestamp , timezone ) . strftime ( \"%H:%M:%S\" ) undelete_text ( project_id = Path ( Ellipsis , description = 'The ID of the project.' ), text_id = Path ( Ellipsis , description = 'The ID of the text.' )) async \u00b6 Undelete a text. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') text_id str The ID of the text. Path(Ellipsis, description='The ID of the text.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the text with id text_id to undelete doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow modification. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of undeleted text. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 @app . put ( \"/api/projects/ {project_id} /texts/ {text_id} /undelete\" , tags = [ \"Texts\" ], status_code = status . HTTP_202_ACCEPTED , ) async def undelete_text ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), text_id : str = Path ( ... , description = \"The ID of the text.\" , ), ) -> Dict [ str , Any ]: \"\"\" Undelete a text. Args: project_id (str): The ID of the project. text_id (str): The ID of the text. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the text with id `text_id` to undelete doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow modification. Returns: Dict[str, Any]: A dictionary that contains the ID of undeleted text. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Load texts file. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"r\" ) as texts_fileobject_r : texts : Dict [ str , Any ] = json . load ( texts_fileobject_r ) # Load constraints file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Any ] = json . load ( constraints_fileobject_r ) ### ### Check parameters. ### # Check text id. if text_id not in texts . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"In project with id ' {project_id_str} ', the text with id ' {text_id_str} ' to undelete doesn't exist.\" . format ( project_id_str = str ( project_id ), text_id_str = str ( text_id ), ), ) # Check status. if ( project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow modification during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"outdated\" status. if project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS # Update texts by undeleting the text. texts [ text_id ][ \"is_deleted\" ] = False # Update constraints by unhidding those associated with the undeleted text. for constraint_id , constraint_value in constraints . items (): data_id1 : str = constraint_value [ \"data\" ][ \"id_1\" ] data_id2 : str = constraint_value [ \"data\" ][ \"id_2\" ] if text_id in { data_id1 , data_id2 }: constraints [ constraint_id ][ \"is_hidden\" ] = ( texts [ data_id1 ][ \"is_deleted\" ] is True or texts [ data_id2 ][ \"is_deleted\" ] is True ) ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Store updated texts in file. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"w\" ) as texts_fileobject_w : json . dump ( texts , texts_fileobject_w , indent = 4 ) # Store updated constraints in file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"text_id\" : text_id , \"detail\" : \"In project with id ' {project_id_str} ', the text with id ' {text_id_str} ' has been undeleted. Several constraints have been unhidden.\" . format ( project_id_str = str ( project_id ), text_id_str = str ( text_id ), ), } update_settings ( project_id = Path ( Ellipsis , description = 'The ID of the project.' ), preprocessing = Body ( None , description = 'The settings for data preprocessing. Used during `modelization_update` task. Keep unchanged if empty.' ), vectorization = Body ( None , description = 'The settings for data vectorization. Used during `modelization_update` task. Keep unchanged if empty.' ), sampling = Body ( None , description = 'The settings for constraints sampling. Used during `constraints_sampling` task. Keep unchanged if empty.' ), clustering = Body ( None , description = 'The settings for constrained clustering. Used during `constrained_clustering` task. Keep unchanged if empty.' )) async \u00b6 Update settings. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') preprocessing Optional [ PreprocessingSettingsModel ] The settings for data preprocessing. Used during clustering step. Keep unchanged if empty.. Defaults to None. Body(None, description='The settings for data preprocessing. Used during `modelization_update` task. Keep unchanged if empty.') vectorization Optional [ VectorizationSettingsModel ] The settings for data vectorization. Used during clustering step. Keep unchanged if empty.. Defaults to None. Body(None, description='The settings for data vectorization. Used during `modelization_update` task. Keep unchanged if empty.') sampling Optional [ SamplingSettingsModel ] The settings for constraints sampling. Used during sampling step. Keep unchanged if empty.. Defaults to None. Body(None, description='The settings for constraints sampling. Used during `constraints_sampling` task. Keep unchanged if empty.') clustering Optional [ ClusteringSettingsModel ] The settings for constrained clustering. Used during clustering step. Keep unchanged if empty. Defaults to None. Body(None, description='The settings for constrained clustering. Used during `constrained_clustering` task. Keep unchanged if empty.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the status of the project doesn't allow settings modifications. HTTPException Raises HTTP_403_FORBIDDEN if parameters preprocessing , vectorization , sampling or clustering are not expected. HTTPException Raises HTTP_400_BAD_REQUEST if parameters preprocessing , vectorization , sampling or clustering are invalid. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of updated settings. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 @app . put ( \"/api/projects/ {project_id} /settings\" , tags = [ \"Settings\" ], status_code = status . HTTP_201_CREATED , ) async def update_settings ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), preprocessing : Optional [ PreprocessingSettingsModel ] = Body ( None , description = \"The settings for data preprocessing. Used during `modelization_update` task. Keep unchanged if empty.\" , ), vectorization : Optional [ VectorizationSettingsModel ] = Body ( None , description = \"The settings for data vectorization. Used during `modelization_update` task. Keep unchanged if empty.\" , ), sampling : Optional [ SamplingSettingsModel ] = Body ( None , description = \"The settings for constraints sampling. Used during `constraints_sampling` task. Keep unchanged if empty.\" , ), clustering : Optional [ ClusteringSettingsModel ] = Body ( None , description = \"The settings for constrained clustering. Used during `constrained_clustering` task. Keep unchanged if empty.\" , ), ) -> Dict [ str , Any ]: \"\"\" Update settings. Args: project_id (str): The ID of the project. preprocessing (Optional[PreprocessingSettingsModel], optional): The settings for data preprocessing. Used during `clustering` step. Keep unchanged if empty.. Defaults to None. vectorization (Optional[VectorizationSettingsModel], optional): The settings for data vectorization. Used during `clustering` step. Keep unchanged if empty.. Defaults to None. sampling (Optional[SamplingSettingsModel], optional): The settings for constraints sampling. Used during `sampling` step. Keep unchanged if empty.. Defaults to None. clustering (Optional[ClusteringSettingsModel], optional): The settings for constrained clustering. Used during `clustering` step. Keep unchanged if empty. Defaults to None. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the status of the project doesn't allow settings modifications. HTTPException: Raises `HTTP_403_FORBIDDEN` if parameters `preprocessing`, `vectorization`, `sampling` or `clustering` are not expected. HTTPException: Raises `HTTP_400_BAD_REQUEST` if parameters `preprocessing`, `vectorization`, `sampling` or `clustering` are invalid. Returns: Dict[str, Any]: A dictionary that contains the ID of updated settings. \"\"\" # TODO: examples: https://fastapi.tiangolo.com/tutorial/schema-extra-example/#body-with-multiple-examples # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) iteration_id : int = project_status [ \"iteration_id\" ] # Load settings file. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject_r : project_settings : Dict [ str , Any ] = json . load ( settings_fileobject_r ) list_of_updated_settings : List [ ICGUISettings ] = [] ### ### Case of preprocessing settings. ### if preprocessing is not None : list_of_updated_settings . append ( ICGUISettings . PREPROCESSING ) # Check project status for preprocessing. if ( project_status [ \"state\" ] != ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The 'preprocessing' settings of project with id ' {project_id_str} ' cant't be modified during this state (state=' {state_str} '). No changes have been taken into account.\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) # Update status by forcing \"outdated\" status. if project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.INITIALIZATION_WITHOUT_MODELIZATION: #### project_status[\"state\"] = ICGUIStates.INITIALIZATION_WITHOUT_MODELIZATION # Update the default settings with the parameters in the request body. for key_prep , value_prep in preprocessing . to_dict () . items (): project_settings [ str ( iteration_id )][ \"preprocessing\" ][ key_prep ] = value_prep ### ### Case of vectorization settings. ### if vectorization is not None : list_of_updated_settings . append ( ICGUISettings . VECTORIZATION ) # Check project status for vectorization. if ( project_status [ \"state\" ] != ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The 'vectorization' settings of project with id ' {project_id_str} ' cant't be modified during this state (state=' {state_str} '). No changes have been taken into account.\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) # Update status by forcing \"outdated\" status. if project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.INITIALIZATION_WITHOUT_MODELIZATION: #### project_status[\"state\"] = ICGUIStates.INITIALIZATION_WITHOUT_MODELIZATION # Update the default settings with the parameters in the request body. for key_vect , value_vect in vectorization . to_dict () . items (): project_settings [ str ( iteration_id )][ \"vectorization\" ][ key_vect ] = value_vect ### ### Case of sampling settings. ### if sampling is not None : list_of_updated_settings . append ( ICGUISettings . SAMPLING ) # Check project status for sampling. if project_status [ \"state\" ] != ICGUIStates . SAMPLING_TODO : raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The 'sampling' settings of project with id ' {project_id_str} ' cant't be modified during this state (state=' {state_str} '). No changes have been taken into account.\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) # Update the default settings with the parameters in the request body. for key_sampl , value_sampl in sampling . to_dict () . items (): project_settings [ str ( iteration_id )][ \"sampling\" ][ key_sampl ] = value_sampl ### ### Case of clustering settings. ### if clustering is not None : list_of_updated_settings . append ( ICGUISettings . CLUSTERING ) # Check project status for clustering. if ( project_status [ \"state\" ] != ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . INITIALIZATION_WITH_PENDING_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . INITIALIZATION_WITH_WORKING_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . SAMPLING_TODO and project_status [ \"state\" ] != ICGUIStates . SAMPLING_PENDING and project_status [ \"state\" ] != ICGUIStates . SAMPLING_WORKING and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . CLUSTERING_TODO ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The 'clustering' settings of project with id ' {project_id_str} ' cant't be modified during this state (state=' {state_str} '). No changes have been taken into account.\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) # Update the default settings with the parameters in the request body. for key_clus , value_clus in clustering . to_dict () . items (): project_settings [ str ( iteration_id )][ \"clustering\" ][ key_clus ] = value_clus ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Store updated settings in file. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"w\" ) as settings_fileobject_w : json . dump ( project_settings , settings_fileobject_w , indent = 4 ) ### ### Return statement. ### return { \"project_id\" : project_id , \"detail\" : \"The project with id ' {project_id_str} ' has updated the following settings: {settings_str} .\" . format ( project_id_str = str ( project_id ), settings_str = \", \" . join ( list_of_updated_settings ), ), }","title":"app"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.alive","text":"Tell if the API is alive/healthy. Returns: Name Type Description Response Response An HTTP response with either 200 or 503 codes. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 @app . get ( \"/alive\" , tags = [ \"app state\" ], status_code = status . HTTP_200_OK , ) async def alive () -> Response : # pragma: no cover \"\"\" Tell if the API is alive/healthy. Returns: Response: An HTTP response with either 200 or 503 codes. \"\"\" try : # Assert the volume can be reached. pathlib . Path ( DATA_DIRECTORY / \".available\" ) . touch () # Or anything else asserting the API is healthy. except OSError : return Response ( status_code = status . HTTP_503_SERVICE_UNAVAILABLE ) return Response ( status_code = status . HTTP_200_OK )","title":"alive()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.annotate_constraint","text":"Annotate a constraint. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') constraint_id str The ID of the constraint. Path(Ellipsis, description='The ID of the constraint.') constraint_type Optional [ ConstraintsValues ] The type of constraint to annotate. Defaults to None . Query(None, description='The type of constraint to annotate. Defaults to `None`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the constraint with id constraint_id to annotate doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow modification. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of annotated constraint. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 @app . put ( \"/api/projects/ {project_id} /constraints/ {constraint_id} /annotate\" , tags = [ \"Constraints\" ], status_code = status . HTTP_202_ACCEPTED , ) async def annotate_constraint ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), constraint_id : str = Path ( ... , description = \"The ID of the constraint.\" , ), constraint_type : Optional [ ConstraintsValues ] = Query ( None , description = \"The type of constraint to annotate. Defaults to `None`.\" , ), ) -> Dict [ str , Any ]: \"\"\" Annotate a constraint. Args: project_id (str): The ID of the project. constraint_id (str): The ID of the constraint. constraint_type (Optional[ConstraintsValues]): The type of constraint to annotate. Defaults to `None`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the constraint with id `constraint_id` to annotate doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow modification. Returns: Dict[str, Any]: A dictionary that contains the ID of annotated constraint. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Load constraints file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Any ] = json . load ( constraints_fileobject_r ) ### ### Check parameters. ### # Check constraint id. if constraint_id not in constraints . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"In project with id ' {project_id_str} ', the constraint with id ' {constraint_id_str} ' to annotate doesn't exist.\" . format ( project_id_str = str ( project_id ), constraint_id_str = str ( constraint_id ), ), ) # Check status. if ( project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow modification during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"outdated\" status. if project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS # Update constraints by updating the constraint history. constraints [ constraint_id ][ \"constraint_type_previous\" ] . append ( constraints [ constraint_id ][ \"constraint_type\" ]) # Update constraints by annotating the constraint. constraints [ constraint_id ][ \"constraint_type\" ] = constraint_type constraints [ constraint_id ][ \"date_of_update\" ] = datetime . now () . timestamp () # Force annotation status. constraints [ constraint_id ][ \"to_annotate\" ] = False ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Store updated constraints in file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"constraint_id\" : constraint_id , \"detail\" : \"In project with id ' {project_id_str} ', the constraint with id ' {constraint_id_str} ' has been annotated at ` {constraint_type_str} `.\" . format ( project_id_str = str ( project_id ), constraint_id_str = str ( constraint_id ), constraint_type_str = \"None\" if ( constraint_type is None ) else str ( constraint_type . value ), ), }","title":"annotate_constraint()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.approve_all_constraints","text":"Approve all constraints. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow constraints approbation. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the confirmation of constraints approbation. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 @app . post ( \"/api/projects/ {project_id} /constraints/approve\" , tags = [ \"Constraints\" ], status_code = status . HTTP_201_CREATED , ) async def approve_all_constraints ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Approve all constraints. Args: project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow constraints approbation. Returns: Dict[str, Any]: A dictionary that contains the confirmation of constraints approbation. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Check status. if project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow constraints approbation during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status to clustering step. project_status [ \"state\" ] = ICGUIStates . CLUSTERING_TODO ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"detail\" : \"In project with id ' {project_id_str} ', the constraints have been approved.\" . format ( project_id_str = str ( project_id ), ), }","title":"approve_all_constraints()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.comment_constraint","text":"Comment a constraint. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') constraint_id str The ID of the constraint. Path(Ellipsis, description='The ID of the constraint.') constraint_comment str The comment of constraint. Query(Ellipsis, description='The comment of constraint.', max_length=256) Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the constraint with id constraint_id to annotate doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of commented constraint. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 @app . put ( \"/api/projects/ {project_id} /constraints/ {constraint_id} /comment\" , tags = [ \"Constraints\" ], status_code = status . HTTP_202_ACCEPTED , ) async def comment_constraint ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), constraint_id : str = Path ( ... , description = \"The ID of the constraint.\" , ), constraint_comment : str = Query ( ... , description = \"The comment of constraint.\" , # min_length=0, max_length = 256 , ), ) -> Dict [ str , Any ]: \"\"\" Comment a constraint. Args: project_id (str): The ID of the project. constraint_id (str): The ID of the constraint. constraint_comment (str): The comment of constraint. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the constraint with id `constraint_id` to annotate doesn't exist. Returns: Dict[str, Any]: A dictionary that contains the ID of commented constraint. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load constraints file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Any ] = json . load ( constraints_fileobject_r ) ### ### Check parameters. ### # Check constraint id. if constraint_id not in constraints . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"In project with id ' {project_id_str} ', the constraint with id ' {constraint_id_str} ' to annotate doesn't exist.\" . format ( project_id_str = str ( project_id ), constraint_id_str = str ( constraint_id ), ), ) ### ### Update data. ### # Update constraints by commenting the constraint. constraints [ constraint_id ][ \"comment\" ] = constraint_comment ### ### Store updated data. ### # Store updated constraints in file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"constraint_id\" : constraint_id , \"constraint_comment\" : constraint_comment , \"detail\" : \"In project with id ' {project_id_str} ', the constraint with id ' {constraint_id_str} ' has been commented.\" . format ( project_id_str = str ( project_id ), constraint_id_str = str ( constraint_id ), ), }","title":"comment_constraint()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.create_project","text":"Create a project. Parameters: Name Type Description Default project_name str The name of the project. Should not be an empty string. Query(Ellipsis, description='The name of the project. Should not be an empty string.', min_length=3, max_length=64) dataset_file UploadFile The dataset file to load. Use a .csv ( ; separator) or .xlsx file. Please use a list of texts in the first column, without header, with encoding 'utf-8'. File(Ellipsis, description=\"The dataset file to load. Use a `.csv` (`;` separator) or `.xlsx` file. Please use a list of texts in the first column, without header, with encoding 'utf-8'.\") Raises: Type Description HTTPException Raises HTTP_400_BAD_REQUEST if parameters project_name or dataset_file are invalid. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of the created project. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 @app . post ( \"/api/projects\" , tags = [ \"Projects\" ], status_code = status . HTTP_201_CREATED , ) async def create_project ( project_name : str = Query ( ... , description = \"The name of the project. Should not be an empty string.\" , min_length = 3 , max_length = 64 , ), dataset_file : UploadFile = File ( ... , description = \"The dataset file to load. Use a `.csv` (`;` separator) or `.xlsx` file. Please use a list of texts in the first column, without header, with encoding 'utf-8'.\" , # TODO: max_size=\"8MB\", ), ) -> Dict [ str , Any ]: \"\"\" Create a project. Args: project_name (str): The name of the project. Should not be an empty string. dataset_file (UploadFile): The dataset file to load. Use a `.csv` (`;` separator) or `.xlsx` file. Please use a list of texts in the first column, without header, with encoding 'utf-8'. Raises: HTTPException: Raises `HTTP_400_BAD_REQUEST` if parameters `project_name` or `dataset_file` are invalid. Returns: Dict[str, Any]: A dictionary that contains the ID of the created project. \"\"\" # Define the new project ID. current_timestamp : float = datetime . now () . timestamp () current_project_id : str = str ( int ( current_timestamp * 10 ** 6 )) # Check project name. if project_name . strip () == \"\" : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = \"The project name ' {project_name_str} ' is invalid.\" . format ( project_name_str = str ( project_name ), ), ) # Initialize variable to store loaded dataset. list_of_texts : List [ str ] = [] # Load dataset: Case of `.csv` with `;` separator. if dataset_file . content_type in { \"text/csv\" , \"application/vnd.ms-excel\" }: # \"text/csv\" == \".csv\" # \"application/vnd.ms-excel\" == \".xls\" try : # noqa: WPS229 # Found too long `try` body length dataset_csv : pd . Dataframe = pd . read_csv ( filepath_or_buffer = dataset_file . file , sep = \";\" , header = None , # No header expected in the csv file. ) list_of_texts = dataset_csv [ dataset_csv . columns [ 0 ]] . tolist () except Exception : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = \"The dataset file is invalid. `.csv` file, with `;` separator, must contain a list of texts in the first column, with no header.\" , ) # Load dataset: Case of `.xlsx`. elif dataset_file . content_type == \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" : # \"application/vnd.ms-excel\" == \".xlsx\" try : # noqa: WPS229 # Found too long `try` body length dataset_xlsx : pd . Dataframe = pd . read_excel ( io = dataset_file . file . read (), engine = \"openpyxl\" , header = None , # No header expected in the xlsx file. ) list_of_texts = dataset_xlsx [ dataset_xlsx . columns [ 0 ]] . tolist () except Exception : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = \"The dataset file is invalid. `.xlsx` file must contain a list of texts in the first column, with no header.\" , ) # Load dataset: case of not supported type. else : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = \"The file type ' {dataset_file_type} ' is not supported. Please use '.csv' (`;` separator) or '.xlsx' file.\" . format ( dataset_file_type = str ( dataset_file . content_type ), ), ) # Create the directory and subdirectories of the new project. os . mkdir ( DATA_DIRECTORY / current_project_id ) # Initialize storage of metadata. with open ( DATA_DIRECTORY / current_project_id / \"metadata.json\" , \"w\" ) as metadata_fileobject : json . dump ( { \"project_id\" : current_project_id , \"project_name\" : str ( project_name . strip ()), \"creation_timestamp\" : current_timestamp , }, metadata_fileobject , indent = 4 , ) # Initialize storage of status. with open ( DATA_DIRECTORY / current_project_id / \"status.json\" , \"w\" ) as status_fileobject : json . dump ( { \"iteration_id\" : 0 , # Use string format for JSON serialization in dictionaries. \"state\" : ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION , \"task\" : None , # \"progression\", \"detail\". }, status_fileobject , indent = 4 , ) # Initialize storage of texts. with open ( DATA_DIRECTORY / current_project_id / \"texts.json\" , \"w\" ) as texts_fileobject : json . dump ( { str ( i ): { \"text_original\" : str ( text ), # Will never be changed. \"text\" : str ( text ), # Can be change by renaming. \"text_preprocessed\" : str ( text ), # Will be preprocessed during `Modelizationpdate` task. \"is_deleted\" : False , } for i , text in enumerate ( list_of_texts ) }, texts_fileobject , indent = 4 , ) # Initialize storage of constraints. with open ( DATA_DIRECTORY / current_project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject : json . dump ( {}, # Dict[str, Any] constraints_fileobject , indent = 4 , ) # Initialize storage of modelization inference assignations. with open ( DATA_DIRECTORY / current_project_id / \"modelization.json\" , \"w\" ) as modelization_fileobject : json . dump ( { str ( i ): { \"MUST_LINK\" : [ str ( i )], \"CANNOT_LINK\" : [], \"COMPONENT\" : i } for i in range ( len ( list_of_texts ))}, modelization_fileobject , indent = 4 , ) # Initialize settings storage. with open ( DATA_DIRECTORY / current_project_id / \"settings.json\" , \"w\" ) as settings_fileobject : json . dump ( { \"0\" : { \"preprocessing\" : default_PreprocessingSettingsModel () . to_dict (), \"vectorization\" : default_VectorizationSettingsModel () . to_dict (), \"clustering\" : default_ClusteringSettingsModel () . to_dict (), }, }, settings_fileobject , indent = 4 , ) # Initialize storage of sampling results. with open ( DATA_DIRECTORY / current_project_id / \"sampling.json\" , \"w\" ) as sampling_fileobject : json . dump ({}, sampling_fileobject , indent = 4 ) # Dict[str, List[str]] # Initialize storage of clustering results. with open ( DATA_DIRECTORY / current_project_id / \"clustering.json\" , \"w\" ) as clustering_fileobject : json . dump ({}, clustering_fileobject , indent = 4 ) # Dict[str, Dict[str, str]] # Return the ID of the created project. return { \"project_id\" : current_project_id , \"detail\" : \"The project with name ' {project_name_str} ' has been created. It has the id ' {project_id_str} '.\" . format ( project_name_str = str ( project_name ), project_id_str = str ( current_project_id ), ), }","title":"create_project()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.delete_project","text":"Delete a project. Parameters: Name Type Description Default project_id str The ID of the project to delete. Path(Ellipsis, description='The ID of the project to delete.') Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of the deleted project. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 @app . delete ( \"/api/projects/ {project_id} \" , tags = [ \"Projects\" ], status_code = status . HTTP_202_ACCEPTED , ) async def delete_project ( project_id : str = Path ( ... , description = \"The ID of the project to delete.\" , ), ) -> Dict [ str , Any ]: \"\"\" Delete a project. Args: project_id (str): The ID of the project to delete. Returns: Dict[str, Any]: A dictionary that contains the ID of the deleted project. \"\"\" # Delete the project. if os . path . isdir ( DATA_DIRECTORY / project_id ): shutil . rmtree ( DATA_DIRECTORY / project_id , ignore_errors = True ) # Return the deleted project id. return { \"project_id\" : project_id , \"detail\" : \"The deletion of project with id ' {project_id_str} ' is accepted.\" . format ( project_id_str = str ( project_id ), ), }","title":"delete_project()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.delete_text","text":"Delete a text. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') text_id str The ID of the text. Path(Ellipsis, description='The ID of the text.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the text with id text_id to delete doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow modification. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of deleted text. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 @app . put ( \"/api/projects/ {project_id} /texts/ {text_id} /delete\" , tags = [ \"Texts\" ], status_code = status . HTTP_202_ACCEPTED , ) async def delete_text ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), text_id : str = Path ( ... , description = \"The ID of the text.\" , ), ) -> Dict [ str , Any ]: \"\"\" Delete a text. Args: project_id (str): The ID of the project. text_id (str): The ID of the text. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the text with id `text_id` to delete doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow modification. Returns: Dict[str, Any]: A dictionary that contains the ID of deleted text. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Load texts file. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"r\" ) as texts_fileobject_r : texts : Dict [ str , Any ] = json . load ( texts_fileobject_r ) # Load constraints file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Any ] = json . load ( constraints_fileobject_r ) ### ### Check parameters. ### # Check text id. if text_id not in texts . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"In project with id ' {project_id_str} ', the text with id ' {text_id_str} ' to delete doesn't exist.\" . format ( project_id_str = str ( project_id ), text_id_str = str ( text_id ), ), ) # Check status. if ( project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow modification during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"outdated\" status. if project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS # Update texts by deleting the text. texts [ text_id ][ \"is_deleted\" ] = True # Update constraints by hidding those associated with the deleted text. for constraint_id , constraint_value in constraints . items (): data_id1 : str = constraint_value [ \"data\" ][ \"id_1\" ] data_id2 : str = constraint_value [ \"data\" ][ \"id_2\" ] if text_id in { data_id1 , data_id2 , }: constraints [ constraint_id ][ \"is_hidden\" ] = True ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Store updated texts in file. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"w\" ) as texts_fileobject_w : json . dump ( texts , texts_fileobject_w , indent = 4 ) # Store updated constraints in file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"text_id\" : text_id , \"detail\" : \"In project with id ' {project_id_str} ', the text with id ' {text_id_str} ' has been deleted. Several constraints have been hidden.\" . format ( project_id_str = str ( project_id ), text_id_str = str ( text_id ), ), }","title":"delete_text()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.download_project","text":"Download a project in a zip archive. Parameters: Name Type Description Default background_tasks BackgroundTasks A background task to run after the return statement. required project_id str The ID of the project to download. Path(Ellipsis, description='The ID of the project to download.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. Returns: Name Type Description FileResponse FileResponse A zip archive of the project. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 @app . get ( \"/api/projects/ {project_id} /download\" , tags = [ \"Projects\" ], response_class = FileResponse , status_code = status . HTTP_200_OK , ) async def download_project ( background_tasks : BackgroundTasks , project_id : str = Path ( ... , description = \"The ID of the project to download.\" , ), ) -> FileResponse : \"\"\" Download a project in a zip archive. Args: background_tasks (BackgroundTasks): A background task to run after the return statement. project_id (str): The ID of the project to download. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. Returns: FileResponse: A zip archive of the project. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Define archive name. archive_name : str = \"archive- {project_id_str} .zip\" . format ( project_id_str = str ( project_id )) archive_path : pathlib . Path = DATA_DIRECTORY / project_id / archive_name # Zip the project in an archive. with zipfile . ZipFile ( archive_path , \"w\" , zipfile . ZIP_DEFLATED ) as archive_filewriter : archive_filewriter . write ( DATA_DIRECTORY / project_id / \"metadata.json\" , arcname = \"metadata.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"status.json\" , arcname = \"status.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"texts.json\" , arcname = \"texts.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"constraints.json\" , arcname = \"constraints.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"settings.json\" , arcname = \"settings.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"sampling.json\" , arcname = \"sampling.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"clustering.json\" , arcname = \"clustering.json\" ) archive_filewriter . write ( DATA_DIRECTORY / project_id / \"modelization.json\" , arcname = \"modelization.json\" ) if \"vectors_2D.json\" in os . listdir ( DATA_DIRECTORY / project_id ): archive_filewriter . write ( DATA_DIRECTORY / project_id / \"vectors_2D.json\" , arcname = \"vectors_2D.json\" ) if \"vectors_3D.json\" in os . listdir ( DATA_DIRECTORY / project_id ): archive_filewriter . write ( DATA_DIRECTORY / project_id / \"vectors_3D.json\" , arcname = \"vectors_3D.json\" ) # Define a backgroundtask to clear archive after downloading. def clear_after_download_project (): # noqa: WPS430 (nested function) \"\"\" Delete the archive file. \"\"\" # Delete archive file. if os . path . exists ( archive_path ): # pragma: no cover os . remove ( archive_path ) # Add the background task. background_tasks . add_task ( func = clear_after_download_project , ) # Return the zip archive of the project. return FileResponse ( archive_path , media_type = \"application/x-zip-compressed\" , filename = archive_name , )","title":"download_project()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_constrained_clustering_results","text":"Get constrained clustering results. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') iteration_id Optional [ int ] The ID of project iteration. If None , get the current iteration. Defaults to None . Query(None, description='The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the iteration with id iteration_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the status of the project hasn't completed its clustering step. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains clustering result. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3523 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 3574 3575 3576 3577 3578 3579 3580 3581 3582 3583 3584 3585 3586 3587 3588 3589 3590 3591 3592 3593 3594 3595 3596 3597 3598 3599 3600 3601 3602 3603 3604 3605 3606 3607 3608 3609 3610 3611 3612 3613 3614 3615 3616 3617 @app . get ( \"/api/projects/ {project_id} /clustering\" , tags = [ \"Constrained clustering\" ], status_code = status . HTTP_200_OK , ) async def get_constrained_clustering_results ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), iteration_id : Optional [ int ] = Query ( None , description = \"The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get constrained clustering results. Args: project_id (str, optional): The ID of the project. iteration_id (Optional[int], optional): The ID of project iteration. If `None`, get the current iteration. Defaults to `None`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the iteration with id `iteration_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the status of the project hasn't completed its clustering step. Returns: Dict[str, Any]: A dictionary that contains clustering result. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Load clustering. with open ( DATA_DIRECTORY / project_id / \"clustering.json\" , \"r\" ) as clustering_fileobject : project_clustering : Dict [ str , Dict [ str , Any ]] = json . load ( clustering_fileobject ) # Set iteration id if needed. if iteration_id is None : if ( project_status [ \"iteration_id\" ] == 0 or project_status [ \"state\" ] == ICGUIStates . ITERATION_END or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_ERRORS ): iteration_id = project_status [ \"iteration_id\" ] else : iteration_id = project_status [ \"iteration_id\" ] - 1 # Check project status. if ( iteration_id == project_status [ \"iteration_id\" ] and project_status [ \"state\" ] != ICGUIStates . ITERATION_END and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_ITERATION_END_WITH_ERRORS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' hasn't completed its clustering step on iteration ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( iteration_id ), ), ) # Otherwise check that requested iteration id exist. if str ( iteration_id ) not in project_clustering . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' has no iteration with id ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( iteration_id ), ), ) # Return the project clustering. return { \"project_id\" : project_id , \"iteration_id\" : iteration_id , \"clustering\" : project_clustering [ str ( iteration_id )], }","title":"get_constrained_clustering_results()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_constraints","text":"Get constraints. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') without_hidden_constraints bool The option to not return hidden constraints. Defaults to True . Query(True, description='The option to not return hidden constraints. Defaults to `True`.') sorted_by ConstraintsSortOptions The option to sort constraints. Defaults to ID . Query(ConstraintsSortOptions.ID, description='The option to sort constraints. Defaults to `ID`.') sorted_reverse bool The option to reverse constraints order. Defaults to False . Query(False, description='The option to reverse constraints order. Defaults to `False`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains constraints. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 @app . get ( \"/api/projects/ {project_id} /constraints\" , tags = [ \"Constraints\" ], status_code = status . HTTP_200_OK , ) async def get_constraints ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), without_hidden_constraints : bool = Query ( True , description = \"The option to not return hidden constraints. Defaults to `True`.\" , ), sorted_by : ConstraintsSortOptions = Query ( ConstraintsSortOptions . ID , description = \"The option to sort constraints. Defaults to `ID`.\" , ), sorted_reverse : bool = Query ( False , description = \"The option to reverse constraints order. Defaults to `False`.\" , ), # TODO: filter_text # TODO: limit_size + offset ) -> Dict [ str , Any ]: \"\"\" Get constraints. Args: project_id (str): The ID of the project. without_hidden_constraints (bool, optional): The option to not return hidden constraints. Defaults to `True`. sorted_by (ConstraintsSortOptions, optional): The option to sort constraints. Defaults to `ID`. sorted_reverse (bool, optional): The option to reverse constraints order. Defaults to `False`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. Returns: Dict[str, Any]: A dictionary that contains constraints. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) ### ### Load needed data. ### # Load constraints. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject : constraints : Dict [ str , Any ] = { constraint_id : constraint_value for constraint_id , constraint_value in json . load ( constraints_fileobject ) . items () if ( without_hidden_constraints is False or constraint_value [ \"is_hidden\" ] is False ) } # Load texts. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"r\" ) as texts_fileobject : texts : Dict [ str , Any ] = json . load ( texts_fileobject ) ### ### Sort constraints. ### # Define the values selection method. def get_value_for_constraints_sorting ( # noqa: WPS430 (nested function) constraint_to_sort : Tuple [ str , Dict [ str , Any ]] ) -> Any : \"\"\"Return the values expected for constraints sorting. Args: constraint_to_sort (Tuple[Dict[str, Any]]): A constraint (from `.items()`). Returns: Any: The expected values of the constraint need for the sort. \"\"\" # By constraint id. if sorted_by == ConstraintsSortOptions . ID : return constraint_to_sort [ 0 ] # By texts. if sorted_by == ConstraintsSortOptions . TEXT : return ( texts [ constraint_to_sort [ 1 ][ \"data\" ][ \"id_1\" ]][ \"text\" ], texts [ constraint_to_sort [ 1 ][ \"data\" ][ \"id_2\" ]][ \"text\" ], ) # By constraint type. if sorted_by == ConstraintsSortOptions . CONSTRAINT_TYPE : return ( constraint_to_sort [ 1 ][ \"constraint_type\" ] is None , constraint_to_sort [ 1 ][ \"constraint_type\" ] == \"CANNOT_LINK\" , constraint_to_sort [ 1 ][ \"constraint_type\" ] == \"MUST_LINK\" , ) # By date of update. if sorted_by == ConstraintsSortOptions . DATE_OF_UPDATE : return constraint_to_sort [ 1 ][ \"date_of_update\" ] # By iteration of sampling. if sorted_by == ConstraintsSortOptions . ITERATION_OF_SAMPLING : return constraint_to_sort [ 1 ][ \"iteration_of_sampling\" ] # To annotation. if sorted_by == ConstraintsSortOptions . TO_ANNOTATE : return constraint_to_sort [ 1 ][ \"to_annotate\" ] is False # To review. if sorted_by == ConstraintsSortOptions . TO_REVIEW : return constraint_to_sort [ 1 ][ \"to_review\" ] is False # To fix conflict. #### if sorted_by == ConstraintsSortOptions.TO_FIX_CONFLICT: return constraint_to_sort [ 1 ][ \"to_fix_conflict\" ] is False # Sorted the constraints to return. sorted_constraints : Dict [ str , Any ] = { sorted_constraint_id : sorted_constraint for sorted_constraint_id , sorted_constraint in sorted ( constraints . items (), key = get_value_for_constraints_sorting , reverse = sorted_reverse , ) } # Return the requested constraints. return { \"project_id\" : project_id , \"constraints\" : sorted_constraints , # Get the request parameters. \"parameters\" : { \"without_hidden_constraints\" : without_hidden_constraints , \"sorted_by\" : sorted_by . value , \"sorted_reverse\" : sorted_reverse , }, }","title":"get_constraints()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_constraints_sampling_results","text":"Get constraints sampling results. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') iteration_id Optional [ int ] The ID of project iteration. If None , get the current iteration. Defaults to None . Query(None, description='The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the iteration with id iteration_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the status of the project hasn't completed its sampling step. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains sampling result. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 @app . get ( \"/api/projects/ {project_id} /sampling\" , tags = [ \"Constraints sampling\" ], status_code = status . HTTP_200_OK , ) async def get_constraints_sampling_results ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), iteration_id : Optional [ int ] = Query ( None , description = \"The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get constraints sampling results. Args: project_id (str, optional): The ID of the project. iteration_id (Optional[int], optional): The ID of project iteration. If `None`, get the current iteration. Defaults to `None`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the iteration with id `iteration_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the status of the project hasn't completed its sampling step. Returns: Dict[str, Any]: A dictionary that contains sampling result. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load settings. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject : project_settings : Dict [ str , Dict [ str , Any ]] = json . load ( settings_fileobject ) # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Get current iteration id if needed. if iteration_id is None : if project_status [ \"iteration_id\" ] == 0 : iteration_id = 0 elif ( project_status [ \"state\" ] == ICGUIStates . SAMPLING_TODO # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . SAMPLING_PENDING or project_status [ \"state\" ] == ICGUIStates . SAMPLING_WORKING or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_ERRORS ): iteration_id = project_status [ \"iteration_id\" ] - 1 else : iteration_id = project_status [ \"iteration_id\" ] # Case of iteration `0`. if iteration_id == 0 : raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The iteration `0` has no sampling step.\" , ) # Check project status. if iteration_id == project_status [ \"iteration_id\" ] and ( project_status [ \"state\" ] == ICGUIStates . SAMPLING_TODO # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . SAMPLING_PENDING or project_status [ \"state\" ] == ICGUIStates . SAMPLING_WORKING or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_ERRORS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' hasn't completed its sampling step on iteration ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( iteration_id ), ), ) # Otherwise check that requested iteration id exist. if str ( iteration_id ) not in project_settings . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' has no iteration with id ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( iteration_id ), ), ) # Load the sampling results. with open ( DATA_DIRECTORY / project_id / \"sampling.json\" , \"r\" ) as sampling_fileobject : # Return the project sampling. return { \"project_id\" : project_id , \"iteration_id\" : iteration_id , \"sampling\" : json . load ( sampling_fileobject )[ str ( iteration_id )], }","title":"get_constraints_sampling_results()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_html_constraint_annotation_page","text":"Get HTML constraint annotation page. Parameters: Name Type Description Default request Request The request context. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') constraint_id str The ID of the constraint. Path(Ellipsis, description='The ID of the constraint.') Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 @app . get ( \"/gui/projects/ {project_id} /constraints/ {constraint_id} \" , tags = [ \"Constraints\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_constraint_annotation_page ( request : Request , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), constraint_id : str = Path ( ... , description = \"The ID of the constraint.\" , ), ) -> Response : \"\"\" Get HTML constraint annotation page. Args: request (Request): The request context. project_id (str): The ID of the project. constraint_id (str): The ID of the constraint. Returns: Response: The requested page. \"\"\" # Return HTML constraints page. try : return templates . TemplateResponse ( name = \"constraint_annotation.html\" , context = { \"request\" : request , # Get the project ID. \"project_id\" : project_id , # Get the constraints ID. \"constraint_id\" : constraint_id , # Get the project metadata (ID, name, creation date). \"metadata\" : ( await get_metadata ( project_id = project_id ))[ \"metadata\" ], # Get the project status (iteration, step name and status, modelization state and conflict). \"status\" : ( await get_status ( project_id = project_id ))[ \"status\" ], # Get the project texts. \"texts\" : ( await get_texts ( project_id = project_id , without_deleted_texts = False , sorted_by = TextsSortOptions . ID , sorted_reverse = False , ) )[ \"texts\" ], # Get the project constraints. \"constraints\" : ( await get_constraints ( project_id = project_id , without_hidden_constraints = False , sorted_by = ConstraintsSortOptions . ITERATION_OF_SAMPLING , sorted_reverse = False , ) )[ \"constraints\" ], # Get the project clustering result. \"clusters\" : ( await get_constrained_clustering_results ( project_id = project_id , iteration_id = None ))[ \"clustering\" ], # Get the project modelization inference result. \"modelization\" : ( await get_modelization ( project_id = project_id ))[ \"modelization\" ], }, status_code = status . HTTP_200_OK , ) # Case of error: Return HTML error page. except HTTPException as error : # Return HTML error page. return templates . TemplateResponse ( name = \"error.html\" , context = { \"request\" : request , \"status_code\" : error . status_code , \"detail\" : error . detail , }, status_code = error . status_code , )","title":"get_html_constraint_annotation_page()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_html_constraints_page","text":"Get HTML constraints page. Parameters: Name Type Description Default request Request The request context. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') sorted_by ConstraintsSortOptions The option to sort constraints. Defaults to ITERATION_OF_SAMPLING . Query(ConstraintsSortOptions.ITERATION_OF_SAMPLING, description='The option to sort constraints. Defaults to `ITERATION_OF_SAMPLING`.') sorted_reverse bool The option to reverse constraints order. Defaults to False . Query(False, description='The option to reverse constraints order. Defaults to `False`.') Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 @app . get ( \"/gui/projects/ {project_id} /constraints\" , tags = [ \"Constraints\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_constraints_page ( request : Request , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), sorted_by : ConstraintsSortOptions = Query ( ConstraintsSortOptions . ITERATION_OF_SAMPLING , description = \"The option to sort constraints. Defaults to `ITERATION_OF_SAMPLING`.\" , ), sorted_reverse : bool = Query ( False , description = \"The option to reverse constraints order. Defaults to `False`.\" , ), # TODO: filter_text # TODO: limit_size + offset ) -> Response : \"\"\" Get HTML constraints page. Args: request (Request): The request context. project_id (str): The ID of the project. sorted_by (ConstraintsSortOptions, optional): The option to sort constraints. Defaults to `ITERATION_OF_SAMPLING`. sorted_reverse (bool, optional): The option to reverse constraints order. Defaults to `False`. Returns: Response: The requested page. \"\"\" # Return HTML constraints page. try : return templates . TemplateResponse ( name = \"constraints.html\" , context = { \"request\" : request , # Get the project ID. \"project_id\" : project_id , # Get the request parameters. \"parameters\" : { \"without_hidden_constraints\" : True , \"sorted_by\" : sorted_by . value , \"sorted_reverse\" : sorted_reverse , }, # Get the project metadata (ID, name, creation date). \"metadata\" : ( await get_metadata ( project_id = project_id ))[ \"metadata\" ], # Get the project status (iteration, step name and status, modelization state and conflict). \"status\" : ( await get_status ( project_id = project_id ))[ \"status\" ], # Get the project texts. \"texts\" : ( await get_texts ( project_id = project_id , without_deleted_texts = False , sorted_by = TextsSortOptions . ID , sorted_reverse = False , ) )[ \"texts\" ], # Get the project constraints. \"constraints\" : ( await get_constraints ( project_id = project_id , without_hidden_constraints = True , sorted_by = sorted_by , sorted_reverse = sorted_reverse , ) )[ \"constraints\" ], }, status_code = status . HTTP_200_OK , ) # Case of error: Return HTML error page. except HTTPException as error : # Return HTML error page. return templates . TemplateResponse ( name = \"error.html\" , context = { \"request\" : request , \"status_code\" : error . status_code , \"detail\" : error . detail , }, status_code = error . status_code , )","title":"get_html_constraints_page()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_html_help_page","text":"Get HTML help page. Parameters: Name Type Description Default request Request The request context. required Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 @app . get ( \"/gui/help\" , tags = [ \"Home and Documentation\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_help_page ( request : Request , ) -> Response : \"\"\" Get HTML help page. Args: request (Request): The request context. Returns: Response: The requested page. \"\"\" # Return HTML help page. return templates . TemplateResponse ( name = \"help.html\" , context = { \"request\" : request , }, status_code = status . HTTP_200_OK , )","title":"get_html_help_page()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_html_project_home_page","text":"Get HTML project home page. Parameters: Name Type Description Default request Request The request context. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 @app . get ( \"/gui/projects/ {project_id} \" , tags = [ \"Projects\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_project_home_page ( request : Request , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Response : \"\"\" Get HTML project home page. Args: request (Request): The request context. project_id (str): The ID of the project. Returns: Response: The requested page. \"\"\" # Return HTML project home page. try : return templates . TemplateResponse ( name = \"project_home.html\" , context = { \"request\" : request , # Get the project ID. \"project_id\" : project_id , # Get the project metadata (ID, name, creation date). \"metadata\" : ( await get_metadata ( project_id = project_id ))[ \"metadata\" ], # Get the project status (iteration, step name and status, modelization state and conflict). \"status\" : ( await get_status ( project_id = project_id ))[ \"status\" ], }, status_code = status . HTTP_200_OK , ) # Case of error: Return HTML error page. except HTTPException as error : # Return HTML error page. return templates . TemplateResponse ( name = \"error.html\" , context = { \"request\" : request , \"status_code\" : error . status_code , \"detail\" : error . detail , }, status_code = error . status_code , )","title":"get_html_project_home_page()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_html_projects_listing_or_creation_page","text":"Get HTML projects listing or creation page. Parameters: Name Type Description Default request Request The request context. required Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 @app . get ( \"/gui/projects\" , tags = [ \"Projects\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_projects_listing_or_creation_page ( request : Request , ) -> Response : \"\"\" Get HTML projects listing or creation page. Args: request (Request): The request context. Returns: Response: The requested page. \"\"\" # Return HTML projects listing and creation page. return templates . TemplateResponse ( name = \"projects_listing.html\" , context = { \"request\" : request , # Get projects and their description. \"projects\" : { project_id : { \"metadata\" : ( await get_metadata ( project_id = project_id ))[ \"metadata\" ], \"status\" : ( await get_status ( project_id = project_id ))[ \"status\" ], } for project_id in ( await get_projects ()) }, }, status_code = status . HTTP_200_OK , )","title":"get_html_projects_listing_or_creation_page()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_html_settings_page","text":"Get HTML settings page. Parameters: Name Type Description Default request Request The request context. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') iteration_id Optional [ int ] The ID of project iteration. If None , get the current iteration. Defaults to None . Query(None, description='The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.') settings_names List [ ICGUISettings ] The list of names of requested settings to return. Defaults to [ICGUISettings.PREPROCESSING, ICGUISettings.VECTORIZATION, ICGUISettings.SAMPLING, ICGUISettings.CLUSTERING,] . Query([ICGUISettings.PREPROCESSING, ICGUISettings.VECTORIZATION, ICGUISettings.SAMPLING, ICGUISettings.CLUSTERING], description='The list of names of requested settings to return. To select multiple settings kinds, use `CTRL + clic`.') Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 @app . get ( \"/gui/projects/ {project_id} /settings\" , tags = [ \"Settings\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_settings_page ( request : Request , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), iteration_id : Optional [ int ] = Query ( None , description = \"The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.\" , ), settings_names : List [ ICGUISettings ] = Query ( [ ICGUISettings . PREPROCESSING , ICGUISettings . VECTORIZATION , ICGUISettings . SAMPLING , ICGUISettings . CLUSTERING , ], description = \"The list of names of requested settings to return. To select multiple settings kinds, use `CTRL + clic`.\" , ), ) -> Response : \"\"\" Get HTML settings page. Args: request (Request): The request context. project_id (str): The ID of the project. iteration_id (Optional[int], optional): The ID of project iteration. If `None`, get the current iteration. Defaults to `None`. settings_names (List[ICGUISettings], optional): The list of names of requested settings to return. Defaults to `[ICGUISettings.PREPROCESSING, ICGUISettings.VECTORIZATION, ICGUISettings.SAMPLING, ICGUISettings.CLUSTERING,]`. Returns: Response: The requested page. \"\"\" # Return HTML project home page. try : # noqa: WPS229 (too long try body) project_status : Dict [ str , Any ] = ( await get_status ( project_id = project_id ))[ \"status\" ] if iteration_id is None : iteration_id = project_status [ \"iteration_id\" ] return templates . TemplateResponse ( name = \"settings.html\" , context = { \"request\" : request , # Get the project ID. \"project_id\" : project_id , # Get the iteration ID. \"iteration_id\" : iteration_id , # Get the request parameters. \"parameters\" : { \"settings_names\" : [ settings_name . value for settings_name in settings_names ], }, # Get the project metadata (ID, name, creation date). \"metadata\" : ( await get_metadata ( project_id = project_id ))[ \"metadata\" ], # Get the project status (iteration, step name and status, modelization state and conflict). \"status\" : project_status , # Get the project settings (preprocessing, vectorization, sampling, clustering). \"settings\" : ( await get_settings ( project_id = project_id , iteration_id = iteration_id , settings_names = settings_names ) )[ \"settings\" ], # Get navigation information. \"navigation\" : { \"previous\" : ( None if ( iteration_id == 0 ) else iteration_id - 1 ), \"next\" : ( None if ( iteration_id == project_status [ \"iteration_id\" ]) else ( iteration_id + 1 )), }, }, status_code = status . HTTP_200_OK , ) # Case of error: Return HTML error page. except HTTPException as error : # Return HTML error page. return templates . TemplateResponse ( name = \"error.html\" , context = { \"request\" : request , \"status_code\" : error . status_code , \"detail\" : error . detail , }, status_code = error . status_code , )","title":"get_html_settings_page()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_html_texts_page","text":"Get HTML texts page. Parameters: Name Type Description Default request Request The request context. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') sorted_by TextsSortOptions The option to sort texts. Defaults to ALPHABETICAL . Query(TextsSortOptions.ALPHABETICAL, description='The option to sort texts. Defaults to `ALPHABETICAL`.') sorted_reverse bool The option to reverse texts order. Defaults to False . Query(False, description='The option to reverse texts order. Defaults to `False`.') Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 @app . get ( \"/gui/projects/ {project_id} /texts\" , tags = [ \"Texts\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_texts_page ( request : Request , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), sorted_by : TextsSortOptions = Query ( TextsSortOptions . ALPHABETICAL , description = \"The option to sort texts. Defaults to `ALPHABETICAL`.\" , ), sorted_reverse : bool = Query ( False , description = \"The option to reverse texts order. Defaults to `False`.\" , ), # TODO: filter_text # TODO: limit_size + offset ) -> Response : \"\"\" Get HTML texts page. Args: request (Request): The request context. project_id (str): The ID of the project. sorted_by (TextsSortOptions, optional): The option to sort texts. Defaults to `ALPHABETICAL`. sorted_reverse (bool, optional): The option to reverse texts order. Defaults to `False`. Returns: Response: The requested page. \"\"\" # Return HTML constraints page. try : return templates . TemplateResponse ( name = \"texts.html\" , context = { \"request\" : request , # Get the project ID. \"project_id\" : project_id , # Get the request parameters. \"parameters\" : { \"without_deleted_texts\" : True , \"sorted_by\" : sorted_by . value , \"sorted_reverse\" : sorted_reverse , }, # Get the project metadata (ID, name, creation date). \"metadata\" : ( await get_metadata ( project_id = project_id ))[ \"metadata\" ], # Get the project status (iteration, step name and status, modelization state and conflict). \"status\" : ( await get_status ( project_id = project_id ))[ \"status\" ], # Get the project texts. \"texts\" : ( await get_texts ( project_id = project_id , without_deleted_texts = False , sorted_by = sorted_by , sorted_reverse = sorted_reverse , ) )[ \"texts\" ], # Get the project constraints. \"constraints\" : ( await get_constraints ( project_id = project_id , without_hidden_constraints = True , sorted_by = ConstraintsSortOptions . ID , sorted_reverse = False , ) )[ \"constraints\" ], }, status_code = status . HTTP_200_OK , ) # Case of error: Return HTML error page. except HTTPException as error : # Return HTML error page. return templates . TemplateResponse ( name = \"error.html\" , context = { \"request\" : request , \"status_code\" : error . status_code , \"detail\" : error . detail , }, status_code = error . status_code , )","title":"get_html_texts_page()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_html_welcome_page","text":"Define HTML welcome page. Parameters: Name Type Description Default request Request The request context. required Returns: Name Type Description Response Response The requested page. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 @app . get ( \"/welcome\" , # TODO: Use \"/\". tags = [ \"Home and Documentation\" ], response_class = Response , status_code = status . HTTP_200_OK , ) async def get_html_welcome_page ( request : Request , ) -> Response : \"\"\" Define HTML welcome page. Args: request (Request): The request context. Returns: Response: The requested page. \"\"\" # Return HTML welcome page. return templates . TemplateResponse ( name = \"welcome.html\" , context = { \"request\" : request , }, status_code = status . HTTP_200_OK , )","title":"get_html_welcome_page()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_metadata","text":"Get metadata. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains metadata. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 @app . get ( \"/api/projects/ {project_id} /metadata\" , tags = [ \"Projects\" ], status_code = status . HTTP_200_OK , ) async def get_metadata ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get metadata. Args: project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. Returns: Dict[str, Any]: A dictionary that contains metadata. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load the project metadata. with open ( DATA_DIRECTORY / project_id / \"metadata.json\" , \"r\" ) as metadata_fileobject : # Return the project metadata. return { \"project_id\" : project_id , \"metadata\" : json . load ( metadata_fileobject ), }","title":"get_metadata()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_modelization","text":"Get modelization inference. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains modelization inference result. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 @app . get ( \"/api/projects/ {project_id} /modelization\" , tags = [ \"Data modelization\" ], status_code = status . HTTP_200_OK , ) async def get_modelization ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get modelization inference. Args: project_id (str, optional): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. Returns: Dict[str, Any]: A dictionary that contains modelization inference result. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load the modelization inference results. with open ( DATA_DIRECTORY / project_id / \"modelization.json\" , \"r\" ) as modelization_fileobject : # Return the project modelization inference. return { \"project_id\" : project_id , \"modelization\" : json . load ( modelization_fileobject ), }","title":"get_modelization()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_next_key","text":"Get next key in a dictionary. Parameters: Name Type Description Default key str The current key. required dictionary Dict [ str , Any ] The dictionary. required Returns: Type Description Optional [ str ] Optional[str]: The next key. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def get_next_key ( key : str , dictionary : Dict [ str , Any ]) -> Optional [ str ]: \"\"\" Get next key in a dictionary. Args: key (str): The current key. dictionary (Dict[str, Any]): The dictionary. Returns: Optional[str]: The next key. \"\"\" list_of_keys : List [ str ] = list ( dictionary . keys ()) if key in list_of_keys : next_key_index : int = list_of_keys . index ( key ) + 1 return list_of_keys [ next_key_index ] if next_key_index < len ( list_of_keys ) else None return None","title":"get_next_key()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_previous_key","text":"Get previous key in a dictionary. Parameters: Name Type Description Default key str The current key. required dictionary Dict [ str , Any ] The dictionary. required Returns: Type Description Optional [ str ] Optional[str]: The previous key. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def get_previous_key ( key : str , dictionary : Dict [ str , Any ]) -> Optional [ str ]: \"\"\" Get previous key in a dictionary. Args: key (str): The current key. dictionary (Dict[str, Any]): The dictionary. Returns: Optional[str]: The previous key. \"\"\" list_of_keys : List [ str ] = list ( dictionary . keys ()) if key in list_of_keys : previous_key_index : int = list_of_keys . index ( key ) - 1 return list_of_keys [ previous_key_index ] if 0 <= previous_key_index else None return None","title":"get_previous_key()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_projects","text":"Get the list of existing project IDs. (A project is represented by a subfolder in .data folder.) Returns: Type Description List [ str ] List[str]: The list of existing project IDs. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 @app . get ( \"/api/projects\" , tags = [ \"Projects\" ], status_code = status . HTTP_200_OK , ) async def get_projects () -> List [ str ]: \"\"\" Get the list of existing project IDs. (A project is represented by a subfolder in `.data` folder.) Returns: List[str]: The list of existing project IDs. \"\"\" # Return the list of project IDs. return [ project_id for project_id in os . listdir ( DATA_DIRECTORY ) if os . path . isdir ( DATA_DIRECTORY / project_id )]","title":"get_projects()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_settings","text":"Get settings. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') iteration_id Optional [ int ] The ID of project iteration. If None , get the current iteration. Defaults to None . Query(None, description='The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.') settings_names List [ ICGUISettings ] The list of names of requested settings to return. Defaults to [ICGUISettings.PREPROCESSING, ICGUISettings.VECTORIZATION, ICGUISettings.SAMPLING, ICGUISettings.CLUSTERING,] . Query([ICGUISettings.PREPROCESSING, ICGUISettings.VECTORIZATION, ICGUISettings.SAMPLING, ICGUISettings.CLUSTERING], description='The list of names of requested settings to return. To select multiple settings kinds, use `CTRL + clic`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the iteration with id iteration_id doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains settings. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 @app . get ( \"/api/projects/ {project_id} /settings\" , tags = [ \"Settings\" ], status_code = status . HTTP_200_OK , ) async def get_settings ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), iteration_id : Optional [ int ] = Query ( None , description = \"The ID of project iteration. If `None`, get the current iteration. Defaults to `None`.\" , ), settings_names : List [ ICGUISettings ] = Query ( [ ICGUISettings . PREPROCESSING , ICGUISettings . VECTORIZATION , ICGUISettings . SAMPLING , ICGUISettings . CLUSTERING , ], description = \"The list of names of requested settings to return. To select multiple settings kinds, use `CTRL + clic`.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get settings. Args: project_id (str): The ID of the project. iteration_id (Optional[int], optional): The ID of project iteration. If `None`, get the current iteration. Defaults to `None`. settings_names (List[ICGUISettings], optional): The list of names of requested settings to return. Defaults to `[ICGUISettings.PREPROCESSING, ICGUISettings.VECTORIZATION, ICGUISettings.SAMPLING, ICGUISettings.CLUSTERING,]`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the iteration with id `iteration_id` doesn't exist. Returns: Dict[str, Any]: A dictionary that contains settings. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load settings. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject : project_settings : Dict [ str , Dict [ str , Any ]] = json . load ( settings_fileobject ) # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Get current iteration id if needed. if iteration_id is None : iteration_id = project_status [ \"iteration_id\" ] # Otherwise check that requested iteration id exist. if str ( iteration_id ) not in project_settings . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' has no iteration with id ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( iteration_id ), ), ) # Return the requested settings. return { # Get the project ID. \"project_id\" : project_id , # Get the iteration ID. \"iteration_id\" : iteration_id , # Get the request parameters. \"parameters\" : { \"settings_names\" : [ settings_name . value for settings_name in settings_names ], }, # Get the settings. \"settings\" : { setting_name : settings_value for setting_name , settings_value in project_settings [ str ( iteration_id )] . items () if setting_name in settings_names }, }","title":"get_settings()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_status","text":"Get status. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains status. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 @app . get ( \"/api/projects/ {project_id} /status\" , tags = [ \"Status\" ], status_code = status . HTTP_200_OK , ) async def get_status ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get status. Args: project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. Returns: Dict[str, Any]: A dictionary that contains status. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) project_status [ \"state_details\" ] = get_ICGUIStates_details ( state = project_status [ \"state\" ]) # Return the requested status. return { \"project_id\" : project_id , \"status\" : project_status }","title":"get_status()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_texts","text":"Get texts. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') without_deleted_texts bool The option to not return deleted texts. Defaults to True . Query(True, description='The option to not return deleted texts. Defaults to `True`.') sorted_by TextsSortOptions The option to sort texts. Defaults to ALPHABETICAL . Query(TextsSortOptions.ALPHABETICAL, description='The option to sort texts. Defaults to `ALPHABETICAL`.') sorted_reverse bool The option to reverse texts order. Defaults to False . Query(False, description='The option to reverse texts order. Defaults to `False`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains texts. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 @app . get ( \"/api/projects/ {project_id} /texts\" , tags = [ \"Texts\" ], status_code = status . HTTP_200_OK , ) async def get_texts ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), without_deleted_texts : bool = Query ( True , description = \"The option to not return deleted texts. Defaults to `True`.\" , ), sorted_by : TextsSortOptions = Query ( TextsSortOptions . ALPHABETICAL , description = \"The option to sort texts. Defaults to `ALPHABETICAL`.\" , ), sorted_reverse : bool = Query ( False , description = \"The option to reverse texts order. Defaults to `False`.\" , ), # TODO: filter_text # TODO: limit_size + offset ) -> Dict [ str , Any ]: \"\"\" Get texts. Args: project_id (str): The ID of the project. without_deleted_texts (bool): The option to not return deleted texts. Defaults to `True`. sorted_by (TextsSortOptions, optional): The option to sort texts. Defaults to `ALPHABETICAL`. sorted_reverse (bool, optional): The option to reverse texts order. Defaults to `False`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. Returns: Dict[str, Any]: A dictionary that contains texts. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) ### ### Load needed data. ### # Load texts. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"r\" ) as texts_fileobject : texts : Dict [ str , Any ] = { text_id : text_value for text_id , text_value in json . load ( texts_fileobject ) . items () if ( without_deleted_texts is False or text_value [ \"is_deleted\" ] is False ) } ### ### Sort texts. ### # Define the values selection method. def get_value_for_texts_sorting ( text_to_sort : Tuple [ str , Dict [ str , Any ]]) -> Any : # noqa: WPS430 (nested function) \"\"\"Return the values expected for texts sorting. Args: text_to_sort (Tuple[Dict[str, Any]]): A text (from `.items()`). Returns: Any: The expected values of the text need for the sort. \"\"\" # By text id. if sorted_by == TextsSortOptions . ID : return text_to_sort [ 0 ] # By text value. if sorted_by == TextsSortOptions . ALPHABETICAL : return text_to_sort [ 1 ][ \"text_preprocessed\" ] # By deletion status. #### if sorted_by == TextsSortOptions.IS_DELETED: return text_to_sort [ 1 ][ \"is_deleted\" ] # Sorted the texts to return. sorted_texts : Dict [ str , Any ] = { sorted_text_id : sorted_text for sorted_text_id , sorted_text in sorted ( texts . items (), key = get_value_for_texts_sorting , reverse = sorted_reverse , ) } # Return the requested texts. return { \"project_id\" : project_id , \"texts\" : sorted_texts , # Get the request parameters. \"parameters\" : { \"without_deleted_texts\" : without_deleted_texts , \"sorted_by\" : sorted_by . value , \"sorted_reverse\" : sorted_reverse , }, }","title":"get_texts()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.get_vectors","text":"Get 2D and 3D vectors. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the iteration with id iteration_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the status of the project hasn't completed its clustering step. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains clustering result. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 @app . get ( \"/api/projects/ {project_id} /vectors\" , tags = [ \"Data modelization\" ], status_code = status . HTTP_200_OK , ) async def get_vectors ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Get 2D and 3D vectors. Args: project_id (str, optional): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the iteration with id `iteration_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the status of the project hasn't completed its clustering step. Returns: Dict[str, Any]: A dictionary that contains clustering result. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Check project status. if ( project_status [ \"state\" ] != ICGUIStates . SAMPLING_TODO # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . SAMPLING_PENDING and project_status [ \"state\" ] != ICGUIStates . SAMPLING_WORKING and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . CLUSTERING_TODO and project_status [ \"state\" ] != ICGUIStates . CLUSTERING_PENDING and project_status [ \"state\" ] != ICGUIStates . CLUSTERING_WORKING and project_status [ \"state\" ] != ICGUIStates . ITERATION_END ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' hasn't completed its modelization update step.\" . format ( project_id_str = str ( project_id ), ), ) # Load the 2D vectors. with open ( DATA_DIRECTORY / project_id / \"vectors_2D.json\" , \"r\" ) as vectors_2D_fileobject : vectors_2D : Dict [ str , Dict [ str , float ]] = json . load ( vectors_2D_fileobject ) # noqa: S301 # Usage of Pickle # Load the 3D vectors. with open ( DATA_DIRECTORY / project_id / \"vectors_3D.json\" , \"r\" ) as vectors_3D_fileobject : vectors_3D : Dict [ str , Dict [ str , float ]] = json . load ( vectors_3D_fileobject ) # noqa: S301 # Usage of Pickle # Return the project vectors. return { \"project_id\" : project_id , \"vectors_2d\" : vectors_2D , \"vectors_3d\" : vectors_3D , }","title":"get_vectors()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.import_project","text":"Import a project from a zip archive file. Parameters: Name Type Description Default background_tasks BackgroundTasks A background task to run after the return statement. required project_archive UploadFile A zip archive representing a project. Use format from download route. File(Ellipsis, description='A zip archive representing a project. Use format from `download` route.') Raises: Type Description HTTPException Raises HTTP_400_NOT_FOUND if archive is invalid. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of the imported project. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 @app . put ( \"/api/projects\" , tags = [ \"Projects\" ], status_code = status . HTTP_201_CREATED , ) async def import_project ( background_tasks : BackgroundTasks , project_archive : UploadFile = File ( ... , description = \"A zip archive representing a project. Use format from `download` route.\" , # TODO: max_size=\"8MB\", ), ) -> Dict [ str , Any ]: \"\"\" Import a project from a zip archive file. Args: background_tasks (BackgroundTasks): A background task to run after the return statement. project_archive (UploadFile, optional): A zip archive representing a project. Use format from `download` route. Raises: HTTPException: Raises `HTTP_400_NOT_FOUND` if archive is invalid. Returns: Dict[str, Any]: A dictionary that contains the ID of the imported project. \"\"\" # Check archive type. if project_archive . content_type != \"application/x-zip-compressed\" : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = \"The file type ' {project_archive_type} ' is not supported. Please use '.zip' file.\" . format ( project_archive_type = str ( project_archive . content_type ), ), ) # Temporarly store zip archive. current_timestamp : float = datetime . now () . timestamp () new_current_project_id : str = str ( int ( current_timestamp * 10 ** 6 )) import_archive_name : str = \"import- {new_current_project_id_str} .zip\" . format ( new_current_project_id_str = str ( new_current_project_id ) ) import_archive_path : pathlib . Path = DATA_DIRECTORY / import_archive_name with open ( import_archive_path , \"wb\" ) as import_archive_fileobject_w : shutil . copyfileobj ( project_archive . file , import_archive_fileobject_w ) # Define a backgroundtask to clear archive after importation. def clear_after_import_project (): # noqa: WPS430 (nested function) \"\"\" Delete the archive file. \"\"\" # Delete archive file. if os . path . exists ( import_archive_path ): # pragma: no cover os . remove ( import_archive_path ) # Add the background task. background_tasks . add_task ( func = clear_after_import_project , ) # Try to open archive file. try : with zipfile . ZipFile ( import_archive_path , \"r\" ) as import_archive_file : ### ### Check archive content. ### missing_files : List [ str ] = [ needed_file for needed_file in ( \"metadata.json\" , \"status.json\" , \"texts.json\" , \"constraints.json\" , \"settings.json\" , \"sampling.json\" , \"clustering.json\" , \"modelization.json\" , # Will be recomputed during modelization step. # \"vectors_2D.json\", # Will be recomputed during modelization step. # \"vectors_3D.json\", # Will be recomputed during modelization step. ) if needed_file not in import_archive_file . namelist () ] if len ( missing_files ) != 0 : # noqa: WPS507 raise ValueError ( \"The project archive file doesn't contains the following files: {missing_files_str} .\" . format ( missing_files_str = str ( missing_files ), ) ) ### ### Check `metadata.json`. ### with import_archive_file . open ( \"metadata.json\" ) as metadata_fileobject_r : metadata : Dict [ str , Any ] = json . load ( metadata_fileobject_r ) metadata [ \"project_id\" ] = new_current_project_id if ( \"project_name\" not in metadata . keys () or not isinstance ( metadata [ \"project_name\" ], str ) or \"creation_timestamp\" not in metadata . keys () or not isinstance ( metadata [ \"creation_timestamp\" ], float ) ): raise ValueError ( \"The project archive file has an invalid `metadata.json` file.\" ) ### ### Check `status.json`. ### with import_archive_file . open ( \"status.json\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) # Check `status.state`. if \"state\" not in project_status . keys (): raise ValueError ( \"The project archive file has an invalid `status.json` file (see key `state`).\" ) # Force `status.state` - Case of initialization. if ( project_status [ \"state\" ] == ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . INITIALIZATION_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . INITIALIZATION_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . INITIALIZATION_WITH_ERRORS ): project_status [ \"state\" ] = ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION # Force `status.state` - Case of sampling. elif ( project_status [ \"state\" ] == ICGUIStates . SAMPLING_TODO # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . SAMPLING_PENDING or project_status [ \"state\" ] == ICGUIStates . SAMPLING_WORKING or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_ERRORS ): project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION # Force `status.state` - Case of annotation. elif ( project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS or project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS or project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS or project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS or project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS or project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_WORKING_MODELIZATION ): project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION # Force `status.state` - Case of clustering. elif ( project_status [ \"state\" ] == ICGUIStates . CLUSTERING_TODO # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . CLUSTERING_PENDING or project_status [ \"state\" ] == ICGUIStates . CLUSTERING_WORKING or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_ERRORS ): project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION # Force `status.state` - Case of iteration end. elif ( project_status [ \"state\" ] == ICGUIStates . ITERATION_END # noqa: WPS514 or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION or project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_ERRORS ): project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION # Force `state` - Case of unknown state. else : raise ValueError ( \"The project archive file has an invalid `status.json` file (see key `state`).\" ) # Force `status.task`. project_status [ \"task\" ] = None # TODO: Check `texts.json`. with import_archive_file . open ( \"texts.json\" ) as texts_fileobject_r : texts : Dict [ str , Dict [ str , Any ]] = json . load ( texts_fileobject_r ) # TODO: Check `constraints.json`. with import_archive_file . open ( \"constraints.json\" ) as constraints_fileobject_r : constraints : Dict [ str , Dict [ str , Any ]] = json . load ( constraints_fileobject_r ) # TODO: Check `settings.json`. with import_archive_file . open ( \"settings.json\" ) as settings_fileobject_r : settings : Dict [ str , Dict [ str , Any ]] = json . load ( settings_fileobject_r ) # TODO: Check `sampling.json`. with import_archive_file . open ( \"sampling.json\" ) as sampling_fileobject_r : sampling : Dict [ str , List [ str ]] = json . load ( sampling_fileobject_r ) # TODO: Check `clustering.json`. with import_archive_file . open ( \"clustering.json\" ) as clustering_fileobject_r : clustering : Dict [ str , Dict [ str , str ]] = json . load ( clustering_fileobject_r ) # TODO: Check `modelization.json`. with import_archive_file . open ( \"modelization.json\" ) as modelization_fileobject_r : modelization : Dict [ str , Dict [ str , Any ]] = json . load ( modelization_fileobject_r ) # Error: case of custom raised errors. except ValueError as value_error : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = str ( value_error ), ) # Error: other raised errors. except Exception : raise HTTPException ( status_code = status . HTTP_400_BAD_REQUEST , detail = \"An error occurs in project import. Project archive is probably invalid.\" , ) # Create the directory and subdirectories of the new project. os . mkdir ( DATA_DIRECTORY / metadata [ \"project_id\" ]) # Store `metadata.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"metadata.json\" , \"w\" ) as metadata_fileobject_w : json . dump ( metadata , metadata_fileobject_w , indent = 4 ) # Store `status.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Store `texts.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"texts.json\" , \"w\" ) as texts_fileobject_w : json . dump ( texts , texts_fileobject_w , indent = 4 ) # Store `constraints.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) # Store `settings.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"settings.json\" , \"w\" ) as settings_fileobject_w : json . dump ( settings , settings_fileobject_w , indent = 4 ) # Store `sampling.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"sampling.json\" , \"w\" ) as sampling_fileobject_w : json . dump ( sampling , sampling_fileobject_w , indent = 4 ) # Store `clustering.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"clustering.json\" , \"w\" ) as clustering_fileobject_w : json . dump ( clustering , clustering_fileobject_w , indent = 4 ) # Store `modelization.json`. with open ( DATA_DIRECTORY / metadata [ \"project_id\" ] / \"modelization.json\" , \"w\" ) as modelization_fileobject_w : json . dump ( modelization , modelization_fileobject_w , indent = 4 ) # Return the new ID of the imported project. return { \"project_id\" : metadata [ \"project_id\" ], \"detail\" : \"The project with name ' {project_name_str} ' has been imported. It has the id ' {project_id_str} '.\" . format ( project_name_str = str ( metadata [ \"project_name\" ]), project_id_str = str ( metadata [ \"project_id\" ]), ), }","title":"import_project()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.move_to_next_iteration","text":"Move to next iteration after clustering step. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the project didn't complete its clustering step. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of the new iteration. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 @app . post ( \"/api/projects/ {project_id} /iterations\" , tags = [ \"Status\" ], status_code = status . HTTP_201_CREATED , ) async def move_to_next_iteration ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Move to next iteration after clustering step. Args: project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the project didn't complete its clustering step. Returns: Dict[str, Any]: A dictionary that contains the ID of the new iteration. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) # Load settings file. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject_r : project_settings : Dict [ str , Any ] = json . load ( settings_fileobject_r ) # Get current iteration id. current_iteration_id : int = project_status [ \"iteration_id\" ] ### ### Check parameters. ### # Check project status. if project_status [ \"state\" ] != ICGUIStates . ITERATION_END : raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' hasn't completed its clustering step on iteration ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( current_iteration_id ), ), ) ### ### Update data. ### # Define new iteration id. new_iteration_id : int = current_iteration_id + 1 # Initialize status for the new iteration. project_status [ \"iteration_id\" ] = new_iteration_id project_status [ \"state\" ] = ICGUIStates . SAMPLING_TODO # Initialize settings for the new iteration. project_settings [ str ( new_iteration_id )] = { \"sampling\" : ( default_SamplingSettingsModel () . to_dict () if ( current_iteration_id == 0 ) else project_settings [ str ( current_iteration_id )][ \"sampling\" ] ), \"preprocessing\" : project_settings [ str ( current_iteration_id )][ \"preprocessing\" ], \"vectorization\" : project_settings [ str ( current_iteration_id )][ \"vectorization\" ], \"clustering\" : project_settings [ str ( current_iteration_id )][ \"clustering\" ], } ### ### Store updated data. ### # Store project settings. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"w\" ) as settings_fileobject_w : json . dump ( project_settings , settings_fileobject_w , indent = 4 ) # Store project status. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Return the new iteration id. return { \"project_id\" : project_id , \"iteration_id\" : new_iteration_id , \"detail\" : \"The project with id ' {project_id_str} ' is now on iteration with id ' {iteration_id_str} '.\" . format ( project_id_str = str ( project_id ), iteration_id_str = str ( new_iteration_id ), ), }","title":"move_to_next_iteration()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.prepare_constrained_clustering_task","text":"Prepare constrained clustering task. Parameters: Name Type Description Default background_tasks BackgroundTasks A background task to run after the return statement. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow the preparation of constrained clustering task. HTTPException Raises HTTP_504_GATEWAY_TIMEOUT if the task can't be prepared. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the confirmation of the preparation of constrained clustering task. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3623 3624 3625 3626 3627 3628 3629 3630 3631 3632 3633 3634 3635 3636 3637 3638 3639 3640 3641 3642 3643 3644 3645 3646 3647 3648 3649 3650 3651 3652 3653 3654 3655 3656 3657 3658 3659 3660 3661 3662 3663 3664 3665 3666 3667 3668 3669 3670 3671 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 3683 3684 3685 3686 3687 3688 3689 3690 3691 3692 3693 3694 3695 3696 3697 3698 3699 3700 3701 3702 3703 3704 3705 3706 3707 3708 3709 3710 3711 3712 3713 3714 3715 3716 3717 3718 3719 3720 3721 3722 @app . post ( \"/api/projects/ {project_id} /clustering\" , tags = [ \"Constrained clustering\" ], status_code = status . HTTP_202_ACCEPTED , ) async def prepare_constrained_clustering_task ( background_tasks : BackgroundTasks , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Prepare constrained clustering task. Args: background_tasks (BackgroundTasks): A background task to run after the return statement. project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow the preparation of constrained clustering task. HTTPException: Raises `HTTP_504_GATEWAY_TIMEOUT` if the task can't be prepared. Returns: Dict[str, Any]: A dictionary that contains the confirmation of the preparation of constrained clustering task. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) ### ### Check parameters. ### # Check status. if project_status [ \"state\" ] != ICGUIStates . CLUSTERING_TODO : raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow the preparation of constrained clustering task during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"pending\" status. project_status [ \"state\" ] = ICGUIStates . CLUSTERING_PENDING # Prepare status by initializing \"task\" status. project_status [ \"task\" ] = { \"progression\" : 1 , \"detail\" : \"Waiting for background task allocation...\" , } ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) ### ### Launch backgroundtask. ### # Add the background task. background_tasks . add_task ( func = backgroundtasks . run_constrained_clustering_task , project_id = project_id , ) # Return statement. return { # pragma: no cover (need radis and worder) \"project_id\" : project_id , \"detail\" : \"In project with id ' {project_id_str} ', the constrained clustering task has been requested and is waiting for a background task.\" . format ( project_id_str = str ( project_id ), ), }","title":"prepare_constrained_clustering_task()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.prepare_constraints_sampling_task","text":"Prepare constraints sampling task. Parameters: Name Type Description Default background_tasks BackgroundTasks A background task to run after the return statement. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow the preparation of constraints sampling task. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the confirmation of the preparation of constraints sampling task. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 @app . post ( \"/api/projects/ {project_id} /sampling\" , tags = [ \"Constraints sampling\" ], status_code = status . HTTP_202_ACCEPTED , ) async def prepare_constraints_sampling_task ( background_tasks : BackgroundTasks , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Prepare constraints sampling task. Args: background_tasks (BackgroundTasks): A background task to run after the return statement. project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow the preparation of constraints sampling task. Returns: Dict[str, Any]: A dictionary that contains the confirmation of the preparation of constraints sampling task. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Check status. if project_status [ \"state\" ] != ICGUIStates . SAMPLING_TODO : raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow the preparation of constraints sampling task during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"pending\" status. project_status [ \"state\" ] = ICGUIStates . SAMPLING_PENDING # Prepare status by initializing \"task\" status. project_status [ \"task\" ] = { \"progression\" : 1 , \"detail\" : \"Waiting for background task allocation...\" , } ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) ### ### Launch backgroundtask. ### # Add the background task. background_tasks . add_task ( func = backgroundtasks . run_constraints_sampling_task , project_id = project_id , ) # Return statement. return { # pragma: no cover (need radis and worder) \"project_id\" : project_id , \"detail\" : \"In project with id ' {project_id_str} ', the constraints sampling task has been requested and is waiting for a background task.\" . format ( project_id_str = str ( project_id ), ), }","title":"prepare_constraints_sampling_task()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.prepare_modelization_update_task","text":"Prepare modelization update task. Parameters: Name Type Description Default background_tasks BackgroundTasks A background task to run after the return statement. required project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow the preparation of modelization update task. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the confirmation of the preparation of modelization update task. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 @app . post ( \"/api/projects/ {project_id} /modelization\" , tags = [ \"Data modelization\" ], status_code = status . HTTP_202_ACCEPTED , ) async def prepare_modelization_update_task ( background_tasks : BackgroundTasks , project_id : str = Path ( ... , description = \"The ID of the project.\" , ), ) -> Dict [ str , Any ]: \"\"\" Prepare modelization update task. Args: background_tasks (BackgroundTasks): A background task to run after the return statement. project_id (str): The ID of the project. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow the preparation of modelization update task. Returns: Dict[str, Any]: A dictionary that contains the confirmation of the preparation of modelization update task. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) ### ### Check parameters. ### # Check status. if ( project_status [ \"state\" ] != ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow the preparation of modelization update task during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"pending\" status. if project_status [ \"state\" ] == ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . INITIALIZATION_WITH_PENDING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_PENDING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_PENDING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: else : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS # Prepare status by initializing \"task\" status. project_status [ \"task\" ] = { \"progression\" : 1 , \"detail\" : \"Waiting for background task allocation...\" , } ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) ### ### Launch backgroundtask. ### # Add the background task. background_tasks . add_task ( func = backgroundtasks . run_modelization_update_task , project_id = project_id , ) # Return statement. return { # pragma: no cover (need radis and worder) \"project_id\" : project_id , \"detail\" : \"In project with id ' {project_id_str} ', the modelization update task has been requested and is waiting for a background task.\" . format ( project_id_str = str ( project_id ), ), }","title":"prepare_modelization_update_task()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.prometheus_disk_usage","text":"Define a metric of disk usage. Returns: Type Description Callable [[ metrics . Info ], None] Callable[[metrics.Info], None]: instrumentation. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def prometheus_disk_usage () -> Callable [[ metrics . Info ], None ]: \"\"\" Define a metric of disk usage. Returns: Callable[[metrics.Info], None]: instrumentation. \"\"\" gaugemetric = Gauge ( \"disk_usage\" , \"The disk usage in %\" , ) def instrumentation ( info : metrics . Info ) -> None : # noqa: WPS430 (nested function) total , used , _ = shutil . disk_usage ( DATA_DIRECTORY ) gaugemetric . set ( used * 100 / total ) return instrumentation","title":"prometheus_disk_usage()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.ready","text":"Tell if the API is ready. Returns: Type Description Response An HTTP response with either 200 or 503 codes. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 @app . get ( \"/ready\" , tags = [ \"app state\" ], status_code = status . HTTP_200_OK , ) async def ready () -> Response : # pragma: no cover \"\"\" Tell if the API is ready. Returns: An HTTP response with either 200 or 503 codes. \"\"\" # Return 200_OK if ready. if app . state . ready : return Response ( status_code = status . HTTP_200_OK ) # Return 503_SERVICE_UNAVAILABLE otherwise. return Response ( status_code = status . HTTP_503_SERVICE_UNAVAILABLE )","title":"ready()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.rename_text","text":"Rename a text. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') text_id str The ID of the text. Path(Ellipsis, description='The ID of the text.') text_value str The new value of the text. Query(Ellipsis, description='The new value of the text.', min_length=3, max_length=256) Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the text with id text_id to rename doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow modification. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of renamed text. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 @app . put ( \"/api/projects/ {project_id} /texts/ {text_id} /rename\" , tags = [ \"Texts\" ], status_code = status . HTTP_202_ACCEPTED , ) async def rename_text ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), text_id : str = Path ( ... , description = \"The ID of the text.\" , ), text_value : str = Query ( ... , description = \"The new value of the text.\" , min_length = 3 , max_length = 256 , ), ) -> Dict [ str , Any ]: \"\"\" Rename a text. Args: project_id (str): The ID of the project. text_id (str): The ID of the text. text_value (str): The new value of the text. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the text with id `text_id` to rename doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow modification. Returns: Dict[str, Any]: A dictionary that contains the ID of renamed text. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Load texts file. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"r\" ) as texts_fileobject_r : texts : Dict [ str , Any ] = json . load ( texts_fileobject_r ) ### ### Check parameters. ### # Check text id. if text_id not in texts . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"In project with id ' {project_id_str} ', the text with id ' {text_id_str} ' to rename doesn't exist.\" . format ( project_id_str = str ( project_id ), text_id_str = str ( text_id ), ), ) # Check status. if ( project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow modification during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"outdated\" status. if project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS # Update texts by renaming the new text. texts [ text_id ][ \"text\" ] = text_value ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Store updated texts in file. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"w\" ) as texts_fileobject_w : json . dump ( texts , texts_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"text_id\" : text_id , \"text_value\" : text_value , \"detail\" : \"In project with id ' {project_id_str} ', the text with id ' {text_id_str} ' has been renamed.\" . format ( project_id_str = str ( project_id ), text_id_str = str ( text_id ), ), }","title":"rename_text()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.review_constraint","text":"Review a constraint. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') constraint_id str The ID of the constraint. Path(Ellipsis, description='The ID of the constraint.') to_review str The choice to review or not the constraint. Defaults to True . Query(True, description='The choice to review or not the constraint. Defaults to `True`.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the constraint with id constraint_id to annotate doesn't exist. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of reviewed constraint. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 @app . put ( \"/api/projects/ {project_id} /constraints/ {constraint_id} /review\" , tags = [ \"Constraints\" ], status_code = status . HTTP_202_ACCEPTED , ) async def review_constraint ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), constraint_id : str = Path ( ... , description = \"The ID of the constraint.\" , ), to_review : bool = Query ( True , description = \"The choice to review or not the constraint. Defaults to `True`.\" , ), ) -> Dict [ str , Any ]: \"\"\" Review a constraint. Args: project_id (str): The ID of the project. constraint_id (str): The ID of the constraint. to_review (str): The choice to review or not the constraint. Defaults to `True`. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the constraint with id `constraint_id` to annotate doesn't exist. Returns: Dict[str, Any]: A dictionary that contains the ID of reviewed constraint. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load constraints file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Any ] = json . load ( constraints_fileobject_r ) ### ### Check parameters. ### # Check constraint id. if constraint_id not in constraints . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"In project with id ' {project_id_str} ', the constraint with id ' {constraint_id_str} ' to annotate doesn't exist.\" . format ( project_id_str = str ( project_id ), constraint_id_str = str ( constraint_id ), ), ) ### ### Update data. ### # Update constraints by reviewing the constraint. constraints [ constraint_id ][ \"to_review\" ] = to_review ### ### Store updated data. ### # Store updated constraints in file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"constraint_id\" : constraint_id , \"detail\" : \"In project with id ' {project_id_str} ', the constraint with id ' {constraint_id_str} ' {review_conclusion} .\" . format ( project_id_str = str ( project_id ), constraint_id_str = str ( constraint_id ), review_conclusion = \"need a review\" if ( to_review ) else \"has been reviewed\" , ), }","title":"review_constraint()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.startup","text":"Startup event. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 227 228 229 230 231 232 233 234 235 236 237 @app . on_event ( \"startup\" ) async def startup () -> None : # pragma: no cover \"\"\"Startup event.\"\"\" # Initialize ready state. app . state . ready = False # Apply database connection, long loading, etc. # Update ready state when done. app . state . ready = True","title":"startup()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.timestamp_to_date","text":"From timestamp to date. Parameters: Name Type Description Default timestamp float The timstamp to convert. required timezone_str str The time zone. Defaults to \"Europe/Paris\" . 'Europe/Paris' Returns: Name Type Description str str The requested date. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 106 107 108 109 110 111 112 113 114 115 116 117 118 def timestamp_to_date ( timestamp : float , timezone_str : str = \"Europe/Paris\" ) -> str : \"\"\" From timestamp to date. Args: timestamp (float): The timstamp to convert. timezone_str (str, optional): The time zone. Defaults to `\"Europe/Paris\"`. Returns: str: The requested date. \"\"\" timezone = tz . gettz ( timezone_str ) return datetime . fromtimestamp ( timestamp , timezone ) . strftime ( \" %d /%m/%Y\" )","title":"timestamp_to_date()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.timestamp_to_hour","text":"From timestamp to hours. Parameters: Name Type Description Default timestamp float The timstamp to convert. required timezone_str str The time zone. Defaults to \"Europe/Paris\" . 'Europe/Paris' Returns: Name Type Description str str The requested hour. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 125 126 127 128 129 130 131 132 133 134 135 136 137 def timestamp_to_hour ( timestamp : float , timezone_str : str = \"Europe/Paris\" ) -> str : \"\"\" From timestamp to hours. Args: timestamp (float): The timstamp to convert. timezone_str (str, optional): The time zone. Defaults to `\"Europe/Paris\"`. Returns: str: The requested hour. \"\"\" timezone = tz . gettz ( timezone_str ) return datetime . fromtimestamp ( timestamp , timezone ) . strftime ( \"%H:%M:%S\" )","title":"timestamp_to_hour()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.undelete_text","text":"Undelete a text. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') text_id str The ID of the text. Path(Ellipsis, description='The ID of the text.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_404_NOT_FOUND if the text with id text_id to undelete doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the current status of the project doesn't allow modification. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of undeleted text. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 @app . put ( \"/api/projects/ {project_id} /texts/ {text_id} /undelete\" , tags = [ \"Texts\" ], status_code = status . HTTP_202_ACCEPTED , ) async def undelete_text ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), text_id : str = Path ( ... , description = \"The ID of the text.\" , ), ) -> Dict [ str , Any ]: \"\"\" Undelete a text. Args: project_id (str): The ID of the project. text_id (str): The ID of the text. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_404_NOT_FOUND` if the text with id `text_id` to undelete doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the current status of the project doesn't allow modification. Returns: Dict[str, Any]: A dictionary that contains the ID of undeleted text. \"\"\" # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject : project_status : Dict [ str , Any ] = json . load ( status_fileobject ) # Load texts file. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"r\" ) as texts_fileobject_r : texts : Dict [ str , Any ] = json . load ( texts_fileobject_r ) # Load constraints file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Any ] = json . load ( constraints_fileobject_r ) ### ### Check parameters. ### # Check text id. if text_id not in texts . keys (): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"In project with id ' {project_id_str} ', the text with id ' {text_id_str} ' to undelete doesn't exist.\" . format ( project_id_str = str ( project_id ), text_id_str = str ( text_id ), ), ) # Check status. if ( project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The project with id ' {project_id_str} ' doesn't allow modification during this state (state=' {state_str} ').\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) ### ### Update data. ### # Update status by forcing \"outdated\" status. if project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS # Update texts by undeleting the text. texts [ text_id ][ \"is_deleted\" ] = False # Update constraints by unhidding those associated with the undeleted text. for constraint_id , constraint_value in constraints . items (): data_id1 : str = constraint_value [ \"data\" ][ \"id_1\" ] data_id2 : str = constraint_value [ \"data\" ][ \"id_2\" ] if text_id in { data_id1 , data_id2 }: constraints [ constraint_id ][ \"is_hidden\" ] = ( texts [ data_id1 ][ \"is_deleted\" ] is True or texts [ data_id2 ][ \"is_deleted\" ] is True ) ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Store updated texts in file. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"w\" ) as texts_fileobject_w : json . dump ( texts , texts_fileobject_w , indent = 4 ) # Store updated constraints in file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) # Return statement. return { \"project_id\" : project_id , \"text_id\" : text_id , \"detail\" : \"In project with id ' {project_id_str} ', the text with id ' {text_id_str} ' has been undeleted. Several constraints have been unhidden.\" . format ( project_id_str = str ( project_id ), text_id_str = str ( text_id ), ), }","title":"undelete_text()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/app/#cognitivefactory.interactive_clustering_gui.app.update_settings","text":"Update settings. Parameters: Name Type Description Default project_id str The ID of the project. Path(Ellipsis, description='The ID of the project.') preprocessing Optional [ PreprocessingSettingsModel ] The settings for data preprocessing. Used during clustering step. Keep unchanged if empty.. Defaults to None. Body(None, description='The settings for data preprocessing. Used during `modelization_update` task. Keep unchanged if empty.') vectorization Optional [ VectorizationSettingsModel ] The settings for data vectorization. Used during clustering step. Keep unchanged if empty.. Defaults to None. Body(None, description='The settings for data vectorization. Used during `modelization_update` task. Keep unchanged if empty.') sampling Optional [ SamplingSettingsModel ] The settings for constraints sampling. Used during sampling step. Keep unchanged if empty.. Defaults to None. Body(None, description='The settings for constraints sampling. Used during `constraints_sampling` task. Keep unchanged if empty.') clustering Optional [ ClusteringSettingsModel ] The settings for constrained clustering. Used during clustering step. Keep unchanged if empty. Defaults to None. Body(None, description='The settings for constrained clustering. Used during `constrained_clustering` task. Keep unchanged if empty.') Raises: Type Description HTTPException Raises HTTP_404_NOT_FOUND if the project with id project_id doesn't exist. HTTPException Raises HTTP_403_FORBIDDEN if the status of the project doesn't allow settings modifications. HTTPException Raises HTTP_403_FORBIDDEN if parameters preprocessing , vectorization , sampling or clustering are not expected. HTTPException Raises HTTP_400_BAD_REQUEST if parameters preprocessing , vectorization , sampling or clustering are invalid. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains the ID of updated settings. Source code in cognitivefactory\\interactive_clustering_gui\\app.py 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 @app . put ( \"/api/projects/ {project_id} /settings\" , tags = [ \"Settings\" ], status_code = status . HTTP_201_CREATED , ) async def update_settings ( project_id : str = Path ( ... , description = \"The ID of the project.\" , ), preprocessing : Optional [ PreprocessingSettingsModel ] = Body ( None , description = \"The settings for data preprocessing. Used during `modelization_update` task. Keep unchanged if empty.\" , ), vectorization : Optional [ VectorizationSettingsModel ] = Body ( None , description = \"The settings for data vectorization. Used during `modelization_update` task. Keep unchanged if empty.\" , ), sampling : Optional [ SamplingSettingsModel ] = Body ( None , description = \"The settings for constraints sampling. Used during `constraints_sampling` task. Keep unchanged if empty.\" , ), clustering : Optional [ ClusteringSettingsModel ] = Body ( None , description = \"The settings for constrained clustering. Used during `constrained_clustering` task. Keep unchanged if empty.\" , ), ) -> Dict [ str , Any ]: \"\"\" Update settings. Args: project_id (str): The ID of the project. preprocessing (Optional[PreprocessingSettingsModel], optional): The settings for data preprocessing. Used during `clustering` step. Keep unchanged if empty.. Defaults to None. vectorization (Optional[VectorizationSettingsModel], optional): The settings for data vectorization. Used during `clustering` step. Keep unchanged if empty.. Defaults to None. sampling (Optional[SamplingSettingsModel], optional): The settings for constraints sampling. Used during `sampling` step. Keep unchanged if empty.. Defaults to None. clustering (Optional[ClusteringSettingsModel], optional): The settings for constrained clustering. Used during `clustering` step. Keep unchanged if empty. Defaults to None. Raises: HTTPException: Raises `HTTP_404_NOT_FOUND` if the project with id `project_id` doesn't exist. HTTPException: Raises `HTTP_403_FORBIDDEN` if the status of the project doesn't allow settings modifications. HTTPException: Raises `HTTP_403_FORBIDDEN` if parameters `preprocessing`, `vectorization`, `sampling` or `clustering` are not expected. HTTPException: Raises `HTTP_400_BAD_REQUEST` if parameters `preprocessing`, `vectorization`, `sampling` or `clustering` are invalid. Returns: Dict[str, Any]: A dictionary that contains the ID of updated settings. \"\"\" # TODO: examples: https://fastapi.tiangolo.com/tutorial/schema-extra-example/#body-with-multiple-examples # Check project id. if project_id not in ( await get_projects ()): raise HTTPException ( status_code = status . HTTP_404_NOT_FOUND , detail = \"The project with id ' {project_id_str} ' doesn't exist.\" . format ( project_id_str = str ( project_id ), ), ) # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) iteration_id : int = project_status [ \"iteration_id\" ] # Load settings file. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject_r : project_settings : Dict [ str , Any ] = json . load ( settings_fileobject_r ) list_of_updated_settings : List [ ICGUISettings ] = [] ### ### Case of preprocessing settings. ### if preprocessing is not None : list_of_updated_settings . append ( ICGUISettings . PREPROCESSING ) # Check project status for preprocessing. if ( project_status [ \"state\" ] != ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The 'preprocessing' settings of project with id ' {project_id_str} ' cant't be modified during this state (state=' {state_str} '). No changes have been taken into account.\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) # Update status by forcing \"outdated\" status. if project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.INITIALIZATION_WITHOUT_MODELIZATION: #### project_status[\"state\"] = ICGUIStates.INITIALIZATION_WITHOUT_MODELIZATION # Update the default settings with the parameters in the request body. for key_prep , value_prep in preprocessing . to_dict () . items (): project_settings [ str ( iteration_id )][ \"preprocessing\" ][ key_prep ] = value_prep ### ### Case of vectorization settings. ### if vectorization is not None : list_of_updated_settings . append ( ICGUISettings . VECTORIZATION ) # Check project status for vectorization. if ( project_status [ \"state\" ] != ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The 'vectorization' settings of project with id ' {project_id_str} ' cant't be modified during this state (state=' {state_str} '). No changes have been taken into account.\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) # Update status by forcing \"outdated\" status. if project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : project_status [ \"state\" ] = ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS: #### project_status[\"state\"] = ICGUIStates.ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS #### elif project_status[\"state\"] == ICGUIStates.INITIALIZATION_WITHOUT_MODELIZATION: #### project_status[\"state\"] = ICGUIStates.INITIALIZATION_WITHOUT_MODELIZATION # Update the default settings with the parameters in the request body. for key_vect , value_vect in vectorization . to_dict () . items (): project_settings [ str ( iteration_id )][ \"vectorization\" ][ key_vect ] = value_vect ### ### Case of sampling settings. ### if sampling is not None : list_of_updated_settings . append ( ICGUISettings . SAMPLING ) # Check project status for sampling. if project_status [ \"state\" ] != ICGUIStates . SAMPLING_TODO : raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The 'sampling' settings of project with id ' {project_id_str} ' cant't be modified during this state (state=' {state_str} '). No changes have been taken into account.\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) # Update the default settings with the parameters in the request body. for key_sampl , value_sampl in sampling . to_dict () . items (): project_settings [ str ( iteration_id )][ \"sampling\" ][ key_sampl ] = value_sampl ### ### Case of clustering settings. ### if clustering is not None : list_of_updated_settings . append ( ICGUISettings . CLUSTERING ) # Check project status for clustering. if ( project_status [ \"state\" ] != ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION # noqa: WPS514 and project_status [ \"state\" ] != ICGUIStates . INITIALIZATION_WITH_PENDING_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . INITIALIZATION_WITH_WORKING_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . SAMPLING_TODO and project_status [ \"state\" ] != ICGUIStates . SAMPLING_PENDING and project_status [ \"state\" ] != ICGUIStates . SAMPLING_WORKING and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS and project_status [ \"state\" ] != ICGUIStates . CLUSTERING_TODO ): raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN , detail = \"The 'clustering' settings of project with id ' {project_id_str} ' cant't be modified during this state (state=' {state_str} '). No changes have been taken into account.\" . format ( project_id_str = str ( project_id ), state_str = str ( project_status [ \"state\" ]), ), ) # Update the default settings with the parameters in the request body. for key_clus , value_clus in clustering . to_dict () . items (): project_settings [ str ( iteration_id )][ \"clustering\" ][ key_clus ] = value_clus ### ### Store updated data. ### # Store updated status in file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 ) # Store updated settings in file. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"w\" ) as settings_fileobject_w : json . dump ( project_settings , settings_fileobject_w , indent = 4 ) ### ### Return statement. ### return { \"project_id\" : project_id , \"detail\" : \"The project with id ' {project_id_str} ' has updated the following settings: {settings_str} .\" . format ( project_id_str = str ( project_id ), settings_str = \", \" . join ( list_of_updated_settings ), ), }","title":"update_settings()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/backgroundtasks/","text":"Name: cognitivefactory.interactive_clustering_gui.backgroundtasks Description: Definition of bakgroundtasks for interactive clustering graphical user interface. Author: Erwan Schild Created: 22/10/2021 Licence: CeCILL-C License v1.0 ( https://cecill.info/licences.fr.html ) get_projects () \u00b6 Get the list of existing project IDs. (A project is represented by a subfolder in .data folder.) Returns: Type Description List [ str ] List[str]: The list of existing project IDs. Source code in cognitivefactory\\interactive_clustering_gui\\backgroundtasks.py 60 61 62 63 64 65 66 67 68 69 70 def get_projects () -> List [ str ]: \"\"\" Get the list of existing project IDs. (A project is represented by a subfolder in `.data` folder.) Returns: List[str]: The list of existing project IDs. \"\"\" # Return the list of project IDs. return [ project_id for project_id in os . listdir ( DATA_DIRECTORY ) if os . path . isdir ( DATA_DIRECTORY / project_id )] run_constrained_clustering_task ( project_id ) \u00b6 Background task for constraints clustering task. It performs the following actions : constrained clustering. Parameters: Name Type Description Default project_id str The ID of the project. required Source code in cognitivefactory\\interactive_clustering_gui\\backgroundtasks.py 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 def run_constrained_clustering_task ( project_id : str , ) -> None : \"\"\" Background task for constraints clustering task. It performs the following actions : constrained clustering. Args: project_id (str): The ID of the project. \"\"\" ### ### Check parameters. ### # Check project id : Case of unknown. if project_id not in get_projects (): return # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) # Check project status. if project_status [ \"state\" ] != ICGUIStates . CLUSTERING_PENDING : return # Update status. update_project_status ( project_id = project_id , task_progression = 5 , task_detail = \"Lock the project for constrained clustering step.\" , state = ICGUIStates . CLUSTERING_WORKING , ) # Get current iteration. iteration_id : int = project_status [ \"iteration_id\" ] ### ### Settings loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 10 , task_detail = \"Load settings.\" , ) # Load settings file. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject : settings : Dict [ str , Any ] = json . load ( settings_fileobject ) ### ### Constraints manager loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 20 , task_detail = \"Load constraints manager.\" , ) # Load constraints manager. with open ( DATA_DIRECTORY / project_id / \"constraints_manager.pkl\" , \"rb\" ) as constraints_manager_fileobject : constraints_manager : BinaryConstraintsManager = pickle . load ( # noqa: S301 # Usage of Pickle constraints_manager_fileobject ) ### ### Vectors loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 30 , task_detail = \"Load vectors.\" , ) # Load vectors. with open ( DATA_DIRECTORY / project_id / \"vectors.pkl\" , \"rb\" ) as vectors_fileobject : dict_of_managed_vectors : Dict [ str , csr_matrix ] = pickle . load ( # noqa: S301 # Usage of Pickle vectors_fileobject ) ### ### Clustering model initialization. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 40 , task_detail = \"Initialize clustering model.\" , ) # Initialize clustering model. kwargs_clustering_init : Dict [ str , Any ] = ( { key : value for key , value in settings [ str ( iteration_id )][ \"clustering\" ][ \"init_kargs\" ] . items () if value is not None } if ( settings [ str ( iteration_id )][ \"clustering\" ][ \"init_kargs\" ] is not None ) else {} ) clustering_model : AbstractConstrainedClustering = clustering_factory ( algorithm = settings [ str ( iteration_id )][ \"clustering\" ][ \"algorithm\" ], random_seed = settings [ str ( iteration_id )][ \"clustering\" ][ \"random_seed\" ], ** kwargs_clustering_init , ) ### ### Constrained clustering. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 50 , task_detail = \"Run constrained clustering.\" , ) # Run constrained clustering. clustering_result : Dict [ str , int ] = clustering_model . cluster ( constraints_manager = constraints_manager , vectors = dict_of_managed_vectors , nb_clusters = settings [ str ( iteration_id )][ \"clustering\" ][ \"nb_clusters\" ], ) ### ### Clustering results storage. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 90 , task_detail = \"Store clustering results.\" , ) # Load clustering results file. with open ( DATA_DIRECTORY / project_id / \"clustering.json\" , \"r\" ) as clustering_fileobject_r : history_of_clustering_results : Dict [ str , Dict [ str , int ]] = json . load ( clustering_fileobject_r ) # Update clustering results. history_of_clustering_results [ str ( iteration_id )] = clustering_result # Store clustering results. with open ( DATA_DIRECTORY / project_id / \"clustering.json\" , \"w\" ) as clustering_fileobject_w : json . dump ( history_of_clustering_results , clustering_fileobject_w , indent = 4 , ) ### ### End of task. ### # Lock status file in order to update project status. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = None , task_detail = None , state = ICGUIStates . ITERATION_END , ) run_constraints_sampling_task ( project_id ) \u00b6 Background task route for constraints sampling task. It performs the following actions : constraints sampling. Parameters: Name Type Description Default project_id str The ID of the project. required Source code in cognitivefactory\\interactive_clustering_gui\\backgroundtasks.py 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 def run_constraints_sampling_task ( project_id : str , ) -> None : \"\"\" Background task route for constraints sampling task. It performs the following actions : constraints sampling. Args: project_id (str): The ID of the project. \"\"\" ### ### Check parameters. ### # Check project id : Case of unknown. if project_id not in get_projects (): return # Lock status file in order to check project iteration and project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) # Check project status. if project_status [ \"state\" ] != ICGUIStates . SAMPLING_PENDING : return # Update status. update_project_status ( project_id = project_id , task_progression = 5 , task_detail = \"Lock the project for constraints sampling step.\" , state = ICGUIStates . SAMPLING_WORKING , ) # Get current iteration. iteration_id : int = project_status [ \"iteration_id\" ] ### ### Settings loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 10 , task_detail = \"Load settings.\" , ) # Load settings file. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject : settings : Dict [ str , Any ] = json . load ( settings_fileobject ) # Get previous iteration id. previous_iteration_id : int = iteration_id - 1 ### ### Constraints manager loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 20 , task_detail = \"Load constraints manager.\" , ) # Load constraints manager. with open ( DATA_DIRECTORY / project_id / \"constraints_manager.pkl\" , \"rb\" ) as constraints_manager_fileobject : constraints_manager : BinaryConstraintsManager = pickle . load ( # noqa: S301 # Usage of Pickle constraints_manager_fileobject ) ### ### Clustering results loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 30 , task_detail = \"Load previous clustering results.\" , ) # Get previous clustering result. with open ( DATA_DIRECTORY / project_id / \"clustering.json\" , \"r\" ) as clustering_fileobject : clustering_results_for_previous_iteration : Dict [ str , int ] = json . load ( clustering_fileobject )[ str ( previous_iteration_id ) ] ### ### Vectors loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 40 , task_detail = \"Load vectors.\" , ) # Load vectors. with open ( DATA_DIRECTORY / project_id / \"vectors.pkl\" , \"rb\" ) as vectors_fileobject : dict_of_managed_vectors : Dict [ str , csr_matrix ] = pickle . load ( # noqa: S301 # Usage of Pickle vectors_fileobject ) ### ### Constraints sampling initialization. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 50 , task_detail = \"Initialize constraints sampler.\" , ) # Initialize constraints sampler. kwargs_sampling_init : Dict [ str , Any ] = ( { key : value for key , value in settings [ str ( iteration_id )][ \"sampling\" ][ \"init_kargs\" ] . items () if value is not None } if ( settings [ str ( iteration_id )][ \"sampling\" ][ \"init_kargs\" ] is not None ) else {} ) sampler : AbstractConstraintsSampling = ( ClustersBasedConstraintsSampling ( ** kwargs_sampling_init ) if ( settings [ str ( iteration_id )][ \"sampling\" ][ \"algorithm\" ] == \"custom\" ) else sampling_factory ( algorithm = settings [ str ( iteration_id )][ \"sampling\" ][ \"algorithm\" ], random_seed = settings [ str ( iteration_id )][ \"sampling\" ][ \"random_seed\" ], ** kwargs_sampling_init , ) ) ### ### Constraints sampling. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 60 , task_detail = \"Sample {nb} pairs of texts to annotate.\" . format ( nb = str ( settings [ str ( iteration_id )][ \"sampling\" ][ \"nb_to_select\" ]) ), ) # Sample pairs of data to annotate. sampling_result : List [ Tuple [ str , str ]] = sampler . sample ( constraints_manager = constraints_manager , nb_to_select = settings [ str ( iteration_id )][ \"sampling\" ][ \"nb_to_select\" ], clustering_result = clustering_results_for_previous_iteration , vectors = dict_of_managed_vectors , ) # If needed: complete with some random pairs of data IDs. if len ( sampling_result ) < settings [ str ( iteration_id )][ \"sampling\" ][ \"nb_to_select\" ]: with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 75 , task_detail = \"Need to complete with {nb} random pairs of texts.\" . format ( nb = str ( settings [ str ( iteration_id )][ \"sampling\" ][ \"nb_to_select\" ] - len ( sampling_result )) ), ) sampling_result += [ random_sample for random_sample in sampling_factory ( algorithm = \"random\" , random_seed = settings [ str ( iteration_id )][ \"sampling\" ][ \"random_seed\" ], ) . sample ( constraints_manager = constraints_manager , nb_to_select = settings [ str ( iteration_id )][ \"sampling\" ][ \"nb_to_select\" ] - len ( sampling_result ), ) if random_sample not in sampling_result ] ### ### Sampling results storage. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 90 , task_detail = \"Store sampling results and prepapre annotations.\" , ) # Load sampling results file. with open ( DATA_DIRECTORY / project_id / \"sampling.json\" , \"r\" ) as sampling_fileobject_r : sampling_results : Dict [ str , List [ str ]] = json . load ( sampling_fileobject_r ) # Load constraints file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Dict [ str , Any ]] = json . load ( constraints_fileobject_r ) # Initialize sampling result for this iteration. sampling_results [ str ( iteration_id )] = [] # For all sampling to annotate... for ( data_ID1 , data_ID2 ) in sampling_result : # Define sampling id. constraint_id : str = \"( {data_ID1_str} , {data_ID2_str} )\" . format ( data_ID1_str = data_ID1 , data_ID2_str = data_ID2 , ) # Add sampling id. sampling_results [ str ( iteration_id )] . append ( constraint_id ) # Update constraints if not already known. if constraint_id not in constraints . keys (): constraints [ constraint_id ] = { \"data\" : { \"id_1\" : data_ID1 , \"id_2\" : data_ID2 , }, \"constraint_type\" : None , \"constraint_type_previous\" : [], \"is_hidden\" : False , # if text is deleted. \"to_annotate\" : False , \"to_review\" : False , \"to_fix_conflict\" : False , \"comment\" : \"\" , \"date_of_update\" : None , \"iteration_of_sampling\" : iteration_id , } constraints [ constraint_id ][ \"to_annotate\" ] = True # Store sampling results. with open ( DATA_DIRECTORY / project_id / \"sampling.json\" , \"w\" ) as sampling_fileobject_w : json . dump ( sampling_results , sampling_fileobject_w , indent = 4 , ) # Store constraints results. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 , ) ### ### End of task. ### # Lock status file in order to update project status. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = None , task_detail = None , state = ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION , ) run_modelization_update_task ( project_id ) \u00b6 Background task route for modelization update. It performs the following actions : texts propressing, texts vectorization, constraints manager update. Emit message to share progress, raise error and announce success. Parameters: Name Type Description Default project_id str The ID of the project. required Source code in cognitivefactory\\interactive_clustering_gui\\backgroundtasks.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 def run_modelization_update_task ( project_id : str , ) -> None : \"\"\" Background task route for modelization update. It performs the following actions : texts propressing, texts vectorization, constraints manager update. Emit message to share progress, raise error and announce success. Args: project_id (str): The ID of the project. \"\"\" ### ### Check parameters. ### # Check project id : Case of unknown. if project_id not in get_projects (): return # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) ### ### Check parameters. ### # Check project status. working_state : Optional [ ICGUIStates ] = None if project_status [ \"state\" ] == ICGUIStates . INITIALIZATION_WITH_PENDING_MODELIZATION : working_state = ICGUIStates . INITIALIZATION_WITH_WORKING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION : working_state = ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_PENDING_MODELIZATION : working_state = ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_WORKING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_PENDING_MODELIZATION : working_state = ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_WORKING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION : working_state = ICGUIStates . IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS : working_state = ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS elif project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS : working_state = ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS else : return # Update status. update_project_status ( project_id = project_id , task_progression = 5 , task_detail = \"Lock the project for modelization update step.\" , state = working_state , ) # Get current iteration. iteration_id : int = project_status [ \"iteration_id\" ] ### ### Settings loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 10 , task_detail = \"Load settings.\" , ) # Load settings file. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject : settings : Dict [ str , Any ] = json . load ( settings_fileobject ) ### ### Texts loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 15 , task_detail = \"Load texts.\" , ) # Load texts with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"r\" ) as texts_fileobject_r : texts : Dict [ str , Any ] = json . load ( texts_fileobject_r ) ### ### Texts preprocessing. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 20 , task_detail = \"Preprocess texts.\" , ) # Get all unpreprocessed texts. dict_of_unpreprocessed_texts : Dict [ str , str ] = { text_id_before_preprocessing : text_value_before_preprocessing [ \"text\" ] for text_id_before_preprocessing , text_value_before_preprocessing in texts . items () } # Preprocess all texts (even if text is deleted). dict_of_preprocessed_texts : Dict [ str , str ] = preprocess ( dict_of_texts = dict_of_unpreprocessed_texts , apply_stopwords_deletion = settings [ str ( iteration_id )][ \"preprocessing\" ][ \"apply_stopwords_deletion\" ], apply_parsing_filter = settings [ str ( iteration_id )][ \"preprocessing\" ][ \"apply_parsing_filter\" ], apply_lemmatization = settings [ str ( iteration_id )][ \"preprocessing\" ][ \"apply_lemmatization\" ], spacy_language_model = settings [ str ( iteration_id )][ \"preprocessing\" ][ \"spacy_language_model\" ], ) # Update texts with preprocessed values. for text_id_with_preprocessing in texts . keys (): texts [ text_id_with_preprocessing ][ \"text_preprocessed\" ] = dict_of_preprocessed_texts [ text_id_with_preprocessing ] # Store texts. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"w\" ) as texts_fileobject_w : json . dump ( texts , texts_fileobject_w , indent = 4 , ) ### ### Texts vectorization. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 35 , task_detail = \"Vectorize texts.\" , ) # Get managed preprocessed texts. dict_of_managed_preprocessed_texts : Dict [ str , str ] = { text_id_before_vectorization : text_value_before_vectorization [ \"text_preprocessed\" ] for text_id_before_vectorization , text_value_before_vectorization in texts . items () if text_value_before_vectorization [ \"is_deleted\" ] is False } # Vectorize texts (only if text is not deleted). dict_of_managed_vectors : Dict [ str , csr_matrix ] = vectorize ( dict_of_texts = dict_of_managed_preprocessed_texts , vectorizer_type = settings [ str ( iteration_id )][ \"vectorization\" ][ \"vectorizer_type\" ], spacy_language_model = settings [ str ( iteration_id )][ \"vectorization\" ][ \"spacy_language_model\" ], ) # Store vectors. with open ( DATA_DIRECTORY / project_id / \"vectors.pkl\" , \"wb\" ) as vectors_fileobject : pickle . dump ( dict_of_managed_vectors , vectors_fileobject , pickle . HIGHEST_PROTOCOL , ) # Convert vectors into matrix. vectors_ND : csr_matrix = vstack ( dict_of_managed_vectors [ text_id_with_ND ] for text_id_with_ND in dict_of_managed_vectors . keys () ) ### ### Texts vectorization in 2D. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 50 , task_detail = \"Reduce vectors to 2 dimensions.\" , ) # Reduce vectors to 2 dimensions with TSNE. vectors_2D : ndarray = TSNE ( n_components = 2 , # learning_rate=\"auto\", # Error on \"scikit-learn==0.24.1\" ! init = \"random\" , random_state = settings [ str ( iteration_id )][ \"vectorization\" ][ \"random_seed\" ], ) . fit_transform ( vectors_ND ) # Store 2D vectors. with open ( DATA_DIRECTORY / project_id / \"vectors_2D.json\" , \"w\" ) as vectors_2D_fileobject : json . dump ( { text_id_with_2D : { \"x\" : float ( vectors_2D [ i_2D ][ 0 ]), \"y\" : float ( vectors_2D [ i_2D ][ 1 ]), } for i_2D , text_id_with_2D in enumerate ( dict_of_managed_vectors . keys ()) }, vectors_2D_fileobject , indent = 4 , ) ### ### Texts vectorization in 3D. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 65 , task_detail = \"Reduce vectors to 3 dimensions.\" , ) # Reduce vectors to 3 dimensions with TSNE. vectors_3D : ndarray = TSNE ( n_components = 3 , # learning_rate=\"auto\", # Error on \"scikit-learn==0.24.1\" ! init = \"random\" , random_state = settings [ str ( iteration_id )][ \"vectorization\" ][ \"random_seed\" ], ) . fit_transform ( vectors_ND ) # Store 3D vectors. with open ( DATA_DIRECTORY / project_id / \"vectors_3D.json\" , \"w\" ) as vectors_3D_fileobject : json . dump ( { text_id_with_3D : { \"x\" : float ( vectors_3D [ i_3D ][ 0 ]), \"y\" : float ( vectors_3D [ i_3D ][ 1 ]), \"z\" : float ( vectors_3D [ i_3D ][ 2 ]), } for i_3D , text_id_with_3D in enumerate ( dict_of_managed_vectors . keys ()) }, vectors_3D_fileobject , indent = 4 , ) ### ### Constraints manager regeneration. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 80 , task_detail = \"(Re)generate constraints manager.\" , ) # Initialize constraints manager with managed texts IDs. new_constraints_manager : BinaryConstraintsManager = BinaryConstraintsManager ( list_of_data_IDs = list ( dict_of_managed_preprocessed_texts . keys ()) ) # Load annotated constraints. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Any ] = json . load ( constraints_fileobject_r ) # First, reset `to_fix_conflict` status of all constraints. for constraint_id in constraints . keys (): constraints [ constraint_id ][ \"to_fix_conflict\" ] = False # Then, update constraints manager with \"CANNOT_LINK\" constraints. for _ , constraint_CL in constraints . items (): if constraint_CL [ \"constraint_type\" ] == \"CANNOT_LINK\" and constraint_CL [ \"is_hidden\" ] is False : new_constraints_manager . add_constraint ( data_ID1 = constraint_CL [ \"data\" ][ \"id_1\" ], data_ID2 = constraint_CL [ \"data\" ][ \"id_2\" ], constraint_type = \"CANNOT_LINK\" , ) # No conflict can append, at this step the constraints manager handle only constraints of same type. # Initialize conflicts counter. number_of_conflicts : int = 0 # Finaly, update constraints manager with \"MUST_LINK\" constraints. for constraint_ML_id , constraint_ML in constraints . items (): if constraint_ML [ \"constraint_type\" ] == \"MUST_LINK\" and constraint_ML [ \"is_hidden\" ] is False : try : new_constraints_manager . add_constraint ( data_ID1 = constraint_ML [ \"data\" ][ \"id_1\" ], data_ID2 = constraint_ML [ \"data\" ][ \"id_2\" ], constraint_type = \"MUST_LINK\" , ) # Conflicts can append. except ValueError : # Update conflicts status. constraints [ constraint_ML_id ][ \"to_fix_conflict\" ] = True number_of_conflicts += 1 # Store new constraints manager. with open ( DATA_DIRECTORY / project_id / \"constraints_manager.pkl\" , \"wb\" ) as constraints_manager_fileobject : pickle . dump ( new_constraints_manager , constraints_manager_fileobject , pickle . HIGHEST_PROTOCOL , ) # Store updated constraints in file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) ### ### Store modelization inference. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 95 , task_detail = \"Store modelization inference results.\" , ) # Load modelization inference file. with open ( DATA_DIRECTORY / project_id / \"modelization.json\" , \"r\" ) as modelization_fileobject_r : modelization : Dict [ str , Any ] = json . load ( modelization_fileobject_r ) # Get constraints transitivity. constraints_transitivity : Dict [ str , Dict [ str , Dict [ str , None ]] ] = new_constraints_manager . _constraints_transitivity # noqa: WPS437 # Update modelization inference. modelization = {} for text_id_in_manager in new_constraints_manager . get_list_of_managed_data_IDs (): modelization [ text_id_in_manager ] = { \"MUST_LINK\" : list ( constraints_transitivity [ text_id_in_manager ][ \"MUST_LINK\" ] . keys ()), \"CANNOT_LINK\" : list ( constraints_transitivity [ text_id_in_manager ][ \"CANNOT_LINK\" ] . keys ()), } for component_id , component in enumerate ( new_constraints_manager . get_connected_components ()): for text_id_in_component in component : modelization [ text_id_in_component ][ \"COMPONENT\" ] = component_id # Store updated modelization inference in file. with open ( DATA_DIRECTORY / project_id / \"modelization.json\" , \"w\" ) as modelization_fileobject_w : json . dump ( modelization , modelization_fileobject_w , indent = 4 ) ### ### End of task. ### # Define the next state. end_state : Optional [ ICGUIStates ] = None if working_state == ICGUIStates . INITIALIZATION_WITH_WORKING_MODELIZATION : end_state = ( ICGUIStates . CLUSTERING_TODO if ( number_of_conflicts == 0 ) else ICGUIStates . INITIALIZATION_WITH_ERRORS ) elif working_state == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION : end_state = ( ICGUIStates . SAMPLING_TODO if ( number_of_conflicts == 0 ) else ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_ERRORS ) elif working_state == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_WORKING_MODELIZATION : end_state = ( ICGUIStates . CLUSTERING_TODO if ( number_of_conflicts == 0 ) else ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_ERRORS ) elif working_state == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION : end_state = ( ICGUIStates . ITERATION_END if ( number_of_conflicts == 0 ) else ICGUIStates . IMPORT_AT_ITERATION_END_WITH_ERRORS ) #### elif working_state in { #### ICGUIStates.IMPORT_AT_ANNOTATION_STEP_WITH_WORKING_MODELIZATION, #### ICGUIStates.ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS, #### ICGUIStates.ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS, #### }: else : end_state = ( ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION if ( number_of_conflicts == 0 ) else ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ) # Lock status file in order to update project status. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = None , task_detail = None , state = end_state , ) update_project_status ( project_id , task_progression , task_detail , state = None ) \u00b6 Update project status during task. Parameters: Name Type Description Default project_id str The ID of the project. required task_progression Optional [ int ] The progression of the updated task. required task_detail Optional [ str ] The detail of the updated task. required state Optional [ ICGUIStates ] The state of the application. Unchanged if None . Defaults to None . None Source code in cognitivefactory\\interactive_clustering_gui\\backgroundtasks.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def update_project_status ( project_id : str , task_progression : Optional [ int ], task_detail : Optional [ str ], state : Optional [ ICGUIStates ] = None , ) -> None : \"\"\" Update project status during task. Args: project_id (str): The ID of the project. task_progression (Optional[int]): The progression of the updated task. task_detail (Optional[str]): The detail of the updated task. state (Optional[ICGUIStates], optional): The state of the application. Unchanged if `None`. Defaults to `None`. \"\"\" # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) # Update status. project_status [ \"task\" ] = ( { \"progression\" : task_progression , \"detail\" : task_detail , } if ( task_progression is not None ) else None ) project_status [ \"state\" ] = project_status [ \"state\" ] if ( state is None ) else state # Store status. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 , )","title":"backgroundtasks"},{"location":"reference/cognitivefactory/interactive_clustering_gui/backgroundtasks/#cognitivefactory.interactive_clustering_gui.backgroundtasks.get_projects","text":"Get the list of existing project IDs. (A project is represented by a subfolder in .data folder.) Returns: Type Description List [ str ] List[str]: The list of existing project IDs. Source code in cognitivefactory\\interactive_clustering_gui\\backgroundtasks.py 60 61 62 63 64 65 66 67 68 69 70 def get_projects () -> List [ str ]: \"\"\" Get the list of existing project IDs. (A project is represented by a subfolder in `.data` folder.) Returns: List[str]: The list of existing project IDs. \"\"\" # Return the list of project IDs. return [ project_id for project_id in os . listdir ( DATA_DIRECTORY ) if os . path . isdir ( DATA_DIRECTORY / project_id )]","title":"get_projects()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/backgroundtasks/#cognitivefactory.interactive_clustering_gui.backgroundtasks.run_constrained_clustering_task","text":"Background task for constraints clustering task. It performs the following actions : constrained clustering. Parameters: Name Type Description Default project_id str The ID of the project. required Source code in cognitivefactory\\interactive_clustering_gui\\backgroundtasks.py 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 def run_constrained_clustering_task ( project_id : str , ) -> None : \"\"\" Background task for constraints clustering task. It performs the following actions : constrained clustering. Args: project_id (str): The ID of the project. \"\"\" ### ### Check parameters. ### # Check project id : Case of unknown. if project_id not in get_projects (): return # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) # Check project status. if project_status [ \"state\" ] != ICGUIStates . CLUSTERING_PENDING : return # Update status. update_project_status ( project_id = project_id , task_progression = 5 , task_detail = \"Lock the project for constrained clustering step.\" , state = ICGUIStates . CLUSTERING_WORKING , ) # Get current iteration. iteration_id : int = project_status [ \"iteration_id\" ] ### ### Settings loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 10 , task_detail = \"Load settings.\" , ) # Load settings file. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject : settings : Dict [ str , Any ] = json . load ( settings_fileobject ) ### ### Constraints manager loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 20 , task_detail = \"Load constraints manager.\" , ) # Load constraints manager. with open ( DATA_DIRECTORY / project_id / \"constraints_manager.pkl\" , \"rb\" ) as constraints_manager_fileobject : constraints_manager : BinaryConstraintsManager = pickle . load ( # noqa: S301 # Usage of Pickle constraints_manager_fileobject ) ### ### Vectors loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 30 , task_detail = \"Load vectors.\" , ) # Load vectors. with open ( DATA_DIRECTORY / project_id / \"vectors.pkl\" , \"rb\" ) as vectors_fileobject : dict_of_managed_vectors : Dict [ str , csr_matrix ] = pickle . load ( # noqa: S301 # Usage of Pickle vectors_fileobject ) ### ### Clustering model initialization. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 40 , task_detail = \"Initialize clustering model.\" , ) # Initialize clustering model. kwargs_clustering_init : Dict [ str , Any ] = ( { key : value for key , value in settings [ str ( iteration_id )][ \"clustering\" ][ \"init_kargs\" ] . items () if value is not None } if ( settings [ str ( iteration_id )][ \"clustering\" ][ \"init_kargs\" ] is not None ) else {} ) clustering_model : AbstractConstrainedClustering = clustering_factory ( algorithm = settings [ str ( iteration_id )][ \"clustering\" ][ \"algorithm\" ], random_seed = settings [ str ( iteration_id )][ \"clustering\" ][ \"random_seed\" ], ** kwargs_clustering_init , ) ### ### Constrained clustering. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 50 , task_detail = \"Run constrained clustering.\" , ) # Run constrained clustering. clustering_result : Dict [ str , int ] = clustering_model . cluster ( constraints_manager = constraints_manager , vectors = dict_of_managed_vectors , nb_clusters = settings [ str ( iteration_id )][ \"clustering\" ][ \"nb_clusters\" ], ) ### ### Clustering results storage. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 90 , task_detail = \"Store clustering results.\" , ) # Load clustering results file. with open ( DATA_DIRECTORY / project_id / \"clustering.json\" , \"r\" ) as clustering_fileobject_r : history_of_clustering_results : Dict [ str , Dict [ str , int ]] = json . load ( clustering_fileobject_r ) # Update clustering results. history_of_clustering_results [ str ( iteration_id )] = clustering_result # Store clustering results. with open ( DATA_DIRECTORY / project_id / \"clustering.json\" , \"w\" ) as clustering_fileobject_w : json . dump ( history_of_clustering_results , clustering_fileobject_w , indent = 4 , ) ### ### End of task. ### # Lock status file in order to update project status. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = None , task_detail = None , state = ICGUIStates . ITERATION_END , )","title":"run_constrained_clustering_task()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/backgroundtasks/#cognitivefactory.interactive_clustering_gui.backgroundtasks.run_constraints_sampling_task","text":"Background task route for constraints sampling task. It performs the following actions : constraints sampling. Parameters: Name Type Description Default project_id str The ID of the project. required Source code in cognitivefactory\\interactive_clustering_gui\\backgroundtasks.py 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 def run_constraints_sampling_task ( project_id : str , ) -> None : \"\"\" Background task route for constraints sampling task. It performs the following actions : constraints sampling. Args: project_id (str): The ID of the project. \"\"\" ### ### Check parameters. ### # Check project id : Case of unknown. if project_id not in get_projects (): return # Lock status file in order to check project iteration and project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) # Check project status. if project_status [ \"state\" ] != ICGUIStates . SAMPLING_PENDING : return # Update status. update_project_status ( project_id = project_id , task_progression = 5 , task_detail = \"Lock the project for constraints sampling step.\" , state = ICGUIStates . SAMPLING_WORKING , ) # Get current iteration. iteration_id : int = project_status [ \"iteration_id\" ] ### ### Settings loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 10 , task_detail = \"Load settings.\" , ) # Load settings file. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject : settings : Dict [ str , Any ] = json . load ( settings_fileobject ) # Get previous iteration id. previous_iteration_id : int = iteration_id - 1 ### ### Constraints manager loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 20 , task_detail = \"Load constraints manager.\" , ) # Load constraints manager. with open ( DATA_DIRECTORY / project_id / \"constraints_manager.pkl\" , \"rb\" ) as constraints_manager_fileobject : constraints_manager : BinaryConstraintsManager = pickle . load ( # noqa: S301 # Usage of Pickle constraints_manager_fileobject ) ### ### Clustering results loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 30 , task_detail = \"Load previous clustering results.\" , ) # Get previous clustering result. with open ( DATA_DIRECTORY / project_id / \"clustering.json\" , \"r\" ) as clustering_fileobject : clustering_results_for_previous_iteration : Dict [ str , int ] = json . load ( clustering_fileobject )[ str ( previous_iteration_id ) ] ### ### Vectors loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 40 , task_detail = \"Load vectors.\" , ) # Load vectors. with open ( DATA_DIRECTORY / project_id / \"vectors.pkl\" , \"rb\" ) as vectors_fileobject : dict_of_managed_vectors : Dict [ str , csr_matrix ] = pickle . load ( # noqa: S301 # Usage of Pickle vectors_fileobject ) ### ### Constraints sampling initialization. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 50 , task_detail = \"Initialize constraints sampler.\" , ) # Initialize constraints sampler. kwargs_sampling_init : Dict [ str , Any ] = ( { key : value for key , value in settings [ str ( iteration_id )][ \"sampling\" ][ \"init_kargs\" ] . items () if value is not None } if ( settings [ str ( iteration_id )][ \"sampling\" ][ \"init_kargs\" ] is not None ) else {} ) sampler : AbstractConstraintsSampling = ( ClustersBasedConstraintsSampling ( ** kwargs_sampling_init ) if ( settings [ str ( iteration_id )][ \"sampling\" ][ \"algorithm\" ] == \"custom\" ) else sampling_factory ( algorithm = settings [ str ( iteration_id )][ \"sampling\" ][ \"algorithm\" ], random_seed = settings [ str ( iteration_id )][ \"sampling\" ][ \"random_seed\" ], ** kwargs_sampling_init , ) ) ### ### Constraints sampling. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 60 , task_detail = \"Sample {nb} pairs of texts to annotate.\" . format ( nb = str ( settings [ str ( iteration_id )][ \"sampling\" ][ \"nb_to_select\" ]) ), ) # Sample pairs of data to annotate. sampling_result : List [ Tuple [ str , str ]] = sampler . sample ( constraints_manager = constraints_manager , nb_to_select = settings [ str ( iteration_id )][ \"sampling\" ][ \"nb_to_select\" ], clustering_result = clustering_results_for_previous_iteration , vectors = dict_of_managed_vectors , ) # If needed: complete with some random pairs of data IDs. if len ( sampling_result ) < settings [ str ( iteration_id )][ \"sampling\" ][ \"nb_to_select\" ]: with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 75 , task_detail = \"Need to complete with {nb} random pairs of texts.\" . format ( nb = str ( settings [ str ( iteration_id )][ \"sampling\" ][ \"nb_to_select\" ] - len ( sampling_result )) ), ) sampling_result += [ random_sample for random_sample in sampling_factory ( algorithm = \"random\" , random_seed = settings [ str ( iteration_id )][ \"sampling\" ][ \"random_seed\" ], ) . sample ( constraints_manager = constraints_manager , nb_to_select = settings [ str ( iteration_id )][ \"sampling\" ][ \"nb_to_select\" ] - len ( sampling_result ), ) if random_sample not in sampling_result ] ### ### Sampling results storage. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 90 , task_detail = \"Store sampling results and prepapre annotations.\" , ) # Load sampling results file. with open ( DATA_DIRECTORY / project_id / \"sampling.json\" , \"r\" ) as sampling_fileobject_r : sampling_results : Dict [ str , List [ str ]] = json . load ( sampling_fileobject_r ) # Load constraints file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Dict [ str , Any ]] = json . load ( constraints_fileobject_r ) # Initialize sampling result for this iteration. sampling_results [ str ( iteration_id )] = [] # For all sampling to annotate... for ( data_ID1 , data_ID2 ) in sampling_result : # Define sampling id. constraint_id : str = \"( {data_ID1_str} , {data_ID2_str} )\" . format ( data_ID1_str = data_ID1 , data_ID2_str = data_ID2 , ) # Add sampling id. sampling_results [ str ( iteration_id )] . append ( constraint_id ) # Update constraints if not already known. if constraint_id not in constraints . keys (): constraints [ constraint_id ] = { \"data\" : { \"id_1\" : data_ID1 , \"id_2\" : data_ID2 , }, \"constraint_type\" : None , \"constraint_type_previous\" : [], \"is_hidden\" : False , # if text is deleted. \"to_annotate\" : False , \"to_review\" : False , \"to_fix_conflict\" : False , \"comment\" : \"\" , \"date_of_update\" : None , \"iteration_of_sampling\" : iteration_id , } constraints [ constraint_id ][ \"to_annotate\" ] = True # Store sampling results. with open ( DATA_DIRECTORY / project_id / \"sampling.json\" , \"w\" ) as sampling_fileobject_w : json . dump ( sampling_results , sampling_fileobject_w , indent = 4 , ) # Store constraints results. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 , ) ### ### End of task. ### # Lock status file in order to update project status. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = None , task_detail = None , state = ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION , )","title":"run_constraints_sampling_task()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/backgroundtasks/#cognitivefactory.interactive_clustering_gui.backgroundtasks.run_modelization_update_task","text":"Background task route for modelization update. It performs the following actions : texts propressing, texts vectorization, constraints manager update. Emit message to share progress, raise error and announce success. Parameters: Name Type Description Default project_id str The ID of the project. required Source code in cognitivefactory\\interactive_clustering_gui\\backgroundtasks.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 def run_modelization_update_task ( project_id : str , ) -> None : \"\"\" Background task route for modelization update. It performs the following actions : texts propressing, texts vectorization, constraints manager update. Emit message to share progress, raise error and announce success. Args: project_id (str): The ID of the project. \"\"\" ### ### Check parameters. ### # Check project id : Case of unknown. if project_id not in get_projects (): return # Lock status file in order to check project status for this step. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): ### ### Load needed data. ### # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) ### ### Check parameters. ### # Check project status. working_state : Optional [ ICGUIStates ] = None if project_status [ \"state\" ] == ICGUIStates . INITIALIZATION_WITH_PENDING_MODELIZATION : working_state = ICGUIStates . INITIALIZATION_WITH_WORKING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION : working_state = ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_PENDING_MODELIZATION : working_state = ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_WORKING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_PENDING_MODELIZATION : working_state = ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_WORKING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION : working_state = ICGUIStates . IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION elif project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS : working_state = ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS elif project_status [ \"state\" ] == ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS : working_state = ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS else : return # Update status. update_project_status ( project_id = project_id , task_progression = 5 , task_detail = \"Lock the project for modelization update step.\" , state = working_state , ) # Get current iteration. iteration_id : int = project_status [ \"iteration_id\" ] ### ### Settings loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 10 , task_detail = \"Load settings.\" , ) # Load settings file. with open ( DATA_DIRECTORY / project_id / \"settings.json\" , \"r\" ) as settings_fileobject : settings : Dict [ str , Any ] = json . load ( settings_fileobject ) ### ### Texts loading. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 15 , task_detail = \"Load texts.\" , ) # Load texts with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"r\" ) as texts_fileobject_r : texts : Dict [ str , Any ] = json . load ( texts_fileobject_r ) ### ### Texts preprocessing. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 20 , task_detail = \"Preprocess texts.\" , ) # Get all unpreprocessed texts. dict_of_unpreprocessed_texts : Dict [ str , str ] = { text_id_before_preprocessing : text_value_before_preprocessing [ \"text\" ] for text_id_before_preprocessing , text_value_before_preprocessing in texts . items () } # Preprocess all texts (even if text is deleted). dict_of_preprocessed_texts : Dict [ str , str ] = preprocess ( dict_of_texts = dict_of_unpreprocessed_texts , apply_stopwords_deletion = settings [ str ( iteration_id )][ \"preprocessing\" ][ \"apply_stopwords_deletion\" ], apply_parsing_filter = settings [ str ( iteration_id )][ \"preprocessing\" ][ \"apply_parsing_filter\" ], apply_lemmatization = settings [ str ( iteration_id )][ \"preprocessing\" ][ \"apply_lemmatization\" ], spacy_language_model = settings [ str ( iteration_id )][ \"preprocessing\" ][ \"spacy_language_model\" ], ) # Update texts with preprocessed values. for text_id_with_preprocessing in texts . keys (): texts [ text_id_with_preprocessing ][ \"text_preprocessed\" ] = dict_of_preprocessed_texts [ text_id_with_preprocessing ] # Store texts. with open ( DATA_DIRECTORY / project_id / \"texts.json\" , \"w\" ) as texts_fileobject_w : json . dump ( texts , texts_fileobject_w , indent = 4 , ) ### ### Texts vectorization. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 35 , task_detail = \"Vectorize texts.\" , ) # Get managed preprocessed texts. dict_of_managed_preprocessed_texts : Dict [ str , str ] = { text_id_before_vectorization : text_value_before_vectorization [ \"text_preprocessed\" ] for text_id_before_vectorization , text_value_before_vectorization in texts . items () if text_value_before_vectorization [ \"is_deleted\" ] is False } # Vectorize texts (only if text is not deleted). dict_of_managed_vectors : Dict [ str , csr_matrix ] = vectorize ( dict_of_texts = dict_of_managed_preprocessed_texts , vectorizer_type = settings [ str ( iteration_id )][ \"vectorization\" ][ \"vectorizer_type\" ], spacy_language_model = settings [ str ( iteration_id )][ \"vectorization\" ][ \"spacy_language_model\" ], ) # Store vectors. with open ( DATA_DIRECTORY / project_id / \"vectors.pkl\" , \"wb\" ) as vectors_fileobject : pickle . dump ( dict_of_managed_vectors , vectors_fileobject , pickle . HIGHEST_PROTOCOL , ) # Convert vectors into matrix. vectors_ND : csr_matrix = vstack ( dict_of_managed_vectors [ text_id_with_ND ] for text_id_with_ND in dict_of_managed_vectors . keys () ) ### ### Texts vectorization in 2D. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 50 , task_detail = \"Reduce vectors to 2 dimensions.\" , ) # Reduce vectors to 2 dimensions with TSNE. vectors_2D : ndarray = TSNE ( n_components = 2 , # learning_rate=\"auto\", # Error on \"scikit-learn==0.24.1\" ! init = \"random\" , random_state = settings [ str ( iteration_id )][ \"vectorization\" ][ \"random_seed\" ], ) . fit_transform ( vectors_ND ) # Store 2D vectors. with open ( DATA_DIRECTORY / project_id / \"vectors_2D.json\" , \"w\" ) as vectors_2D_fileobject : json . dump ( { text_id_with_2D : { \"x\" : float ( vectors_2D [ i_2D ][ 0 ]), \"y\" : float ( vectors_2D [ i_2D ][ 1 ]), } for i_2D , text_id_with_2D in enumerate ( dict_of_managed_vectors . keys ()) }, vectors_2D_fileobject , indent = 4 , ) ### ### Texts vectorization in 3D. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 65 , task_detail = \"Reduce vectors to 3 dimensions.\" , ) # Reduce vectors to 3 dimensions with TSNE. vectors_3D : ndarray = TSNE ( n_components = 3 , # learning_rate=\"auto\", # Error on \"scikit-learn==0.24.1\" ! init = \"random\" , random_state = settings [ str ( iteration_id )][ \"vectorization\" ][ \"random_seed\" ], ) . fit_transform ( vectors_ND ) # Store 3D vectors. with open ( DATA_DIRECTORY / project_id / \"vectors_3D.json\" , \"w\" ) as vectors_3D_fileobject : json . dump ( { text_id_with_3D : { \"x\" : float ( vectors_3D [ i_3D ][ 0 ]), \"y\" : float ( vectors_3D [ i_3D ][ 1 ]), \"z\" : float ( vectors_3D [ i_3D ][ 2 ]), } for i_3D , text_id_with_3D in enumerate ( dict_of_managed_vectors . keys ()) }, vectors_3D_fileobject , indent = 4 , ) ### ### Constraints manager regeneration. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 80 , task_detail = \"(Re)generate constraints manager.\" , ) # Initialize constraints manager with managed texts IDs. new_constraints_manager : BinaryConstraintsManager = BinaryConstraintsManager ( list_of_data_IDs = list ( dict_of_managed_preprocessed_texts . keys ()) ) # Load annotated constraints. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"r\" ) as constraints_fileobject_r : constraints : Dict [ str , Any ] = json . load ( constraints_fileobject_r ) # First, reset `to_fix_conflict` status of all constraints. for constraint_id in constraints . keys (): constraints [ constraint_id ][ \"to_fix_conflict\" ] = False # Then, update constraints manager with \"CANNOT_LINK\" constraints. for _ , constraint_CL in constraints . items (): if constraint_CL [ \"constraint_type\" ] == \"CANNOT_LINK\" and constraint_CL [ \"is_hidden\" ] is False : new_constraints_manager . add_constraint ( data_ID1 = constraint_CL [ \"data\" ][ \"id_1\" ], data_ID2 = constraint_CL [ \"data\" ][ \"id_2\" ], constraint_type = \"CANNOT_LINK\" , ) # No conflict can append, at this step the constraints manager handle only constraints of same type. # Initialize conflicts counter. number_of_conflicts : int = 0 # Finaly, update constraints manager with \"MUST_LINK\" constraints. for constraint_ML_id , constraint_ML in constraints . items (): if constraint_ML [ \"constraint_type\" ] == \"MUST_LINK\" and constraint_ML [ \"is_hidden\" ] is False : try : new_constraints_manager . add_constraint ( data_ID1 = constraint_ML [ \"data\" ][ \"id_1\" ], data_ID2 = constraint_ML [ \"data\" ][ \"id_2\" ], constraint_type = \"MUST_LINK\" , ) # Conflicts can append. except ValueError : # Update conflicts status. constraints [ constraint_ML_id ][ \"to_fix_conflict\" ] = True number_of_conflicts += 1 # Store new constraints manager. with open ( DATA_DIRECTORY / project_id / \"constraints_manager.pkl\" , \"wb\" ) as constraints_manager_fileobject : pickle . dump ( new_constraints_manager , constraints_manager_fileobject , pickle . HIGHEST_PROTOCOL , ) # Store updated constraints in file. with open ( DATA_DIRECTORY / project_id / \"constraints.json\" , \"w\" ) as constraints_fileobject_w : json . dump ( constraints , constraints_fileobject_w , indent = 4 ) ### ### Store modelization inference. ### with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = 95 , task_detail = \"Store modelization inference results.\" , ) # Load modelization inference file. with open ( DATA_DIRECTORY / project_id / \"modelization.json\" , \"r\" ) as modelization_fileobject_r : modelization : Dict [ str , Any ] = json . load ( modelization_fileobject_r ) # Get constraints transitivity. constraints_transitivity : Dict [ str , Dict [ str , Dict [ str , None ]] ] = new_constraints_manager . _constraints_transitivity # noqa: WPS437 # Update modelization inference. modelization = {} for text_id_in_manager in new_constraints_manager . get_list_of_managed_data_IDs (): modelization [ text_id_in_manager ] = { \"MUST_LINK\" : list ( constraints_transitivity [ text_id_in_manager ][ \"MUST_LINK\" ] . keys ()), \"CANNOT_LINK\" : list ( constraints_transitivity [ text_id_in_manager ][ \"CANNOT_LINK\" ] . keys ()), } for component_id , component in enumerate ( new_constraints_manager . get_connected_components ()): for text_id_in_component in component : modelization [ text_id_in_component ][ \"COMPONENT\" ] = component_id # Store updated modelization inference in file. with open ( DATA_DIRECTORY / project_id / \"modelization.json\" , \"w\" ) as modelization_fileobject_w : json . dump ( modelization , modelization_fileobject_w , indent = 4 ) ### ### End of task. ### # Define the next state. end_state : Optional [ ICGUIStates ] = None if working_state == ICGUIStates . INITIALIZATION_WITH_WORKING_MODELIZATION : end_state = ( ICGUIStates . CLUSTERING_TODO if ( number_of_conflicts == 0 ) else ICGUIStates . INITIALIZATION_WITH_ERRORS ) elif working_state == ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION : end_state = ( ICGUIStates . SAMPLING_TODO if ( number_of_conflicts == 0 ) else ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_ERRORS ) elif working_state == ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_WORKING_MODELIZATION : end_state = ( ICGUIStates . CLUSTERING_TODO if ( number_of_conflicts == 0 ) else ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_ERRORS ) elif working_state == ICGUIStates . IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION : end_state = ( ICGUIStates . ITERATION_END if ( number_of_conflicts == 0 ) else ICGUIStates . IMPORT_AT_ITERATION_END_WITH_ERRORS ) #### elif working_state in { #### ICGUIStates.IMPORT_AT_ANNOTATION_STEP_WITH_WORKING_MODELIZATION, #### ICGUIStates.ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS, #### ICGUIStates.ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS, #### }: else : end_state = ( ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION if ( number_of_conflicts == 0 ) else ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS ) # Lock status file in order to update project status. with FileLock ( str ( DATA_DIRECTORY / project_id / \"status.json.lock\" )): update_project_status ( project_id = project_id , task_progression = None , task_detail = None , state = end_state , )","title":"run_modelization_update_task()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/backgroundtasks/#cognitivefactory.interactive_clustering_gui.backgroundtasks.update_project_status","text":"Update project status during task. Parameters: Name Type Description Default project_id str The ID of the project. required task_progression Optional [ int ] The progression of the updated task. required task_detail Optional [ str ] The detail of the updated task. required state Optional [ ICGUIStates ] The state of the application. Unchanged if None . Defaults to None . None Source code in cognitivefactory\\interactive_clustering_gui\\backgroundtasks.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def update_project_status ( project_id : str , task_progression : Optional [ int ], task_detail : Optional [ str ], state : Optional [ ICGUIStates ] = None , ) -> None : \"\"\" Update project status during task. Args: project_id (str): The ID of the project. task_progression (Optional[int]): The progression of the updated task. task_detail (Optional[str]): The detail of the updated task. state (Optional[ICGUIStates], optional): The state of the application. Unchanged if `None`. Defaults to `None`. \"\"\" # Load status file. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"r\" ) as status_fileobject_r : project_status : Dict [ str , Any ] = json . load ( status_fileobject_r ) # Update status. project_status [ \"task\" ] = ( { \"progression\" : task_progression , \"detail\" : task_detail , } if ( task_progression is not None ) else None ) project_status [ \"state\" ] = project_status [ \"state\" ] if ( state is None ) else state # Store status. with open ( DATA_DIRECTORY / project_id / \"status.json\" , \"w\" ) as status_fileobject_w : json . dump ( project_status , status_fileobject_w , indent = 4 , )","title":"update_project_status()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/","text":"Interactive Clustering GUI package. Web application for Interactive Clustering methodology","title":"models"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/queries/","text":"Name: cognitivefactory.interactive_clustering_gui.models.queries Description: Definition of model parameters required to define query parameters of interactive clustering. Author: Erwan Schild Created: 07/02/2022 Licence: CeCILL-C License v1.0 ( https://cecill.info/licences.fr.html ) ConstraintsSortOptions \u00b6 Bases: str , enum . Enum The enumeration of available options for constraints sort. Source code in cognitivefactory\\interactive_clustering_gui\\models\\queries.py 34 35 36 37 38 39 40 41 42 43 44 class ConstraintsSortOptions ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available options for constraints sort.\"\"\" ID : str = \"id\" TEXT : str = \"text\" CONSTRAINT_TYPE : str = \"constraint_type\" DATE_OF_UPDATE : str = \"date_of_update\" ITERATION_OF_SAMPLING : str = \"iteration_of_sampling\" TO_ANNOTATE : str = \"to_annotate\" TO_REVIEW : str = \"to_review\" TO_FIX_CONFLICT : str = \"to_fix_conflict\" ConstraintsValues \u00b6 Bases: str , enum . Enum The enumeration of available constraints values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\queries.py 22 23 24 25 26 class ConstraintsValues ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available constraints values.\"\"\" MUST_LINK : str = \"MUST_LINK\" CANNOT_LINK : str = \"CANNOT_LINK\" TextsSortOptions \u00b6 Bases: str , enum . Enum The enumeration of available options for texts sort. Source code in cognitivefactory\\interactive_clustering_gui\\models\\queries.py 52 53 54 55 56 57 class TextsSortOptions ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available options for texts sort.\"\"\" ID : str = \"id\" ALPHABETICAL : str = \"alphabetical\" IS_DELETED : str = \"is_deleted\"","title":"queries"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/queries/#cognitivefactory.interactive_clustering_gui.models.queries.ConstraintsSortOptions","text":"Bases: str , enum . Enum The enumeration of available options for constraints sort. Source code in cognitivefactory\\interactive_clustering_gui\\models\\queries.py 34 35 36 37 38 39 40 41 42 43 44 class ConstraintsSortOptions ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available options for constraints sort.\"\"\" ID : str = \"id\" TEXT : str = \"text\" CONSTRAINT_TYPE : str = \"constraint_type\" DATE_OF_UPDATE : str = \"date_of_update\" ITERATION_OF_SAMPLING : str = \"iteration_of_sampling\" TO_ANNOTATE : str = \"to_annotate\" TO_REVIEW : str = \"to_review\" TO_FIX_CONFLICT : str = \"to_fix_conflict\"","title":"ConstraintsSortOptions"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/queries/#cognitivefactory.interactive_clustering_gui.models.queries.ConstraintsValues","text":"Bases: str , enum . Enum The enumeration of available constraints values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\queries.py 22 23 24 25 26 class ConstraintsValues ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available constraints values.\"\"\" MUST_LINK : str = \"MUST_LINK\" CANNOT_LINK : str = \"CANNOT_LINK\"","title":"ConstraintsValues"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/queries/#cognitivefactory.interactive_clustering_gui.models.queries.TextsSortOptions","text":"Bases: str , enum . Enum The enumeration of available options for texts sort. Source code in cognitivefactory\\interactive_clustering_gui\\models\\queries.py 52 53 54 55 56 57 class TextsSortOptions ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available options for texts sort.\"\"\" ID : str = \"id\" ALPHABETICAL : str = \"alphabetical\" IS_DELETED : str = \"is_deleted\"","title":"TextsSortOptions"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/","text":"Name: cognitivefactory.interactive_clustering_gui.models.settings Description: Definition of model parameters required to define settings of interactive clustering. Author: Erwan Schild Created: 16/12/2021 Licence: CeCILL-C License v1.0 ( https://cecill.info/licences.fr.html ) ClusterRestriction \u00b6 Bases: str , enum . Enum The enumeration of available cluster restrictions for custom sampling algorithm. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 243 244 245 246 247 class ClusterRestriction ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available cluster restrictions for custom sampling algorithm.\"\"\" SAME_CLUSTER : str = \"same_cluster\" DIFFERENT_CLUSTERS : str = \"different_clusters\" ClusteringAlgorithmEnum \u00b6 Bases: str , enum . Enum The enumeration of available clustering algorithms. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 428 429 430 431 432 433 class ClusteringAlgorithmEnum ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available clustering algorithms.\"\"\" KMEANS : str = \"kmeans\" HIERARCHICAL : str = \"hierarchical\" SPECTRAL : str = \"spectral\" ClusteringSettingsModel \u00b6 Bases: BaseModel The body model for clustering settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 class ClusteringSettingsModel ( BaseModel ): \"\"\"The body model for clustering settings.\"\"\" # Parameters. algorithm : ClusteringAlgorithmEnum random_seed : int nb_clusters : int init_kargs : Union [ None , KmeansInitSettingsModel , HierarchicalInitSettingsModel , SpectralInitSettingsModel ] @validator ( \"random_seed\" ) @classmethod def validate_random_seed ( cls , value : int ) -> int : \"\"\"The validation of random_seed settings. Args: value (int): The value of random_seed setting. Raises: ValueError: if `random_seed` is incorrectly set. Returns: int: The value of random_seed setting. \"\"\" if value < 0 : raise ValueError ( \"`random_seed` must be greater than or equal to 0.\" ) return value @validator ( \"nb_clusters\" ) @classmethod def validate_nb_clusters ( cls , value : int ) -> int : \"\"\"The validation of nb_clusters settings. Args: value (int): The value of nb_clusters setting. Raises: ValueError: if `nb_clusters` is incorrectly set. Returns: int: The value of nb_clusters setting. \"\"\" if value < 2 : raise ValueError ( \"`nb_clusters` must be greater than or equal to 2.\" ) return value @root_validator @classmethod def validate_clustering_settings ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"The validation of clustering settings. Args: values (Dict[str, Any]): The values of clustering settings. Raises: ValueError: if `algorithm` and `init_kargs` are incompatible. Returns: Dict[str, Any]: The validated values of clustering settings. \"\"\" # Case of no clustering algorithm. if \"algorithm\" not in values . keys (): raise ValueError ( \"The parameter `algorithm` is required.\" ) # Case of kmeans clustering algorithm. if values [ \"algorithm\" ] == ClusteringAlgorithmEnum . KMEANS : # Case of no init parameters. if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `kmeans`.\" ) # Case of wrong type init parameters. if not isinstance ( values [ \"init_kargs\" ], KmeansInitSettingsModel ): raise ValueError ( \"The dictionary of initialization (`init_kargs`) is incompatible with algorithm `kmeans`.\" ) # Case of hierarchical clustering algorithm. if values [ \"algorithm\" ] == ClusteringAlgorithmEnum . HIERARCHICAL : # Case of no init parameters. if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `hierarchical`.\" ) # Case of wrong type init parameters. if not isinstance ( values [ \"init_kargs\" ], HierarchicalInitSettingsModel ): raise ValueError ( \"The dictionary of initialization (`init_kargs`) is incompatible with algorithm `hierarchical`.\" ) # Case of spectral clustering algorithm. if values [ \"algorithm\" ] == ClusteringAlgorithmEnum . SPECTRAL : # Case of no init parameters. if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `spectral`.\" ) # Case of wrong type init parameters. if not isinstance ( values [ \"init_kargs\" ], SpectralInitSettingsModel ): raise ValueError ( \"The dictionary of initialization (`init_kargs`) is incompatible with algorithm `spectral`.\" ) # Return validated values of sampling settings. return values # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"algorithm\" : self . algorithm . value , \"random_seed\" : self . random_seed , \"nb_clusters\" : self . nb_clusters , \"init_kargs\" : self . init_kargs . to_dict () if ( self . init_kargs is not None ) else {}, } # Config for schema. class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of clustering settings.\"\"\" schema_extra = { \"example\" : { \"algorithm\" : ( ClusteringAlgorithmEnum . KMEANS + \"|\" + ClusteringAlgorithmEnum . HIERARCHICAL + \"|\" + ClusteringAlgorithmEnum . SPECTRAL ), \"random_seed\" : 42 , \"nb_clusters\" : 2 , \"init_kargs\" : { \"!!!SPECIFIC: 'algorithm'=='kmeans'\" : { \"model\" : KmeansModelEnum . COP , \"max_iteration\" : 150 , \"tolerance\" : 0.0001 , }, \"!!!SPECIFIC: 'algorithm'=='hierarchical'\" : { \"linkage\" : ( HierarchicalLinkageEnum . WARD + \"|\" + HierarchicalLinkageEnum . AVERAGE + \"|\" + HierarchicalLinkageEnum . COMPLETE + \"|\" + HierarchicalLinkageEnum . SINGLE ), }, \"!!!SPECIFIC: 'algorithm'=='spectral'\" : { \"model\" : SpectralModelEnum . SPEC , \"nb_components\" : None , }, }, } } Config \u00b6 Configuration for body model of clustering settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of clustering settings.\"\"\" schema_extra = { \"example\" : { \"algorithm\" : ( ClusteringAlgorithmEnum . KMEANS + \"|\" + ClusteringAlgorithmEnum . HIERARCHICAL + \"|\" + ClusteringAlgorithmEnum . SPECTRAL ), \"random_seed\" : 42 , \"nb_clusters\" : 2 , \"init_kargs\" : { \"!!!SPECIFIC: 'algorithm'=='kmeans'\" : { \"model\" : KmeansModelEnum . COP , \"max_iteration\" : 150 , \"tolerance\" : 0.0001 , }, \"!!!SPECIFIC: 'algorithm'=='hierarchical'\" : { \"linkage\" : ( HierarchicalLinkageEnum . WARD + \"|\" + HierarchicalLinkageEnum . AVERAGE + \"|\" + HierarchicalLinkageEnum . COMPLETE + \"|\" + HierarchicalLinkageEnum . SINGLE ), }, \"!!!SPECIFIC: 'algorithm'=='spectral'\" : { \"model\" : SpectralModelEnum . SPEC , \"nb_components\" : None , }, }, } } to_dict () \u00b6 Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 716 717 718 719 720 721 722 723 724 725 726 727 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"algorithm\" : self . algorithm . value , \"random_seed\" : self . random_seed , \"nb_clusters\" : self . nb_clusters , \"init_kargs\" : self . init_kargs . to_dict () if ( self . init_kargs is not None ) else {}, } validate_clustering_settings ( values ) classmethod \u00b6 The validation of clustering settings. Parameters: Name Type Description Default values Dict [ str , Any ] The values of clustering settings. required Raises: Type Description ValueError if algorithm and init_kargs are incompatible. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: The validated values of clustering settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 @root_validator @classmethod def validate_clustering_settings ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"The validation of clustering settings. Args: values (Dict[str, Any]): The values of clustering settings. Raises: ValueError: if `algorithm` and `init_kargs` are incompatible. Returns: Dict[str, Any]: The validated values of clustering settings. \"\"\" # Case of no clustering algorithm. if \"algorithm\" not in values . keys (): raise ValueError ( \"The parameter `algorithm` is required.\" ) # Case of kmeans clustering algorithm. if values [ \"algorithm\" ] == ClusteringAlgorithmEnum . KMEANS : # Case of no init parameters. if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `kmeans`.\" ) # Case of wrong type init parameters. if not isinstance ( values [ \"init_kargs\" ], KmeansInitSettingsModel ): raise ValueError ( \"The dictionary of initialization (`init_kargs`) is incompatible with algorithm `kmeans`.\" ) # Case of hierarchical clustering algorithm. if values [ \"algorithm\" ] == ClusteringAlgorithmEnum . HIERARCHICAL : # Case of no init parameters. if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `hierarchical`.\" ) # Case of wrong type init parameters. if not isinstance ( values [ \"init_kargs\" ], HierarchicalInitSettingsModel ): raise ValueError ( \"The dictionary of initialization (`init_kargs`) is incompatible with algorithm `hierarchical`.\" ) # Case of spectral clustering algorithm. if values [ \"algorithm\" ] == ClusteringAlgorithmEnum . SPECTRAL : # Case of no init parameters. if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `spectral`.\" ) # Case of wrong type init parameters. if not isinstance ( values [ \"init_kargs\" ], SpectralInitSettingsModel ): raise ValueError ( \"The dictionary of initialization (`init_kargs`) is incompatible with algorithm `spectral`.\" ) # Return validated values of sampling settings. return values validate_nb_clusters ( value ) classmethod \u00b6 The validation of nb_clusters settings. Parameters: Name Type Description Default value int The value of nb_clusters setting. required Raises: Type Description ValueError if nb_clusters is incorrectly set. Returns: Name Type Description int int The value of nb_clusters setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 @validator ( \"nb_clusters\" ) @classmethod def validate_nb_clusters ( cls , value : int ) -> int : \"\"\"The validation of nb_clusters settings. Args: value (int): The value of nb_clusters setting. Raises: ValueError: if `nb_clusters` is incorrectly set. Returns: int: The value of nb_clusters setting. \"\"\" if value < 2 : raise ValueError ( \"`nb_clusters` must be greater than or equal to 2.\" ) return value validate_random_seed ( value ) classmethod \u00b6 The validation of random_seed settings. Parameters: Name Type Description Default value int The value of random_seed setting. required Raises: Type Description ValueError if random_seed is incorrectly set. Returns: Name Type Description int int The value of random_seed setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 @validator ( \"random_seed\" ) @classmethod def validate_random_seed ( cls , value : int ) -> int : \"\"\"The validation of random_seed settings. Args: value (int): The value of random_seed setting. Raises: ValueError: if `random_seed` is incorrectly set. Returns: int: The value of random_seed setting. \"\"\" if value < 0 : raise ValueError ( \"`random_seed` must be greater than or equal to 0.\" ) return value CustomSamplingInitSettingsModel \u00b6 Bases: BaseModel The body submodel for custom sampling initialization settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 class CustomSamplingInitSettingsModel ( BaseModel ): \"\"\"The body submodel for custom sampling initialization settings.\"\"\" # Parameters. clusters_restriction : ClusterRestriction distance_restriction : DistanceRestriction without_inferred_constraints : bool # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"clusters_restriction\" : self . clusters_restriction . value , \"distance_restriction\" : self . distance_restriction . value , \"without_inferred_constraints\" : self . without_inferred_constraints , } to_dict () \u00b6 Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 266 267 268 269 270 271 272 273 274 275 276 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"clusters_restriction\" : self . clusters_restriction . value , \"distance_restriction\" : self . distance_restriction . value , \"without_inferred_constraints\" : self . without_inferred_constraints , } DistanceRestriction \u00b6 Bases: str , enum . Enum The enumeration of available distance restrictions for custom sampling algorithm. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 250 251 252 253 254 class DistanceRestriction ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available distance restrictions for custom sampling algorithm.\"\"\" CLOSEST_NEIGHBORS : str = \"closest_neighbors\" FARTHEST_NEIGHBORS : str = \"farthest_neighbors\" HierarchicalInitSettingsModel \u00b6 Bases: BaseModel The body submodel for hierarchical instantiation settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 class HierarchicalInitSettingsModel ( BaseModel ): \"\"\"The body submodel for hierarchical instantiation settings.\"\"\" # Parameters. linkage : HierarchicalLinkageEnum # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"linkage\" : self . linkage . value , } to_dict () \u00b6 Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 529 530 531 532 533 534 535 536 537 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"linkage\" : self . linkage . value , } HierarchicalLinkageEnum \u00b6 Bases: str , enum . Enum The enumeration of available hierarchical linkages. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 513 514 515 516 517 518 519 class HierarchicalLinkageEnum ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available hierarchical linkages.\"\"\" AVERAGE : str = \"average\" COMPLETE : str = \"complete\" SINGLE : str = \"single\" WARD : str = \"ward\" ICGUISettings \u00b6 Bases: str , enum . Enum The enumeration of available Settings for Interactive Clustering GUI. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class ICGUISettings ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available Settings for Interactive Clustering GUI.\"\"\" PREPROCESSING : str = \"preprocessing\" VECTORIZATION : str = \"vectorization\" SAMPLING : str = \"sampling\" CLUSTERING : str = \"clustering\" @classmethod def contains ( cls , value : Any ) -> bool : \"\"\"Test if value is in this enumeration. Args: value (Any): A value. Returns: bool: `True` if the value is in the enumeration. \"\"\" return value in cls . _value2member_map_ contains ( value ) classmethod \u00b6 Test if value is in this enumeration. Parameters: Name Type Description Default value Any A value. required Returns: Name Type Description bool bool True if the value is in the enumeration. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 33 34 35 36 37 38 39 40 41 42 43 @classmethod def contains ( cls , value : Any ) -> bool : \"\"\"Test if value is in this enumeration. Args: value (Any): A value. Returns: bool: `True` if the value is in the enumeration. \"\"\" return value in cls . _value2member_map_ KmeansInitSettingsModel \u00b6 Bases: BaseModel The body submodel for kmeans instantiation settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 class KmeansInitSettingsModel ( BaseModel ): \"\"\"The body submodel for kmeans instantiation settings.\"\"\" # Parameters. model : KmeansModelEnum max_iteration : int tolerance : float @validator ( \"max_iteration\" ) @classmethod def validate_max_iteration ( cls , value : int ) -> int : \"\"\"The validation of max_iteration settings. Args: value (int): The value of max_iteration setting. Raises: ValueError: if `max_iteration` is incorrectly set. Returns: int: The value of max_iteration setting. \"\"\" if value < 1 : raise ValueError ( \"`max_iteration` must be greater than or equal to 1.\" ) return value @validator ( \"tolerance\" ) @classmethod def validate_tolerance ( cls , value : float ) -> float : \"\"\"The validation of tolerance settings. Args: value (float): The value of tolerance setting. Raises: ValueError: if `tolerance` is incorrectly set. Returns: float: The value of tolerance setting. \"\"\" if value < 0 : raise ValueError ( \"The `tolerance` must be greater than 0.0.\" ) return value # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"model\" : self . model . value , \"max_iteration\" : self . max_iteration , \"tolerance\" : self . tolerance , } to_dict () \u00b6 Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 487 488 489 490 491 492 493 494 495 496 497 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"model\" : self . model . value , \"max_iteration\" : self . max_iteration , \"tolerance\" : self . tolerance , } validate_max_iteration ( value ) classmethod \u00b6 The validation of max_iteration settings. Parameters: Name Type Description Default value int The value of max_iteration setting. required Raises: Type Description ValueError if max_iteration is incorrectly set. Returns: Name Type Description int int The value of max_iteration setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 @validator ( \"max_iteration\" ) @classmethod def validate_max_iteration ( cls , value : int ) -> int : \"\"\"The validation of max_iteration settings. Args: value (int): The value of max_iteration setting. Raises: ValueError: if `max_iteration` is incorrectly set. Returns: int: The value of max_iteration setting. \"\"\" if value < 1 : raise ValueError ( \"`max_iteration` must be greater than or equal to 1.\" ) return value validate_tolerance ( value ) classmethod \u00b6 The validation of tolerance settings. Parameters: Name Type Description Default value float The value of tolerance setting. required Raises: Type Description ValueError if tolerance is incorrectly set. Returns: Name Type Description float float The value of tolerance setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 @validator ( \"tolerance\" ) @classmethod def validate_tolerance ( cls , value : float ) -> float : \"\"\"The validation of tolerance settings. Args: value (float): The value of tolerance setting. Raises: ValueError: if `tolerance` is incorrectly set. Returns: float: The value of tolerance setting. \"\"\" if value < 0 : raise ValueError ( \"The `tolerance` must be greater than 0.0.\" ) return value KmeansModelEnum \u00b6 Bases: str , enum . Enum The enumeration of available kmeans models. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 436 437 438 439 class KmeansModelEnum ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available kmeans models.\"\"\" COP : str = \"COP\" PreprocessingSettingsModel \u00b6 Bases: BaseModel The body model for preprocessing settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class PreprocessingSettingsModel ( BaseModel ): \"\"\"The body model for preprocessing settings.\"\"\" # Parameters. apply_stopwords_deletion : bool apply_parsing_filter : bool apply_lemmatization : bool spacy_language_model : PreprocessingSpacyLanguageModel # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"apply_stopwords_deletion\" : self . apply_stopwords_deletion , \"apply_parsing_filter\" : self . apply_parsing_filter , \"apply_lemmatization\" : self . apply_lemmatization , \"spacy_language_model\" : self . spacy_language_model . value , } # Config for schema. class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of preprocessing settings.\"\"\" schema_extra = { \"example\" : { \"apply_stopwords_deletion\" : False , \"apply_parsing_filter\" : False , \"apply_lemmatization\" : False , \"spacy_language_model\" : PreprocessingSpacyLanguageModel . FR_CORE_NEWS_MD , } } Config \u00b6 Configuration for body model of preprocessing settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 81 82 83 84 85 86 87 88 89 90 91 class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of preprocessing settings.\"\"\" schema_extra = { \"example\" : { \"apply_stopwords_deletion\" : False , \"apply_parsing_filter\" : False , \"apply_lemmatization\" : False , \"spacy_language_model\" : PreprocessingSpacyLanguageModel . FR_CORE_NEWS_MD , } } to_dict () \u00b6 Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 67 68 69 70 71 72 73 74 75 76 77 78 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"apply_stopwords_deletion\" : self . apply_stopwords_deletion , \"apply_parsing_filter\" : self . apply_parsing_filter , \"apply_lemmatization\" : self . apply_lemmatization , \"spacy_language_model\" : self . spacy_language_model . value , } PreprocessingSpacyLanguageModel \u00b6 Bases: str , enum . Enum The enumeration of available spacy language model name. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 51 52 53 54 class PreprocessingSpacyLanguageModel ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available spacy language model name.\"\"\" FR_CORE_NEWS_MD : str = \"fr_core_news_md\" SamplingAlgorithm \u00b6 Bases: str , enum . Enum The enumeration of available sampling algorithms. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 233 234 235 236 237 238 239 240 class SamplingAlgorithm ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available sampling algorithms.\"\"\" RANDOM : str = \"random\" RANDOM_IN_SAME_CLUSTER : str = \"random_in_same_cluster\" FARTHEST_IN_SAME_CLUSTER : str = \"farthest_in_same_cluster\" CLOSEST_IN_DIFFERENT_CLUSTERS : str = \"closest_in_different_clusters\" CUSTOM : str = \"custom\" SamplingSettingsModel \u00b6 Bases: BaseModel Abstract body model for sampling settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 class SamplingSettingsModel ( BaseModel ): \"\"\"Abstract body model for sampling settings.\"\"\" # Parameters. algorithm : SamplingAlgorithm random_seed : int nb_to_select : int init_kargs : Optional [ CustomSamplingInitSettingsModel ] @validator ( \"random_seed\" ) @classmethod def validate_random_seed ( cls , value : int ) -> int : \"\"\"The validation of random_seed settings. Args: value (int): The value of random_seed setting. Raises: ValueError: if `random_seed` is incorrectly set. Returns: int: The value of random_seed setting. \"\"\" if value < 0 : raise ValueError ( \"`random_seed` must be greater than or equal to 0.\" ) return value @validator ( \"nb_to_select\" ) @classmethod def validate_nb_to_select ( cls , value : int ) -> int : \"\"\"The validation of nb_to_select settings. Args: value (int): The value of nb_to_select setting. Raises: ValueError: if `nb_to_select` is incorrectly set. Returns: int: The value of nb_to_select setting. \"\"\" if value < 1 : raise ValueError ( \"`nb_to_select` must be greater than or equal to 1.\" ) return value @root_validator @classmethod def validate_sampling_settings ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"The validation of sampling settings. Args: values (Dict[str, Any]): The values of sampling settings. Raises: ValueError: if `algorithm` and `init_kargs` are incompatible. Returns: Dict[str, Any]: The validated values of sampling settings. \"\"\" # Case of no sampling algorithm. if \"algorithm\" not in values . keys (): raise ValueError ( \"The parameter `algorithm` is required.\" ) # Case of custom sampling algorithm. if values [ \"algorithm\" ] == SamplingAlgorithm . CUSTOM : if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `custom`.\" ) # Case of predefinite sampling algorithms. else : if ( \"init_kargs\" in values . keys ()) and ( values [ \"init_kargs\" ] is not None ): raise ValueError ( \"No dictionary of initialization (`init_kargs`) is required when algorithm is different from `custom`.\" ) values [ \"init_kargs\" ] = None # Return validated values of sampling settings. return values # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"algorithm\" : self . algorithm . value , \"random_seed\" : self . random_seed , \"nb_to_select\" : self . nb_to_select , \"init_kargs\" : self . init_kargs . to_dict () if ( self . init_kargs is not None ) else None , } # Config for schema. class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of sampling settings.\"\"\" schema_extra = { \"example\" : { \"algorithm\" : ( SamplingAlgorithm . RANDOM + \"|\" + SamplingAlgorithm . RANDOM_IN_SAME_CLUSTER + \"|\" + SamplingAlgorithm . CLOSEST_IN_DIFFERENT_CLUSTERS + \"|\" + SamplingAlgorithm . FARTHEST_IN_SAME_CLUSTER + \"|\" + SamplingAlgorithm . CUSTOM ), \"random_seed\" : 42 , \"nb_to_select\" : 25 , \"!!!SPECIFIC: 'algorithm'=='custom'\" : { \"init_kargs\" : { \"clusters_restriction\" : ( ClusterRestriction . SAME_CLUSTER + \"|\" + ClusterRestriction . DIFFERENT_CLUSTERS ), \"distance_restriction\" : ( DistanceRestriction . CLOSEST_NEIGHBORS + \"|\" + DistanceRestriction . FARTHEST_NEIGHBORS ), \"without_inferred_constraints\" : True , }, }, } } Config \u00b6 Configuration for body model of sampling settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of sampling settings.\"\"\" schema_extra = { \"example\" : { \"algorithm\" : ( SamplingAlgorithm . RANDOM + \"|\" + SamplingAlgorithm . RANDOM_IN_SAME_CLUSTER + \"|\" + SamplingAlgorithm . CLOSEST_IN_DIFFERENT_CLUSTERS + \"|\" + SamplingAlgorithm . FARTHEST_IN_SAME_CLUSTER + \"|\" + SamplingAlgorithm . CUSTOM ), \"random_seed\" : 42 , \"nb_to_select\" : 25 , \"!!!SPECIFIC: 'algorithm'=='custom'\" : { \"init_kargs\" : { \"clusters_restriction\" : ( ClusterRestriction . SAME_CLUSTER + \"|\" + ClusterRestriction . DIFFERENT_CLUSTERS ), \"distance_restriction\" : ( DistanceRestriction . CLOSEST_NEIGHBORS + \"|\" + DistanceRestriction . FARTHEST_NEIGHBORS ), \"without_inferred_constraints\" : True , }, }, } } to_dict () \u00b6 Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 362 363 364 365 366 367 368 369 370 371 372 373 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"algorithm\" : self . algorithm . value , \"random_seed\" : self . random_seed , \"nb_to_select\" : self . nb_to_select , \"init_kargs\" : self . init_kargs . to_dict () if ( self . init_kargs is not None ) else None , } validate_nb_to_select ( value ) classmethod \u00b6 The validation of nb_to_select settings. Parameters: Name Type Description Default value int The value of nb_to_select setting. required Raises: Type Description ValueError if nb_to_select is incorrectly set. Returns: Name Type Description int int The value of nb_to_select setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 @validator ( \"nb_to_select\" ) @classmethod def validate_nb_to_select ( cls , value : int ) -> int : \"\"\"The validation of nb_to_select settings. Args: value (int): The value of nb_to_select setting. Raises: ValueError: if `nb_to_select` is incorrectly set. Returns: int: The value of nb_to_select setting. \"\"\" if value < 1 : raise ValueError ( \"`nb_to_select` must be greater than or equal to 1.\" ) return value validate_random_seed ( value ) classmethod \u00b6 The validation of random_seed settings. Parameters: Name Type Description Default value int The value of random_seed setting. required Raises: Type Description ValueError if random_seed is incorrectly set. Returns: Name Type Description int int The value of random_seed setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 @validator ( \"random_seed\" ) @classmethod def validate_random_seed ( cls , value : int ) -> int : \"\"\"The validation of random_seed settings. Args: value (int): The value of random_seed setting. Raises: ValueError: if `random_seed` is incorrectly set. Returns: int: The value of random_seed setting. \"\"\" if value < 0 : raise ValueError ( \"`random_seed` must be greater than or equal to 0.\" ) return value validate_sampling_settings ( values ) classmethod \u00b6 The validation of sampling settings. Parameters: Name Type Description Default values Dict [ str , Any ] The values of sampling settings. required Raises: Type Description ValueError if algorithm and init_kargs are incompatible. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: The validated values of sampling settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 @root_validator @classmethod def validate_sampling_settings ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"The validation of sampling settings. Args: values (Dict[str, Any]): The values of sampling settings. Raises: ValueError: if `algorithm` and `init_kargs` are incompatible. Returns: Dict[str, Any]: The validated values of sampling settings. \"\"\" # Case of no sampling algorithm. if \"algorithm\" not in values . keys (): raise ValueError ( \"The parameter `algorithm` is required.\" ) # Case of custom sampling algorithm. if values [ \"algorithm\" ] == SamplingAlgorithm . CUSTOM : if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `custom`.\" ) # Case of predefinite sampling algorithms. else : if ( \"init_kargs\" in values . keys ()) and ( values [ \"init_kargs\" ] is not None ): raise ValueError ( \"No dictionary of initialization (`init_kargs`) is required when algorithm is different from `custom`.\" ) values [ \"init_kargs\" ] = None # Return validated values of sampling settings. return values SpectralInitSettingsModel \u00b6 Bases: BaseModel The body submodel for spectral instantiation settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 class SpectralInitSettingsModel ( BaseModel ): \"\"\"The body submodel for spectral instantiation settings.\"\"\" # Parameters. model : SpectralModelEnum = SpectralModelEnum . SPEC nb_components : Optional [ int ] = None @validator ( \"nb_components\" ) @classmethod def validate_nb_components ( cls , value : Optional [ int ]) -> Optional [ int ]: \"\"\"The validation of nb_components settings. Args: value (Optional[int]): The value of nb_components setting. Raises: ValueError: if `nb_components` is incorrectly set. Returns: Optional[int]: The value of nb_components setting. \"\"\" if ( value is not None ) and ( value < 2 ): raise ValueError ( \"`nb_components` must be `None` or greater than or equal to 2.\" ) return value # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"model\" : self . model . value , \"nb_components\" : self . nb_components , } to_dict () \u00b6 Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 584 585 586 587 588 589 590 591 592 593 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"model\" : self . model . value , \"nb_components\" : self . nb_components , } validate_nb_components ( value ) classmethod \u00b6 The validation of nb_components settings. Parameters: Name Type Description Default value Optional [ int ] The value of nb_components setting. required Raises: Type Description ValueError if nb_components is incorrectly set. Returns: Type Description Optional [ int ] Optional[int]: The value of nb_components setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 @validator ( \"nb_components\" ) @classmethod def validate_nb_components ( cls , value : Optional [ int ]) -> Optional [ int ]: \"\"\"The validation of nb_components settings. Args: value (Optional[int]): The value of nb_components setting. Raises: ValueError: if `nb_components` is incorrectly set. Returns: Optional[int]: The value of nb_components setting. \"\"\" if ( value is not None ) and ( value < 2 ): raise ValueError ( \"`nb_components` must be `None` or greater than or equal to 2.\" ) return value SpectralModelEnum \u00b6 Bases: str , enum . Enum The enumeration of available spectral models. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 552 553 554 555 class SpectralModelEnum ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available spectral models.\"\"\" SPEC : str = \"SPEC\" VectorizationSettingsModel \u00b6 Bases: BaseModel The body model for vectorization settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class VectorizationSettingsModel ( BaseModel ): \"\"\"The body model for vectorization settings.\"\"\" # Parameters. vectorizer_type : VectorizerType spacy_language_model : Optional [ VectorizationSpacyLanguageModel ] random_seed : int @validator ( \"random_seed\" ) @classmethod def validate_random_seed ( cls , value : int ) -> int : \"\"\"The validation of random_seed settings. Args: value (int): The value of random_seed setting. Raises: ValueError: if `random_seed` is incorrectly set. Returns: int: The value of random_seed setting. \"\"\" if value < 0 : raise ValueError ( \"`random_seed` must be greater than or equal to 0.\" ) return value @root_validator @classmethod def validate_vectorization_settings ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"The validation of vectorization settings. Args: values (Dict[str, Any]): The values of vectorization settings. Raises: ValueError: if `vectorizer_type` and `spacy_language_model` are incompatible. Returns: Dict[str, Any]: The validated values of vectorization settings. \"\"\" # Case of no vectorizer. if \"vectorizer_type\" not in values . keys (): raise ValueError ( \"The parameter `vectorizer_type` is required.\" ) # Case of tfidf vectorizer. if values [ \"vectorizer_type\" ] == VectorizerType . TFIDF : if ( \"spacy_language_model\" in values . keys ()) and ( values [ \"spacy_language_model\" ] is not None ): raise ValueError ( \"No spacy language model is required when vectorizer is `tfidf`.\" ) values [ \"spacy_language_model\" ] = None # Case of spacy vectorizer. if values [ \"vectorizer_type\" ] == VectorizerType . SPACY : if ( \"spacy_language_model\" not in values . keys ()) or ( values [ \"spacy_language_model\" ] is None ): raise ValueError ( \"A spacy language model is required when vectorizer is `spacy`.\" ) # Return validated values of vectorization settings. return values # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"vectorizer_type\" : self . vectorizer_type . value , \"spacy_language_model\" : self . spacy_language_model . value if ( self . spacy_language_model is not None ) else None , \"random_seed\" : self . random_seed , } # Config for schema. class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of vectorization settings.\"\"\" schema_extra = { \"example\" : { \"vectorizer_type\" : ( VectorizerType . TFIDF + \"|\" + VectorizerType . SPACY ), \"random_seed\" : 42 , \"!!!SPECIFIC: 'vectorizer_type'=='spacy'\" : { \"spacy_language_model\" : VectorizationSpacyLanguageModel . FR_CORE_NEWS_MD , }, } } Config \u00b6 Configuration for body model of vectorization settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 201 202 203 204 205 206 207 208 209 210 211 212 class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of vectorization settings.\"\"\" schema_extra = { \"example\" : { \"vectorizer_type\" : ( VectorizerType . TFIDF + \"|\" + VectorizerType . SPACY ), \"random_seed\" : 42 , \"!!!SPECIFIC: 'vectorizer_type'=='spacy'\" : { \"spacy_language_model\" : VectorizationSpacyLanguageModel . FR_CORE_NEWS_MD , }, } } to_dict () \u00b6 Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 186 187 188 189 190 191 192 193 194 195 196 197 198 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"vectorizer_type\" : self . vectorizer_type . value , \"spacy_language_model\" : self . spacy_language_model . value if ( self . spacy_language_model is not None ) else None , \"random_seed\" : self . random_seed , } validate_random_seed ( value ) classmethod \u00b6 The validation of random_seed settings. Parameters: Name Type Description Default value int The value of random_seed setting. required Raises: Type Description ValueError if random_seed is incorrectly set. Returns: Name Type Description int int The value of random_seed setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @validator ( \"random_seed\" ) @classmethod def validate_random_seed ( cls , value : int ) -> int : \"\"\"The validation of random_seed settings. Args: value (int): The value of random_seed setting. Raises: ValueError: if `random_seed` is incorrectly set. Returns: int: The value of random_seed setting. \"\"\" if value < 0 : raise ValueError ( \"`random_seed` must be greater than or equal to 0.\" ) return value validate_vectorization_settings ( values ) classmethod \u00b6 The validation of vectorization settings. Parameters: Name Type Description Default values Dict [ str , Any ] The values of vectorization settings. required Raises: Type Description ValueError if vectorizer_type and spacy_language_model are incompatible. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: The validated values of vectorization settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @root_validator @classmethod def validate_vectorization_settings ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"The validation of vectorization settings. Args: values (Dict[str, Any]): The values of vectorization settings. Raises: ValueError: if `vectorizer_type` and `spacy_language_model` are incompatible. Returns: Dict[str, Any]: The validated values of vectorization settings. \"\"\" # Case of no vectorizer. if \"vectorizer_type\" not in values . keys (): raise ValueError ( \"The parameter `vectorizer_type` is required.\" ) # Case of tfidf vectorizer. if values [ \"vectorizer_type\" ] == VectorizerType . TFIDF : if ( \"spacy_language_model\" in values . keys ()) and ( values [ \"spacy_language_model\" ] is not None ): raise ValueError ( \"No spacy language model is required when vectorizer is `tfidf`.\" ) values [ \"spacy_language_model\" ] = None # Case of spacy vectorizer. if values [ \"vectorizer_type\" ] == VectorizerType . SPACY : if ( \"spacy_language_model\" not in values . keys ()) or ( values [ \"spacy_language_model\" ] is None ): raise ValueError ( \"A spacy language model is required when vectorizer is `spacy`.\" ) # Return validated values of vectorization settings. return values VectorizationSpacyLanguageModel \u00b6 Bases: str , enum . Enum The enumeration of available spacy language model name. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 120 121 122 123 class VectorizationSpacyLanguageModel ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available spacy language model name.\"\"\" FR_CORE_NEWS_MD : str = \"fr_core_news_md\" VectorizerType \u00b6 Bases: str , enum . Enum The enumeration of available vectorizer type. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 113 114 115 116 117 class VectorizerType ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available vectorizer type.\"\"\" TFIDF : str = \"tfidf\" SPACY : str = \"spacy\" default_ClusteringSettingsModel () \u00b6 Create a ClusteringSettingsModel instance with default values. Returns: Name Type Description ClusteringSettingsModel ClusteringSettingsModel A ClusteringSettingsModel instance with default values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 770 771 772 773 774 775 776 777 778 779 780 781 def default_ClusteringSettingsModel () -> ClusteringSettingsModel : \"\"\"Create a ClusteringSettingsModel instance with default values. Returns: ClusteringSettingsModel: A ClusteringSettingsModel instance with default values. \"\"\" return ClusteringSettingsModel ( algorithm = ClusteringAlgorithmEnum . KMEANS , random_seed = 42 , nb_clusters = 2 , init_kargs = default_KmeansInitSettingsModel (), ) default_KmeansInitSettingsModel () \u00b6 Create a KmeansInitSettingsModel instance with default values. Returns: Name Type Description KmeansInitSettingsModel KmeansInitSettingsModel A KmeansInitSettingsModel instance with default values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 500 501 502 503 504 505 506 507 508 509 510 def default_KmeansInitSettingsModel () -> KmeansInitSettingsModel : \"\"\"Create a KmeansInitSettingsModel instance with default values. Returns: KmeansInitSettingsModel: A KmeansInitSettingsModel instance with default values. \"\"\" return KmeansInitSettingsModel ( model = KmeansModelEnum . COP , max_iteration = 150 , tolerance = 0.0001 , ) default_PreprocessingSettingsModel () \u00b6 Create a PreprocessingSettingsModel instance with default values. Returns: Name Type Description PreprocessingSettingsModel PreprocessingSettingsModel A PreprocessingSettingsModel instance with default values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 94 95 96 97 98 99 100 101 102 103 104 105 def default_PreprocessingSettingsModel () -> PreprocessingSettingsModel : \"\"\"Create a PreprocessingSettingsModel instance with default values. Returns: PreprocessingSettingsModel: A PreprocessingSettingsModel instance with default values. \"\"\" return PreprocessingSettingsModel ( apply_stopwords_deletion = False , apply_parsing_filter = False , apply_lemmatization = False , spacy_language_model = \"fr_core_news_md\" , ) default_SamplingSettingsModel () \u00b6 Create a SamplingSettingsModel instance with default values. Returns: Name Type Description SamplingSettingsModel SamplingSettingsModel A SamplingSettingsModel instance with default values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 409 410 411 412 413 414 415 416 417 418 419 420 def default_SamplingSettingsModel () -> SamplingSettingsModel : \"\"\"Create a SamplingSettingsModel instance with default values. Returns: SamplingSettingsModel: A SamplingSettingsModel instance with default values. \"\"\" return SamplingSettingsModel ( algorithm = SamplingAlgorithm . CLOSEST_IN_DIFFERENT_CLUSTERS , random_seed = 42 , nb_to_select = 25 , init_kargs = None , ) default_VectorizationSettingsModel () \u00b6 Create a VectorizationSettingsModel instance with default values. Returns: Name Type Description VectorizationSettingsModel VectorizationSettingsModel A VectorizationSettingsModel instance with default values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 215 216 217 218 219 220 221 222 223 224 225 def default_VectorizationSettingsModel () -> VectorizationSettingsModel : \"\"\"Create a VectorizationSettingsModel instance with default values. Returns: VectorizationSettingsModel: A VectorizationSettingsModel instance with default values. \"\"\" return VectorizationSettingsModel ( vectorizer_type = VectorizerType . TFIDF , spacy_language_model = None , random_seed = 42 , )","title":"settings"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.ClusterRestriction","text":"Bases: str , enum . Enum The enumeration of available cluster restrictions for custom sampling algorithm. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 243 244 245 246 247 class ClusterRestriction ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available cluster restrictions for custom sampling algorithm.\"\"\" SAME_CLUSTER : str = \"same_cluster\" DIFFERENT_CLUSTERS : str = \"different_clusters\"","title":"ClusterRestriction"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.ClusteringAlgorithmEnum","text":"Bases: str , enum . Enum The enumeration of available clustering algorithms. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 428 429 430 431 432 433 class ClusteringAlgorithmEnum ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available clustering algorithms.\"\"\" KMEANS : str = \"kmeans\" HIERARCHICAL : str = \"hierarchical\" SPECTRAL : str = \"spectral\"","title":"ClusteringAlgorithmEnum"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.ClusteringSettingsModel","text":"Bases: BaseModel The body model for clustering settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 class ClusteringSettingsModel ( BaseModel ): \"\"\"The body model for clustering settings.\"\"\" # Parameters. algorithm : ClusteringAlgorithmEnum random_seed : int nb_clusters : int init_kargs : Union [ None , KmeansInitSettingsModel , HierarchicalInitSettingsModel , SpectralInitSettingsModel ] @validator ( \"random_seed\" ) @classmethod def validate_random_seed ( cls , value : int ) -> int : \"\"\"The validation of random_seed settings. Args: value (int): The value of random_seed setting. Raises: ValueError: if `random_seed` is incorrectly set. Returns: int: The value of random_seed setting. \"\"\" if value < 0 : raise ValueError ( \"`random_seed` must be greater than or equal to 0.\" ) return value @validator ( \"nb_clusters\" ) @classmethod def validate_nb_clusters ( cls , value : int ) -> int : \"\"\"The validation of nb_clusters settings. Args: value (int): The value of nb_clusters setting. Raises: ValueError: if `nb_clusters` is incorrectly set. Returns: int: The value of nb_clusters setting. \"\"\" if value < 2 : raise ValueError ( \"`nb_clusters` must be greater than or equal to 2.\" ) return value @root_validator @classmethod def validate_clustering_settings ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"The validation of clustering settings. Args: values (Dict[str, Any]): The values of clustering settings. Raises: ValueError: if `algorithm` and `init_kargs` are incompatible. Returns: Dict[str, Any]: The validated values of clustering settings. \"\"\" # Case of no clustering algorithm. if \"algorithm\" not in values . keys (): raise ValueError ( \"The parameter `algorithm` is required.\" ) # Case of kmeans clustering algorithm. if values [ \"algorithm\" ] == ClusteringAlgorithmEnum . KMEANS : # Case of no init parameters. if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `kmeans`.\" ) # Case of wrong type init parameters. if not isinstance ( values [ \"init_kargs\" ], KmeansInitSettingsModel ): raise ValueError ( \"The dictionary of initialization (`init_kargs`) is incompatible with algorithm `kmeans`.\" ) # Case of hierarchical clustering algorithm. if values [ \"algorithm\" ] == ClusteringAlgorithmEnum . HIERARCHICAL : # Case of no init parameters. if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `hierarchical`.\" ) # Case of wrong type init parameters. if not isinstance ( values [ \"init_kargs\" ], HierarchicalInitSettingsModel ): raise ValueError ( \"The dictionary of initialization (`init_kargs`) is incompatible with algorithm `hierarchical`.\" ) # Case of spectral clustering algorithm. if values [ \"algorithm\" ] == ClusteringAlgorithmEnum . SPECTRAL : # Case of no init parameters. if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `spectral`.\" ) # Case of wrong type init parameters. if not isinstance ( values [ \"init_kargs\" ], SpectralInitSettingsModel ): raise ValueError ( \"The dictionary of initialization (`init_kargs`) is incompatible with algorithm `spectral`.\" ) # Return validated values of sampling settings. return values # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"algorithm\" : self . algorithm . value , \"random_seed\" : self . random_seed , \"nb_clusters\" : self . nb_clusters , \"init_kargs\" : self . init_kargs . to_dict () if ( self . init_kargs is not None ) else {}, } # Config for schema. class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of clustering settings.\"\"\" schema_extra = { \"example\" : { \"algorithm\" : ( ClusteringAlgorithmEnum . KMEANS + \"|\" + ClusteringAlgorithmEnum . HIERARCHICAL + \"|\" + ClusteringAlgorithmEnum . SPECTRAL ), \"random_seed\" : 42 , \"nb_clusters\" : 2 , \"init_kargs\" : { \"!!!SPECIFIC: 'algorithm'=='kmeans'\" : { \"model\" : KmeansModelEnum . COP , \"max_iteration\" : 150 , \"tolerance\" : 0.0001 , }, \"!!!SPECIFIC: 'algorithm'=='hierarchical'\" : { \"linkage\" : ( HierarchicalLinkageEnum . WARD + \"|\" + HierarchicalLinkageEnum . AVERAGE + \"|\" + HierarchicalLinkageEnum . COMPLETE + \"|\" + HierarchicalLinkageEnum . SINGLE ), }, \"!!!SPECIFIC: 'algorithm'=='spectral'\" : { \"model\" : SpectralModelEnum . SPEC , \"nb_components\" : None , }, }, } }","title":"ClusteringSettingsModel"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.ClusteringSettingsModel.Config","text":"Configuration for body model of clustering settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of clustering settings.\"\"\" schema_extra = { \"example\" : { \"algorithm\" : ( ClusteringAlgorithmEnum . KMEANS + \"|\" + ClusteringAlgorithmEnum . HIERARCHICAL + \"|\" + ClusteringAlgorithmEnum . SPECTRAL ), \"random_seed\" : 42 , \"nb_clusters\" : 2 , \"init_kargs\" : { \"!!!SPECIFIC: 'algorithm'=='kmeans'\" : { \"model\" : KmeansModelEnum . COP , \"max_iteration\" : 150 , \"tolerance\" : 0.0001 , }, \"!!!SPECIFIC: 'algorithm'=='hierarchical'\" : { \"linkage\" : ( HierarchicalLinkageEnum . WARD + \"|\" + HierarchicalLinkageEnum . AVERAGE + \"|\" + HierarchicalLinkageEnum . COMPLETE + \"|\" + HierarchicalLinkageEnum . SINGLE ), }, \"!!!SPECIFIC: 'algorithm'=='spectral'\" : { \"model\" : SpectralModelEnum . SPEC , \"nb_components\" : None , }, }, } }","title":"Config"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.ClusteringSettingsModel.to_dict","text":"Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 716 717 718 719 720 721 722 723 724 725 726 727 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"algorithm\" : self . algorithm . value , \"random_seed\" : self . random_seed , \"nb_clusters\" : self . nb_clusters , \"init_kargs\" : self . init_kargs . to_dict () if ( self . init_kargs is not None ) else {}, }","title":"to_dict()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.ClusteringSettingsModel.validate_clustering_settings","text":"The validation of clustering settings. Parameters: Name Type Description Default values Dict [ str , Any ] The values of clustering settings. required Raises: Type Description ValueError if algorithm and init_kargs are incompatible. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: The validated values of clustering settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 @root_validator @classmethod def validate_clustering_settings ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"The validation of clustering settings. Args: values (Dict[str, Any]): The values of clustering settings. Raises: ValueError: if `algorithm` and `init_kargs` are incompatible. Returns: Dict[str, Any]: The validated values of clustering settings. \"\"\" # Case of no clustering algorithm. if \"algorithm\" not in values . keys (): raise ValueError ( \"The parameter `algorithm` is required.\" ) # Case of kmeans clustering algorithm. if values [ \"algorithm\" ] == ClusteringAlgorithmEnum . KMEANS : # Case of no init parameters. if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `kmeans`.\" ) # Case of wrong type init parameters. if not isinstance ( values [ \"init_kargs\" ], KmeansInitSettingsModel ): raise ValueError ( \"The dictionary of initialization (`init_kargs`) is incompatible with algorithm `kmeans`.\" ) # Case of hierarchical clustering algorithm. if values [ \"algorithm\" ] == ClusteringAlgorithmEnum . HIERARCHICAL : # Case of no init parameters. if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `hierarchical`.\" ) # Case of wrong type init parameters. if not isinstance ( values [ \"init_kargs\" ], HierarchicalInitSettingsModel ): raise ValueError ( \"The dictionary of initialization (`init_kargs`) is incompatible with algorithm `hierarchical`.\" ) # Case of spectral clustering algorithm. if values [ \"algorithm\" ] == ClusteringAlgorithmEnum . SPECTRAL : # Case of no init parameters. if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `spectral`.\" ) # Case of wrong type init parameters. if not isinstance ( values [ \"init_kargs\" ], SpectralInitSettingsModel ): raise ValueError ( \"The dictionary of initialization (`init_kargs`) is incompatible with algorithm `spectral`.\" ) # Return validated values of sampling settings. return values","title":"validate_clustering_settings()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.ClusteringSettingsModel.validate_nb_clusters","text":"The validation of nb_clusters settings. Parameters: Name Type Description Default value int The value of nb_clusters setting. required Raises: Type Description ValueError if nb_clusters is incorrectly set. Returns: Name Type Description int int The value of nb_clusters setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 @validator ( \"nb_clusters\" ) @classmethod def validate_nb_clusters ( cls , value : int ) -> int : \"\"\"The validation of nb_clusters settings. Args: value (int): The value of nb_clusters setting. Raises: ValueError: if `nb_clusters` is incorrectly set. Returns: int: The value of nb_clusters setting. \"\"\" if value < 2 : raise ValueError ( \"`nb_clusters` must be greater than or equal to 2.\" ) return value","title":"validate_nb_clusters()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.ClusteringSettingsModel.validate_random_seed","text":"The validation of random_seed settings. Parameters: Name Type Description Default value int The value of random_seed setting. required Raises: Type Description ValueError if random_seed is incorrectly set. Returns: Name Type Description int int The value of random_seed setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 @validator ( \"random_seed\" ) @classmethod def validate_random_seed ( cls , value : int ) -> int : \"\"\"The validation of random_seed settings. Args: value (int): The value of random_seed setting. Raises: ValueError: if `random_seed` is incorrectly set. Returns: int: The value of random_seed setting. \"\"\" if value < 0 : raise ValueError ( \"`random_seed` must be greater than or equal to 0.\" ) return value","title":"validate_random_seed()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.CustomSamplingInitSettingsModel","text":"Bases: BaseModel The body submodel for custom sampling initialization settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 class CustomSamplingInitSettingsModel ( BaseModel ): \"\"\"The body submodel for custom sampling initialization settings.\"\"\" # Parameters. clusters_restriction : ClusterRestriction distance_restriction : DistanceRestriction without_inferred_constraints : bool # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"clusters_restriction\" : self . clusters_restriction . value , \"distance_restriction\" : self . distance_restriction . value , \"without_inferred_constraints\" : self . without_inferred_constraints , }","title":"CustomSamplingInitSettingsModel"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.CustomSamplingInitSettingsModel.to_dict","text":"Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 266 267 268 269 270 271 272 273 274 275 276 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"clusters_restriction\" : self . clusters_restriction . value , \"distance_restriction\" : self . distance_restriction . value , \"without_inferred_constraints\" : self . without_inferred_constraints , }","title":"to_dict()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.DistanceRestriction","text":"Bases: str , enum . Enum The enumeration of available distance restrictions for custom sampling algorithm. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 250 251 252 253 254 class DistanceRestriction ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available distance restrictions for custom sampling algorithm.\"\"\" CLOSEST_NEIGHBORS : str = \"closest_neighbors\" FARTHEST_NEIGHBORS : str = \"farthest_neighbors\"","title":"DistanceRestriction"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.HierarchicalInitSettingsModel","text":"Bases: BaseModel The body submodel for hierarchical instantiation settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 class HierarchicalInitSettingsModel ( BaseModel ): \"\"\"The body submodel for hierarchical instantiation settings.\"\"\" # Parameters. linkage : HierarchicalLinkageEnum # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"linkage\" : self . linkage . value , }","title":"HierarchicalInitSettingsModel"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.HierarchicalInitSettingsModel.to_dict","text":"Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 529 530 531 532 533 534 535 536 537 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"linkage\" : self . linkage . value , }","title":"to_dict()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.HierarchicalLinkageEnum","text":"Bases: str , enum . Enum The enumeration of available hierarchical linkages. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 513 514 515 516 517 518 519 class HierarchicalLinkageEnum ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available hierarchical linkages.\"\"\" AVERAGE : str = \"average\" COMPLETE : str = \"complete\" SINGLE : str = \"single\" WARD : str = \"ward\"","title":"HierarchicalLinkageEnum"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.ICGUISettings","text":"Bases: str , enum . Enum The enumeration of available Settings for Interactive Clustering GUI. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class ICGUISettings ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available Settings for Interactive Clustering GUI.\"\"\" PREPROCESSING : str = \"preprocessing\" VECTORIZATION : str = \"vectorization\" SAMPLING : str = \"sampling\" CLUSTERING : str = \"clustering\" @classmethod def contains ( cls , value : Any ) -> bool : \"\"\"Test if value is in this enumeration. Args: value (Any): A value. Returns: bool: `True` if the value is in the enumeration. \"\"\" return value in cls . _value2member_map_","title":"ICGUISettings"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.ICGUISettings.contains","text":"Test if value is in this enumeration. Parameters: Name Type Description Default value Any A value. required Returns: Name Type Description bool bool True if the value is in the enumeration. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 33 34 35 36 37 38 39 40 41 42 43 @classmethod def contains ( cls , value : Any ) -> bool : \"\"\"Test if value is in this enumeration. Args: value (Any): A value. Returns: bool: `True` if the value is in the enumeration. \"\"\" return value in cls . _value2member_map_","title":"contains()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.KmeansInitSettingsModel","text":"Bases: BaseModel The body submodel for kmeans instantiation settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 class KmeansInitSettingsModel ( BaseModel ): \"\"\"The body submodel for kmeans instantiation settings.\"\"\" # Parameters. model : KmeansModelEnum max_iteration : int tolerance : float @validator ( \"max_iteration\" ) @classmethod def validate_max_iteration ( cls , value : int ) -> int : \"\"\"The validation of max_iteration settings. Args: value (int): The value of max_iteration setting. Raises: ValueError: if `max_iteration` is incorrectly set. Returns: int: The value of max_iteration setting. \"\"\" if value < 1 : raise ValueError ( \"`max_iteration` must be greater than or equal to 1.\" ) return value @validator ( \"tolerance\" ) @classmethod def validate_tolerance ( cls , value : float ) -> float : \"\"\"The validation of tolerance settings. Args: value (float): The value of tolerance setting. Raises: ValueError: if `tolerance` is incorrectly set. Returns: float: The value of tolerance setting. \"\"\" if value < 0 : raise ValueError ( \"The `tolerance` must be greater than 0.0.\" ) return value # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"model\" : self . model . value , \"max_iteration\" : self . max_iteration , \"tolerance\" : self . tolerance , }","title":"KmeansInitSettingsModel"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.KmeansInitSettingsModel.to_dict","text":"Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 487 488 489 490 491 492 493 494 495 496 497 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"model\" : self . model . value , \"max_iteration\" : self . max_iteration , \"tolerance\" : self . tolerance , }","title":"to_dict()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.KmeansInitSettingsModel.validate_max_iteration","text":"The validation of max_iteration settings. Parameters: Name Type Description Default value int The value of max_iteration setting. required Raises: Type Description ValueError if max_iteration is incorrectly set. Returns: Name Type Description int int The value of max_iteration setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 @validator ( \"max_iteration\" ) @classmethod def validate_max_iteration ( cls , value : int ) -> int : \"\"\"The validation of max_iteration settings. Args: value (int): The value of max_iteration setting. Raises: ValueError: if `max_iteration` is incorrectly set. Returns: int: The value of max_iteration setting. \"\"\" if value < 1 : raise ValueError ( \"`max_iteration` must be greater than or equal to 1.\" ) return value","title":"validate_max_iteration()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.KmeansInitSettingsModel.validate_tolerance","text":"The validation of tolerance settings. Parameters: Name Type Description Default value float The value of tolerance setting. required Raises: Type Description ValueError if tolerance is incorrectly set. Returns: Name Type Description float float The value of tolerance setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 @validator ( \"tolerance\" ) @classmethod def validate_tolerance ( cls , value : float ) -> float : \"\"\"The validation of tolerance settings. Args: value (float): The value of tolerance setting. Raises: ValueError: if `tolerance` is incorrectly set. Returns: float: The value of tolerance setting. \"\"\" if value < 0 : raise ValueError ( \"The `tolerance` must be greater than 0.0.\" ) return value","title":"validate_tolerance()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.KmeansModelEnum","text":"Bases: str , enum . Enum The enumeration of available kmeans models. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 436 437 438 439 class KmeansModelEnum ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available kmeans models.\"\"\" COP : str = \"COP\"","title":"KmeansModelEnum"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.PreprocessingSettingsModel","text":"Bases: BaseModel The body model for preprocessing settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class PreprocessingSettingsModel ( BaseModel ): \"\"\"The body model for preprocessing settings.\"\"\" # Parameters. apply_stopwords_deletion : bool apply_parsing_filter : bool apply_lemmatization : bool spacy_language_model : PreprocessingSpacyLanguageModel # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"apply_stopwords_deletion\" : self . apply_stopwords_deletion , \"apply_parsing_filter\" : self . apply_parsing_filter , \"apply_lemmatization\" : self . apply_lemmatization , \"spacy_language_model\" : self . spacy_language_model . value , } # Config for schema. class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of preprocessing settings.\"\"\" schema_extra = { \"example\" : { \"apply_stopwords_deletion\" : False , \"apply_parsing_filter\" : False , \"apply_lemmatization\" : False , \"spacy_language_model\" : PreprocessingSpacyLanguageModel . FR_CORE_NEWS_MD , } }","title":"PreprocessingSettingsModel"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.PreprocessingSettingsModel.Config","text":"Configuration for body model of preprocessing settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 81 82 83 84 85 86 87 88 89 90 91 class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of preprocessing settings.\"\"\" schema_extra = { \"example\" : { \"apply_stopwords_deletion\" : False , \"apply_parsing_filter\" : False , \"apply_lemmatization\" : False , \"spacy_language_model\" : PreprocessingSpacyLanguageModel . FR_CORE_NEWS_MD , } }","title":"Config"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.PreprocessingSettingsModel.to_dict","text":"Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 67 68 69 70 71 72 73 74 75 76 77 78 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"apply_stopwords_deletion\" : self . apply_stopwords_deletion , \"apply_parsing_filter\" : self . apply_parsing_filter , \"apply_lemmatization\" : self . apply_lemmatization , \"spacy_language_model\" : self . spacy_language_model . value , }","title":"to_dict()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.PreprocessingSpacyLanguageModel","text":"Bases: str , enum . Enum The enumeration of available spacy language model name. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 51 52 53 54 class PreprocessingSpacyLanguageModel ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available spacy language model name.\"\"\" FR_CORE_NEWS_MD : str = \"fr_core_news_md\"","title":"PreprocessingSpacyLanguageModel"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.SamplingAlgorithm","text":"Bases: str , enum . Enum The enumeration of available sampling algorithms. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 233 234 235 236 237 238 239 240 class SamplingAlgorithm ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available sampling algorithms.\"\"\" RANDOM : str = \"random\" RANDOM_IN_SAME_CLUSTER : str = \"random_in_same_cluster\" FARTHEST_IN_SAME_CLUSTER : str = \"farthest_in_same_cluster\" CLOSEST_IN_DIFFERENT_CLUSTERS : str = \"closest_in_different_clusters\" CUSTOM : str = \"custom\"","title":"SamplingAlgorithm"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.SamplingSettingsModel","text":"Bases: BaseModel Abstract body model for sampling settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 class SamplingSettingsModel ( BaseModel ): \"\"\"Abstract body model for sampling settings.\"\"\" # Parameters. algorithm : SamplingAlgorithm random_seed : int nb_to_select : int init_kargs : Optional [ CustomSamplingInitSettingsModel ] @validator ( \"random_seed\" ) @classmethod def validate_random_seed ( cls , value : int ) -> int : \"\"\"The validation of random_seed settings. Args: value (int): The value of random_seed setting. Raises: ValueError: if `random_seed` is incorrectly set. Returns: int: The value of random_seed setting. \"\"\" if value < 0 : raise ValueError ( \"`random_seed` must be greater than or equal to 0.\" ) return value @validator ( \"nb_to_select\" ) @classmethod def validate_nb_to_select ( cls , value : int ) -> int : \"\"\"The validation of nb_to_select settings. Args: value (int): The value of nb_to_select setting. Raises: ValueError: if `nb_to_select` is incorrectly set. Returns: int: The value of nb_to_select setting. \"\"\" if value < 1 : raise ValueError ( \"`nb_to_select` must be greater than or equal to 1.\" ) return value @root_validator @classmethod def validate_sampling_settings ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"The validation of sampling settings. Args: values (Dict[str, Any]): The values of sampling settings. Raises: ValueError: if `algorithm` and `init_kargs` are incompatible. Returns: Dict[str, Any]: The validated values of sampling settings. \"\"\" # Case of no sampling algorithm. if \"algorithm\" not in values . keys (): raise ValueError ( \"The parameter `algorithm` is required.\" ) # Case of custom sampling algorithm. if values [ \"algorithm\" ] == SamplingAlgorithm . CUSTOM : if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `custom`.\" ) # Case of predefinite sampling algorithms. else : if ( \"init_kargs\" in values . keys ()) and ( values [ \"init_kargs\" ] is not None ): raise ValueError ( \"No dictionary of initialization (`init_kargs`) is required when algorithm is different from `custom`.\" ) values [ \"init_kargs\" ] = None # Return validated values of sampling settings. return values # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"algorithm\" : self . algorithm . value , \"random_seed\" : self . random_seed , \"nb_to_select\" : self . nb_to_select , \"init_kargs\" : self . init_kargs . to_dict () if ( self . init_kargs is not None ) else None , } # Config for schema. class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of sampling settings.\"\"\" schema_extra = { \"example\" : { \"algorithm\" : ( SamplingAlgorithm . RANDOM + \"|\" + SamplingAlgorithm . RANDOM_IN_SAME_CLUSTER + \"|\" + SamplingAlgorithm . CLOSEST_IN_DIFFERENT_CLUSTERS + \"|\" + SamplingAlgorithm . FARTHEST_IN_SAME_CLUSTER + \"|\" + SamplingAlgorithm . CUSTOM ), \"random_seed\" : 42 , \"nb_to_select\" : 25 , \"!!!SPECIFIC: 'algorithm'=='custom'\" : { \"init_kargs\" : { \"clusters_restriction\" : ( ClusterRestriction . SAME_CLUSTER + \"|\" + ClusterRestriction . DIFFERENT_CLUSTERS ), \"distance_restriction\" : ( DistanceRestriction . CLOSEST_NEIGHBORS + \"|\" + DistanceRestriction . FARTHEST_NEIGHBORS ), \"without_inferred_constraints\" : True , }, }, } }","title":"SamplingSettingsModel"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.SamplingSettingsModel.Config","text":"Configuration for body model of sampling settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of sampling settings.\"\"\" schema_extra = { \"example\" : { \"algorithm\" : ( SamplingAlgorithm . RANDOM + \"|\" + SamplingAlgorithm . RANDOM_IN_SAME_CLUSTER + \"|\" + SamplingAlgorithm . CLOSEST_IN_DIFFERENT_CLUSTERS + \"|\" + SamplingAlgorithm . FARTHEST_IN_SAME_CLUSTER + \"|\" + SamplingAlgorithm . CUSTOM ), \"random_seed\" : 42 , \"nb_to_select\" : 25 , \"!!!SPECIFIC: 'algorithm'=='custom'\" : { \"init_kargs\" : { \"clusters_restriction\" : ( ClusterRestriction . SAME_CLUSTER + \"|\" + ClusterRestriction . DIFFERENT_CLUSTERS ), \"distance_restriction\" : ( DistanceRestriction . CLOSEST_NEIGHBORS + \"|\" + DistanceRestriction . FARTHEST_NEIGHBORS ), \"without_inferred_constraints\" : True , }, }, } }","title":"Config"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.SamplingSettingsModel.to_dict","text":"Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 362 363 364 365 366 367 368 369 370 371 372 373 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"algorithm\" : self . algorithm . value , \"random_seed\" : self . random_seed , \"nb_to_select\" : self . nb_to_select , \"init_kargs\" : self . init_kargs . to_dict () if ( self . init_kargs is not None ) else None , }","title":"to_dict()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.SamplingSettingsModel.validate_nb_to_select","text":"The validation of nb_to_select settings. Parameters: Name Type Description Default value int The value of nb_to_select setting. required Raises: Type Description ValueError if nb_to_select is incorrectly set. Returns: Name Type Description int int The value of nb_to_select setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 @validator ( \"nb_to_select\" ) @classmethod def validate_nb_to_select ( cls , value : int ) -> int : \"\"\"The validation of nb_to_select settings. Args: value (int): The value of nb_to_select setting. Raises: ValueError: if `nb_to_select` is incorrectly set. Returns: int: The value of nb_to_select setting. \"\"\" if value < 1 : raise ValueError ( \"`nb_to_select` must be greater than or equal to 1.\" ) return value","title":"validate_nb_to_select()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.SamplingSettingsModel.validate_random_seed","text":"The validation of random_seed settings. Parameters: Name Type Description Default value int The value of random_seed setting. required Raises: Type Description ValueError if random_seed is incorrectly set. Returns: Name Type Description int int The value of random_seed setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 @validator ( \"random_seed\" ) @classmethod def validate_random_seed ( cls , value : int ) -> int : \"\"\"The validation of random_seed settings. Args: value (int): The value of random_seed setting. Raises: ValueError: if `random_seed` is incorrectly set. Returns: int: The value of random_seed setting. \"\"\" if value < 0 : raise ValueError ( \"`random_seed` must be greater than or equal to 0.\" ) return value","title":"validate_random_seed()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.SamplingSettingsModel.validate_sampling_settings","text":"The validation of sampling settings. Parameters: Name Type Description Default values Dict [ str , Any ] The values of sampling settings. required Raises: Type Description ValueError if algorithm and init_kargs are incompatible. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: The validated values of sampling settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 @root_validator @classmethod def validate_sampling_settings ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"The validation of sampling settings. Args: values (Dict[str, Any]): The values of sampling settings. Raises: ValueError: if `algorithm` and `init_kargs` are incompatible. Returns: Dict[str, Any]: The validated values of sampling settings. \"\"\" # Case of no sampling algorithm. if \"algorithm\" not in values . keys (): raise ValueError ( \"The parameter `algorithm` is required.\" ) # Case of custom sampling algorithm. if values [ \"algorithm\" ] == SamplingAlgorithm . CUSTOM : if ( \"init_kargs\" not in values . keys ()) or ( values [ \"init_kargs\" ] is None ): raise ValueError ( \"A dictionary of initialization (`init_kargs`) is required when algorithm is `custom`.\" ) # Case of predefinite sampling algorithms. else : if ( \"init_kargs\" in values . keys ()) and ( values [ \"init_kargs\" ] is not None ): raise ValueError ( \"No dictionary of initialization (`init_kargs`) is required when algorithm is different from `custom`.\" ) values [ \"init_kargs\" ] = None # Return validated values of sampling settings. return values","title":"validate_sampling_settings()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.SpectralInitSettingsModel","text":"Bases: BaseModel The body submodel for spectral instantiation settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 class SpectralInitSettingsModel ( BaseModel ): \"\"\"The body submodel for spectral instantiation settings.\"\"\" # Parameters. model : SpectralModelEnum = SpectralModelEnum . SPEC nb_components : Optional [ int ] = None @validator ( \"nb_components\" ) @classmethod def validate_nb_components ( cls , value : Optional [ int ]) -> Optional [ int ]: \"\"\"The validation of nb_components settings. Args: value (Optional[int]): The value of nb_components setting. Raises: ValueError: if `nb_components` is incorrectly set. Returns: Optional[int]: The value of nb_components setting. \"\"\" if ( value is not None ) and ( value < 2 ): raise ValueError ( \"`nb_components` must be `None` or greater than or equal to 2.\" ) return value # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"model\" : self . model . value , \"nb_components\" : self . nb_components , }","title":"SpectralInitSettingsModel"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.SpectralInitSettingsModel.to_dict","text":"Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 584 585 586 587 588 589 590 591 592 593 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"model\" : self . model . value , \"nb_components\" : self . nb_components , }","title":"to_dict()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.SpectralInitSettingsModel.validate_nb_components","text":"The validation of nb_components settings. Parameters: Name Type Description Default value Optional [ int ] The value of nb_components setting. required Raises: Type Description ValueError if nb_components is incorrectly set. Returns: Type Description Optional [ int ] Optional[int]: The value of nb_components setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 @validator ( \"nb_components\" ) @classmethod def validate_nb_components ( cls , value : Optional [ int ]) -> Optional [ int ]: \"\"\"The validation of nb_components settings. Args: value (Optional[int]): The value of nb_components setting. Raises: ValueError: if `nb_components` is incorrectly set. Returns: Optional[int]: The value of nb_components setting. \"\"\" if ( value is not None ) and ( value < 2 ): raise ValueError ( \"`nb_components` must be `None` or greater than or equal to 2.\" ) return value","title":"validate_nb_components()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.SpectralModelEnum","text":"Bases: str , enum . Enum The enumeration of available spectral models. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 552 553 554 555 class SpectralModelEnum ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available spectral models.\"\"\" SPEC : str = \"SPEC\"","title":"SpectralModelEnum"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.VectorizationSettingsModel","text":"Bases: BaseModel The body model for vectorization settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class VectorizationSettingsModel ( BaseModel ): \"\"\"The body model for vectorization settings.\"\"\" # Parameters. vectorizer_type : VectorizerType spacy_language_model : Optional [ VectorizationSpacyLanguageModel ] random_seed : int @validator ( \"random_seed\" ) @classmethod def validate_random_seed ( cls , value : int ) -> int : \"\"\"The validation of random_seed settings. Args: value (int): The value of random_seed setting. Raises: ValueError: if `random_seed` is incorrectly set. Returns: int: The value of random_seed setting. \"\"\" if value < 0 : raise ValueError ( \"`random_seed` must be greater than or equal to 0.\" ) return value @root_validator @classmethod def validate_vectorization_settings ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"The validation of vectorization settings. Args: values (Dict[str, Any]): The values of vectorization settings. Raises: ValueError: if `vectorizer_type` and `spacy_language_model` are incompatible. Returns: Dict[str, Any]: The validated values of vectorization settings. \"\"\" # Case of no vectorizer. if \"vectorizer_type\" not in values . keys (): raise ValueError ( \"The parameter `vectorizer_type` is required.\" ) # Case of tfidf vectorizer. if values [ \"vectorizer_type\" ] == VectorizerType . TFIDF : if ( \"spacy_language_model\" in values . keys ()) and ( values [ \"spacy_language_model\" ] is not None ): raise ValueError ( \"No spacy language model is required when vectorizer is `tfidf`.\" ) values [ \"spacy_language_model\" ] = None # Case of spacy vectorizer. if values [ \"vectorizer_type\" ] == VectorizerType . SPACY : if ( \"spacy_language_model\" not in values . keys ()) or ( values [ \"spacy_language_model\" ] is None ): raise ValueError ( \"A spacy language model is required when vectorizer is `spacy`.\" ) # Return validated values of vectorization settings. return values # Export method. def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"vectorizer_type\" : self . vectorizer_type . value , \"spacy_language_model\" : self . spacy_language_model . value if ( self . spacy_language_model is not None ) else None , \"random_seed\" : self . random_seed , } # Config for schema. class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of vectorization settings.\"\"\" schema_extra = { \"example\" : { \"vectorizer_type\" : ( VectorizerType . TFIDF + \"|\" + VectorizerType . SPACY ), \"random_seed\" : 42 , \"!!!SPECIFIC: 'vectorizer_type'=='spacy'\" : { \"spacy_language_model\" : VectorizationSpacyLanguageModel . FR_CORE_NEWS_MD , }, } }","title":"VectorizationSettingsModel"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.VectorizationSettingsModel.Config","text":"Configuration for body model of vectorization settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 201 202 203 204 205 206 207 208 209 210 211 212 class Config : # noqa: WPS431 (nested class) \"\"\"Configuration for body model of vectorization settings.\"\"\" schema_extra = { \"example\" : { \"vectorizer_type\" : ( VectorizerType . TFIDF + \"|\" + VectorizerType . SPACY ), \"random_seed\" : 42 , \"!!!SPECIFIC: 'vectorizer_type'=='spacy'\" : { \"spacy_language_model\" : VectorizationSpacyLanguageModel . FR_CORE_NEWS_MD , }, } }","title":"Config"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.VectorizationSettingsModel.to_dict","text":"Export the model as a dictionary Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dictionary that contains paramaters and their values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 186 187 188 189 190 191 192 193 194 195 196 197 198 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export the model as a dictionary Returns: Dict[str, Any]: A dictionary that contains paramaters and their values. \"\"\" return { \"vectorizer_type\" : self . vectorizer_type . value , \"spacy_language_model\" : self . spacy_language_model . value if ( self . spacy_language_model is not None ) else None , \"random_seed\" : self . random_seed , }","title":"to_dict()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.VectorizationSettingsModel.validate_random_seed","text":"The validation of random_seed settings. Parameters: Name Type Description Default value int The value of random_seed setting. required Raises: Type Description ValueError if random_seed is incorrectly set. Returns: Name Type Description int int The value of random_seed setting. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @validator ( \"random_seed\" ) @classmethod def validate_random_seed ( cls , value : int ) -> int : \"\"\"The validation of random_seed settings. Args: value (int): The value of random_seed setting. Raises: ValueError: if `random_seed` is incorrectly set. Returns: int: The value of random_seed setting. \"\"\" if value < 0 : raise ValueError ( \"`random_seed` must be greater than or equal to 0.\" ) return value","title":"validate_random_seed()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.VectorizationSettingsModel.validate_vectorization_settings","text":"The validation of vectorization settings. Parameters: Name Type Description Default values Dict [ str , Any ] The values of vectorization settings. required Raises: Type Description ValueError if vectorizer_type and spacy_language_model are incompatible. Returns: Type Description Dict [ str , Any ] Dict[str, Any]: The validated values of vectorization settings. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @root_validator @classmethod def validate_vectorization_settings ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"The validation of vectorization settings. Args: values (Dict[str, Any]): The values of vectorization settings. Raises: ValueError: if `vectorizer_type` and `spacy_language_model` are incompatible. Returns: Dict[str, Any]: The validated values of vectorization settings. \"\"\" # Case of no vectorizer. if \"vectorizer_type\" not in values . keys (): raise ValueError ( \"The parameter `vectorizer_type` is required.\" ) # Case of tfidf vectorizer. if values [ \"vectorizer_type\" ] == VectorizerType . TFIDF : if ( \"spacy_language_model\" in values . keys ()) and ( values [ \"spacy_language_model\" ] is not None ): raise ValueError ( \"No spacy language model is required when vectorizer is `tfidf`.\" ) values [ \"spacy_language_model\" ] = None # Case of spacy vectorizer. if values [ \"vectorizer_type\" ] == VectorizerType . SPACY : if ( \"spacy_language_model\" not in values . keys ()) or ( values [ \"spacy_language_model\" ] is None ): raise ValueError ( \"A spacy language model is required when vectorizer is `spacy`.\" ) # Return validated values of vectorization settings. return values","title":"validate_vectorization_settings()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.VectorizationSpacyLanguageModel","text":"Bases: str , enum . Enum The enumeration of available spacy language model name. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 120 121 122 123 class VectorizationSpacyLanguageModel ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available spacy language model name.\"\"\" FR_CORE_NEWS_MD : str = \"fr_core_news_md\"","title":"VectorizationSpacyLanguageModel"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.VectorizerType","text":"Bases: str , enum . Enum The enumeration of available vectorizer type. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 113 114 115 116 117 class VectorizerType ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available vectorizer type.\"\"\" TFIDF : str = \"tfidf\" SPACY : str = \"spacy\"","title":"VectorizerType"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.default_ClusteringSettingsModel","text":"Create a ClusteringSettingsModel instance with default values. Returns: Name Type Description ClusteringSettingsModel ClusteringSettingsModel A ClusteringSettingsModel instance with default values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 770 771 772 773 774 775 776 777 778 779 780 781 def default_ClusteringSettingsModel () -> ClusteringSettingsModel : \"\"\"Create a ClusteringSettingsModel instance with default values. Returns: ClusteringSettingsModel: A ClusteringSettingsModel instance with default values. \"\"\" return ClusteringSettingsModel ( algorithm = ClusteringAlgorithmEnum . KMEANS , random_seed = 42 , nb_clusters = 2 , init_kargs = default_KmeansInitSettingsModel (), )","title":"default_ClusteringSettingsModel()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.default_KmeansInitSettingsModel","text":"Create a KmeansInitSettingsModel instance with default values. Returns: Name Type Description KmeansInitSettingsModel KmeansInitSettingsModel A KmeansInitSettingsModel instance with default values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 500 501 502 503 504 505 506 507 508 509 510 def default_KmeansInitSettingsModel () -> KmeansInitSettingsModel : \"\"\"Create a KmeansInitSettingsModel instance with default values. Returns: KmeansInitSettingsModel: A KmeansInitSettingsModel instance with default values. \"\"\" return KmeansInitSettingsModel ( model = KmeansModelEnum . COP , max_iteration = 150 , tolerance = 0.0001 , )","title":"default_KmeansInitSettingsModel()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.default_PreprocessingSettingsModel","text":"Create a PreprocessingSettingsModel instance with default values. Returns: Name Type Description PreprocessingSettingsModel PreprocessingSettingsModel A PreprocessingSettingsModel instance with default values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 94 95 96 97 98 99 100 101 102 103 104 105 def default_PreprocessingSettingsModel () -> PreprocessingSettingsModel : \"\"\"Create a PreprocessingSettingsModel instance with default values. Returns: PreprocessingSettingsModel: A PreprocessingSettingsModel instance with default values. \"\"\" return PreprocessingSettingsModel ( apply_stopwords_deletion = False , apply_parsing_filter = False , apply_lemmatization = False , spacy_language_model = \"fr_core_news_md\" , )","title":"default_PreprocessingSettingsModel()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.default_SamplingSettingsModel","text":"Create a SamplingSettingsModel instance with default values. Returns: Name Type Description SamplingSettingsModel SamplingSettingsModel A SamplingSettingsModel instance with default values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 409 410 411 412 413 414 415 416 417 418 419 420 def default_SamplingSettingsModel () -> SamplingSettingsModel : \"\"\"Create a SamplingSettingsModel instance with default values. Returns: SamplingSettingsModel: A SamplingSettingsModel instance with default values. \"\"\" return SamplingSettingsModel ( algorithm = SamplingAlgorithm . CLOSEST_IN_DIFFERENT_CLUSTERS , random_seed = 42 , nb_to_select = 25 , init_kargs = None , )","title":"default_SamplingSettingsModel()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/settings/#cognitivefactory.interactive_clustering_gui.models.settings.default_VectorizationSettingsModel","text":"Create a VectorizationSettingsModel instance with default values. Returns: Name Type Description VectorizationSettingsModel VectorizationSettingsModel A VectorizationSettingsModel instance with default values. Source code in cognitivefactory\\interactive_clustering_gui\\models\\settings.py 215 216 217 218 219 220 221 222 223 224 225 def default_VectorizationSettingsModel () -> VectorizationSettingsModel : \"\"\"Create a VectorizationSettingsModel instance with default values. Returns: VectorizationSettingsModel: A VectorizationSettingsModel instance with default values. \"\"\" return VectorizationSettingsModel ( vectorizer_type = VectorizerType . TFIDF , spacy_language_model = None , random_seed = 42 , )","title":"default_VectorizationSettingsModel()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/states/","text":"Name: cognitivefactory.interactive_clustering_gui.models.states Description: Definition of models required to define states of interactive clustering. Author: Erwan Schild Created: 25/04/2022 Licence: CeCILL-C License v1.0 ( https://cecill.info/licences.fr.html ) ICGUIStates \u00b6 Bases: str , enum . Enum The enumeration of available States for Interactive Clustering GUI. Source code in cognitivefactory\\interactive_clustering_gui\\models\\states.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 class ICGUIStates ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available States for Interactive Clustering GUI.\"\"\" ### ### Case of project initialization. ### INITIALIZATION_WITHOUT_MODELIZATION : str = \"INITIALIZATION_WITHOUT_MODELIZATION\" INITIALIZATION_WITH_PENDING_MODELIZATION : str = \"INITIALIZATION_WITH_PENDING_MODELIZATION\" INITIALIZATION_WITH_WORKING_MODELIZATION : str = \"INITIALIZATION_WITH_WORKING_MODELIZATION\" INITIALIZATION_WITH_ERRORS : str = \"INITIALIZATION_WITH_ERRORS\" ### ### Case of constraints sampling. ### # Sampling tasks. SAMPLING_TODO : str = \"SAMPLING_TODO\" SAMPLING_PENDING : str = \"SAMPLING_PENDING\" SAMPLING_WORKING : str = \"SAMPLING_WORKING\" # Import on sampling step. IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION : str = \"IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION\" IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION : str = \"IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION\" IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION : str = \"IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION\" IMPORT_AT_SAMPLING_STEP_WITH_ERRORS : str = \"IMPORT_AT_SAMPLING_STEP_WITH_ERRORS\" ### ### Case of constraints annotation. ### # Modelization up to date. ANNOTATION_WITH_UPTODATE_MODELIZATION : str = \"ANNOTATION_WITH_UPTODATE_MODELIZATION\" # Modelization outdated, without conflicts. ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS : str = ( \"ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS\" ) ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS : str = ( \"ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS\" ) ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS : str = ( \"ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS\" ) # Modelization outdated, with conflicts. ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS : str = \"ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS\" ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS : str = \"ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS\" ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS : str = \"ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS\" # Import on annotation step. IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION : str = \"IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION\" IMPORT_AT_ANNOTATION_STEP_WITH_PENDING_MODELIZATION : str = \"IMPORT_AT_ANNOTATION_STEP_WITH_PENDING_MODELIZATION\" IMPORT_AT_ANNOTATION_STEP_WITH_WORKING_MODELIZATION : str = \"IMPORT_AT_ANNOTATION_STEP_WITH_WORKING_MODELIZATION\" IMPORT_AT_ANNOTATION_STEP_WITH_ERRORS : str = \"IMPORT_AT_ANNOTATION_STEP_WITH_ERRORS\" ### ### Case of constrained clustering. ### # Clustering tasks. CLUSTERING_TODO : str = \"CLUSTERING_TODO\" CLUSTERING_PENDING : str = \"CLUSTERING_PENDING\" CLUSTERING_WORKING : str = \"CLUSTERING_WORKING\" # Import on clustering step. IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION : str = \"IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION\" IMPORT_AT_CLUSTERING_STEP_WITH_PENDING_MODELIZATION : str = \"IMPORT_AT_CLUSTERING_STEP_WITH_PENDING_MODELIZATION\" IMPORT_AT_CLUSTERING_STEP_WITH_WORKING_MODELIZATION : str = \"IMPORT_AT_CLUSTERING_STEP_WITH_WORKING_MODELIZATION\" IMPORT_AT_CLUSTERING_STEP_WITH_ERRORS : str = \"IMPORT_AT_CLUSTERING_STEP_WITH_ERRORS\" ### ### Case of iteration end. ### # End of iteration. ITERATION_END : str = \"ITERATION_END\" # Import on iteration end. IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION : str = \"IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION\" IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION : str = \"IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION\" IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION : str = \"IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION\" IMPORT_AT_ITERATION_END_WITH_ERRORS : str = \"IMPORT_AT_ITERATION_END_WITH_ERRORS\" @classmethod def contains ( cls , state : str ) -> bool : \"\"\"Test if state is in this enumeration. Args: state (str): A state. Returns: bool: `True` if the state is in the enumeration. \"\"\" return state in cls . _value2member_map_ contains ( state ) classmethod \u00b6 Test if state is in this enumeration. Parameters: Name Type Description Default state str A state. required Returns: Name Type Description bool bool True if the state is in the enumeration. Source code in cognitivefactory\\interactive_clustering_gui\\models\\states.py 101 102 103 104 105 106 107 108 109 110 111 @classmethod def contains ( cls , state : str ) -> bool : \"\"\"Test if state is in this enumeration. Args: state (str): A state. Returns: bool: `True` if the state is in the enumeration. \"\"\" return state in cls . _value2member_map_ get_ICGUIStates_details ( state ) \u00b6 Get state details. Parameters: Name Type Description Default state ICGUIStates The state. required Returns: Type Description Dict [ str , Any ] Dict[str, Any]: The state details. Source code in cognitivefactory\\interactive_clustering_gui\\models\\states.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 def get_ICGUIStates_details ( state : ICGUIStates , ) -> Dict [ str , Any ]: \"\"\" Get state details. Args: state (ICGUIStates): The state. Returns: Dict[str, Any]: The state details. \"\"\" map_of_ICGUIStates_details : Dict [ ICGUIStates , Dict [ str , Any ]] = { ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"TODO\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . INITIALIZATION_WITH_PENDING_MODELIZATION : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . INITIALIZATION_WITH_WORKING_MODELIZATION : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . INITIALIZATION_WITH_ERRORS : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"ERROR\" , \"conflict_status\" : \"UNKNOWN\" , }, ### ### Case of constraints sampling. ### # Sampling tasks. ICGUIStates . SAMPLING_TODO : { \"step\" : \"SAMPLING\" , \"step_status\" : \"TODO\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, ICGUIStates . SAMPLING_PENDING : { \"step\" : \"SAMPLING\" , \"step_status\" : \"PENDING\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, ICGUIStates . SAMPLING_WORKING : { \"step\" : \"SAMPLING\" , \"step_status\" : \"WORKING\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, # Import on sampling step. ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION : { \"step\" : \"SAMPLING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"TODO\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION : { \"step\" : \"SAMPLING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION : { \"step\" : \"SAMPLING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_ERRORS : { \"step\" : \"SAMPLING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"ERROR\" , \"conflict_status\" : \"UNKNOWN\" , }, ### ### Case of constraints annotation. ### # Modelization up to date. ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"TODO\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, # Modelization outdated, without conflicts. ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"TODO\" , \"modelization_status\" : \"OUTDATED\" , \"conflict_status\" : \"FALSE\" , }, ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"FALSE\" , }, ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"FALSE\" , }, # Modelization outdated, with conflicts. ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"TODO\" , \"modelization_status\" : \"OUTDATED\" , \"conflict_status\" : \"TRUE\" , }, ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"TRUE\" , }, ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"TRUE\" , }, # Import on annotation step. ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"TODO\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_PENDING_MODELIZATION : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_WORKING_MODELIZATION : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_ERRORS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"ERROR\" , \"conflict_status\" : \"UNKNOWN\" , }, ### ### Case of constrained clustering. ### # Clustering tasks. ICGUIStates . CLUSTERING_TODO : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"TODO\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, ICGUIStates . CLUSTERING_PENDING : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"PENDING\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, ICGUIStates . CLUSTERING_WORKING : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"WORKING\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, # Import on clustering step. ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"TODO\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_PENDING_MODELIZATION : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_WORKING_MODELIZATION : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_ERRORS : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"ERROR\" , \"conflict_status\" : \"UNKNOWN\" , }, ### ### Case of iteration end. ### # End of iteration. ICGUIStates . ITERATION_END : { \"step\" : \"ITERATION_END\" , \"step_status\" : \"TODO\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, # Import on iteration end. ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION : { \"step\" : \"ITERATION_END\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"TODO\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION : { \"step\" : \"ITERATION_END\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION : { \"step\" : \"ITERATION_END\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_ITERATION_END_WITH_ERRORS : { \"step\" : \"ITERATION_END\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"ERROR\" , \"conflict_status\" : \"UNKNOWN\" , }, } return map_of_ICGUIStates_details [ state ]","title":"states"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/states/#cognitivefactory.interactive_clustering_gui.models.states.ICGUIStates","text":"Bases: str , enum . Enum The enumeration of available States for Interactive Clustering GUI. Source code in cognitivefactory\\interactive_clustering_gui\\models\\states.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 class ICGUIStates ( str , enum . Enum ): # noqa: WPS600 (subclassing str) \"\"\"The enumeration of available States for Interactive Clustering GUI.\"\"\" ### ### Case of project initialization. ### INITIALIZATION_WITHOUT_MODELIZATION : str = \"INITIALIZATION_WITHOUT_MODELIZATION\" INITIALIZATION_WITH_PENDING_MODELIZATION : str = \"INITIALIZATION_WITH_PENDING_MODELIZATION\" INITIALIZATION_WITH_WORKING_MODELIZATION : str = \"INITIALIZATION_WITH_WORKING_MODELIZATION\" INITIALIZATION_WITH_ERRORS : str = \"INITIALIZATION_WITH_ERRORS\" ### ### Case of constraints sampling. ### # Sampling tasks. SAMPLING_TODO : str = \"SAMPLING_TODO\" SAMPLING_PENDING : str = \"SAMPLING_PENDING\" SAMPLING_WORKING : str = \"SAMPLING_WORKING\" # Import on sampling step. IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION : str = \"IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION\" IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION : str = \"IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION\" IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION : str = \"IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION\" IMPORT_AT_SAMPLING_STEP_WITH_ERRORS : str = \"IMPORT_AT_SAMPLING_STEP_WITH_ERRORS\" ### ### Case of constraints annotation. ### # Modelization up to date. ANNOTATION_WITH_UPTODATE_MODELIZATION : str = \"ANNOTATION_WITH_UPTODATE_MODELIZATION\" # Modelization outdated, without conflicts. ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS : str = ( \"ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS\" ) ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS : str = ( \"ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS\" ) ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS : str = ( \"ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS\" ) # Modelization outdated, with conflicts. ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS : str = \"ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS\" ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS : str = \"ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS\" ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS : str = \"ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS\" # Import on annotation step. IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION : str = \"IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION\" IMPORT_AT_ANNOTATION_STEP_WITH_PENDING_MODELIZATION : str = \"IMPORT_AT_ANNOTATION_STEP_WITH_PENDING_MODELIZATION\" IMPORT_AT_ANNOTATION_STEP_WITH_WORKING_MODELIZATION : str = \"IMPORT_AT_ANNOTATION_STEP_WITH_WORKING_MODELIZATION\" IMPORT_AT_ANNOTATION_STEP_WITH_ERRORS : str = \"IMPORT_AT_ANNOTATION_STEP_WITH_ERRORS\" ### ### Case of constrained clustering. ### # Clustering tasks. CLUSTERING_TODO : str = \"CLUSTERING_TODO\" CLUSTERING_PENDING : str = \"CLUSTERING_PENDING\" CLUSTERING_WORKING : str = \"CLUSTERING_WORKING\" # Import on clustering step. IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION : str = \"IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION\" IMPORT_AT_CLUSTERING_STEP_WITH_PENDING_MODELIZATION : str = \"IMPORT_AT_CLUSTERING_STEP_WITH_PENDING_MODELIZATION\" IMPORT_AT_CLUSTERING_STEP_WITH_WORKING_MODELIZATION : str = \"IMPORT_AT_CLUSTERING_STEP_WITH_WORKING_MODELIZATION\" IMPORT_AT_CLUSTERING_STEP_WITH_ERRORS : str = \"IMPORT_AT_CLUSTERING_STEP_WITH_ERRORS\" ### ### Case of iteration end. ### # End of iteration. ITERATION_END : str = \"ITERATION_END\" # Import on iteration end. IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION : str = \"IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION\" IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION : str = \"IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION\" IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION : str = \"IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION\" IMPORT_AT_ITERATION_END_WITH_ERRORS : str = \"IMPORT_AT_ITERATION_END_WITH_ERRORS\" @classmethod def contains ( cls , state : str ) -> bool : \"\"\"Test if state is in this enumeration. Args: state (str): A state. Returns: bool: `True` if the state is in the enumeration. \"\"\" return state in cls . _value2member_map_","title":"ICGUIStates"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/states/#cognitivefactory.interactive_clustering_gui.models.states.ICGUIStates.contains","text":"Test if state is in this enumeration. Parameters: Name Type Description Default state str A state. required Returns: Name Type Description bool bool True if the state is in the enumeration. Source code in cognitivefactory\\interactive_clustering_gui\\models\\states.py 101 102 103 104 105 106 107 108 109 110 111 @classmethod def contains ( cls , state : str ) -> bool : \"\"\"Test if state is in this enumeration. Args: state (str): A state. Returns: bool: `True` if the state is in the enumeration. \"\"\" return state in cls . _value2member_map_","title":"contains()"},{"location":"reference/cognitivefactory/interactive_clustering_gui/models/states/#cognitivefactory.interactive_clustering_gui.models.states.get_ICGUIStates_details","text":"Get state details. Parameters: Name Type Description Default state ICGUIStates The state. required Returns: Type Description Dict [ str , Any ] Dict[str, Any]: The state details. Source code in cognitivefactory\\interactive_clustering_gui\\models\\states.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 def get_ICGUIStates_details ( state : ICGUIStates , ) -> Dict [ str , Any ]: \"\"\" Get state details. Args: state (ICGUIStates): The state. Returns: Dict[str, Any]: The state details. \"\"\" map_of_ICGUIStates_details : Dict [ ICGUIStates , Dict [ str , Any ]] = { ICGUIStates . INITIALIZATION_WITHOUT_MODELIZATION : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"TODO\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . INITIALIZATION_WITH_PENDING_MODELIZATION : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . INITIALIZATION_WITH_WORKING_MODELIZATION : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . INITIALIZATION_WITH_ERRORS : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"ERROR\" , \"conflict_status\" : \"UNKNOWN\" , }, ### ### Case of constraints sampling. ### # Sampling tasks. ICGUIStates . SAMPLING_TODO : { \"step\" : \"SAMPLING\" , \"step_status\" : \"TODO\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, ICGUIStates . SAMPLING_PENDING : { \"step\" : \"SAMPLING\" , \"step_status\" : \"PENDING\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, ICGUIStates . SAMPLING_WORKING : { \"step\" : \"SAMPLING\" , \"step_status\" : \"WORKING\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, # Import on sampling step. ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITHOUT_MODELIZATION : { \"step\" : \"SAMPLING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"TODO\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_PENDING_MODELIZATION : { \"step\" : \"SAMPLING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_WORKING_MODELIZATION : { \"step\" : \"SAMPLING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_SAMPLING_STEP_WITH_ERRORS : { \"step\" : \"SAMPLING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"ERROR\" , \"conflict_status\" : \"UNKNOWN\" , }, ### ### Case of constraints annotation. ### # Modelization up to date. ICGUIStates . ANNOTATION_WITH_UPTODATE_MODELIZATION : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"TODO\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, # Modelization outdated, without conflicts. ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITHOUT_CONFLICTS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"TODO\" , \"modelization_status\" : \"OUTDATED\" , \"conflict_status\" : \"FALSE\" , }, ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITHOUT_CONFLICTS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"FALSE\" , }, ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITHOUT_CONFLICTS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"FALSE\" , }, # Modelization outdated, with conflicts. ICGUIStates . ANNOTATION_WITH_OUTDATED_MODELIZATION_WITH_CONFLICTS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"TODO\" , \"modelization_status\" : \"OUTDATED\" , \"conflict_status\" : \"TRUE\" , }, ICGUIStates . ANNOTATION_WITH_PENDING_MODELIZATION_WITH_CONFLICTS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"TRUE\" , }, ICGUIStates . ANNOTATION_WITH_WORKING_MODELIZATION_WITH_CONFLICTS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"TRUE\" , }, # Import on annotation step. ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITHOUT_MODELIZATION : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"TODO\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_PENDING_MODELIZATION : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_WORKING_MODELIZATION : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_ANNOTATION_STEP_WITH_ERRORS : { \"step\" : \"ANNOTATION\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"ERROR\" , \"conflict_status\" : \"UNKNOWN\" , }, ### ### Case of constrained clustering. ### # Clustering tasks. ICGUIStates . CLUSTERING_TODO : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"TODO\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, ICGUIStates . CLUSTERING_PENDING : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"PENDING\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, ICGUIStates . CLUSTERING_WORKING : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"WORKING\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, # Import on clustering step. ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITHOUT_MODELIZATION : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"TODO\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_PENDING_MODELIZATION : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_WORKING_MODELIZATION : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_CLUSTERING_STEP_WITH_ERRORS : { \"step\" : \"CLUSTERING\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"ERROR\" , \"conflict_status\" : \"UNKNOWN\" , }, ### ### Case of iteration end. ### # End of iteration. ICGUIStates . ITERATION_END : { \"step\" : \"ITERATION_END\" , \"step_status\" : \"TODO\" , \"modelization_status\" : \"UPTODATE\" , \"conflict_status\" : \"FALSE\" , }, # Import on iteration end. ICGUIStates . IMPORT_AT_ITERATION_END_WITHOUT_MODELIZATION : { \"step\" : \"ITERATION_END\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"TODO\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_ITERATION_END_WITH_PENDING_MODELIZATION : { \"step\" : \"ITERATION_END\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"PENDING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_ITERATION_END_WITH_WORKING_MODELIZATION : { \"step\" : \"ITERATION_END\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"WORKING\" , \"conflict_status\" : \"UNKNOWN\" , }, ICGUIStates . IMPORT_AT_ITERATION_END_WITH_ERRORS : { \"step\" : \"ITERATION_END\" , \"step_status\" : \"LOCKED\" , \"modelization_status\" : \"ERROR\" , \"conflict_status\" : \"UNKNOWN\" , }, } return map_of_ICGUIStates_details [ state ]","title":"get_ICGUIStates_details()"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}